

<html>
	<head>
		<meta charset="utf-8">
		<title>MineKhan</title>
    <base href="https://minekhan.thingmaker.repl.co">
    <!--Metadata-->
    <meta name="keywords" content="Minekhan"> <!--search "Minekhan" on Google-->
    <meta name="description" content="Minekhan with survival and nether and many more features">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" id="themeColor">
    
		<link id="vtfont" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>@font-face{font-family: 'VT323'; src:url('mojangles.otf');}</style>
		<link rel="shortcut icon" type="image/ico" href="favicon.ico">
    <link rel="manifest" href="manifest.json">
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
    button, #onscreenControls, canvas, #loader{
		  /*get rid of user select*/
			-webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
		}
		.world-select {
			width: 99vw;
			min-width: 300px;
			height: calc(100vh - 220px);
			position: absolute;
			bottom: 120px;
			overflow-y: auto;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			margin: 0 auto;
		}
		.world {
			width: 250px;
			height: auto;
			border: 1px solid black;
			font-size: 16px;
			font-family: 'VT323', 'Courier New', Courier, monospace;
			color: rgb(180, 180, 180);
			margin: 0 auto;
			margin-top: 15px;
			padding: 5px;
			cursor: pointer;
		}
		strong {
			color: white;
		}
		.selected {
			border: 3px solid white;
			padding: 3px;
		}
		input[type=text] {
			background-color: black;
			caret-color: white;
			border: 2px solid gray;
			color: white;
			font-size: 24px;
			padding-left: 12px;
		}
		input[type=text]:focus {
			border: 2px solid lightgray;
		}
		#boxcentertop {
			z-index: 1;
			width: 80vw;
			max-width: 400px;
			height: 50px;
			position: relative;
			top: 30px;
			display: block;
			margin: 0 auto;
		}
		.hidden {
			display: none !important;
		}
		#onhover {
			background-color: rgba(0, 0, 0, 0.9);
			color: rgb(200, 200, 200);
			font-family: 'Courier New', Courier, monospace;
			word-wrap: normal;
			width: auto;
			max-width: 400px;
			position: absolute;
			z-index: 1;
			padding: 10px;
			cursor: default;
		}
		#quota {
			display: block;
			position: absolute;
			width: 99vw;
			margin: 0 auto;
			bottom: 110px;
			z-index: 1;
			background-color: RGBA(0, 0, 0, 0.6);
			justify-content: center;
			text-align: center;
			color: white;
		}
    #messagesHolder{
      position:absolute;
      z-index:2;
      top:0px;
      left:0px;
      background:#000a;
      color:white;
      font:18px 'VT323';
    }
    #messageInput{
      border:none;
      background:transparent;
      width:100%;
      min-width:100px;
      color:white;
      font:18px 'VT323';
    }
    #onscreenControls{
		    position:fixed;
		    font-family:monospace;
		    bottom:10px;
		    width:100%;
		}
		#onscreenControls button{
		    margin:0;
        min-width:calc(100% / 13);
        min-height:40px;
        border-radius:0px;
        background:#888;
        border-color:#aaa #666 #666 #aaa;
        border-width:2px;
        border-style:solid;
        color:white;
        outline:none;
		}
		#onscreenControls button:active{
	      background:#9a9a9a;
        border-color:#888 #aaa #aaa #888;
		}
		#onscreenControls #buttonsRight{
		    position:absolute;
		    bottom:10px;
		    right:10px;
		}
    #onscreenControls #buttonsTop{
		    position:absolute;
		    top:10px;
        left:10px;
        width:calc(100% - 20px);
        display:flex;
        align-items:center;
		}
    #loader{
      background:#111;
      color:white;
      position:absolute;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      font-size:40px;
      font-family:Arial;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      z-index:2;
    }
    #loader .name{
      font-size:60px;
      font-family:VT323;
    }
    #loadingImg{
      width:50px;
      image-rendering:pixelated;
    }
	</style>
	<body>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
	<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
	<div id="quota" class="hidden"></div>
	<div id="onhover" class="hidden"></div>
	<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		To save your world, copy/paste the saveString<br>
		from this box into the code on line 189.<br>
		var loadString = "Your Code Here";<br>
		Then save the program as a Spin-off.
	</p>
	<div class="world-select hidden" id="worlds"></div>
  <div class="world-select hidden" id="servers"></div>
  <div class="world-select hidden" id="marketplace"></div>
	<p id="message" class="hidden" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
  <div id="messagesHolder" class="hidden">
    <input id="messageInput" class="hidden">
    <div id="messages"></div>
  </div>
  <div id="onscreenControls" class="hidden">
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlW">W</button>
	  <br>
	  <button id="controlA">A</button><button style="visibility:hidden;">&nbsp;</button><button id="controlD">D</button>
	  <br>
	  <button style="visibility:hidden;">&nbsp;</button><button id="controlS">S</button>
    <div id="buttonsRight">
      <button id="controlSpace">space</button>
      <br>
      <button id="controlShift">shift</button>
    </div>
    <!--<div id="buttonsTop">
      <button id="controlPause">Pause</button>
    </div>-->
  </div>
  <div id="loader">
    <span class="name">MINEKHAN</span>
    <div id="loadProgress"></div><br>
    <img src="https://data.thingmaker.repl.co/images/loading.gif" id="loadingImg">
  </div>
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = ""
	</script>
  <!--url for parkour map: https://www.khanacademy.org/cs/i/4676725830008832-->
 	<script type="x-shader/vertex" id="blockVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		attribute float aShadow;
		attribute float aSkylight;
		attribute float aBlocklight;
		varying vec2  vTexture;
		varying float vShadow;
		varying float vFog;
		uniform mat4 uView;
		uniform float uDist;
		uniform vec3 uPos;
		uniform float uTime;
    uniform vec3 skyColor;

		void main() {
      float x = aTexture.x;
      float y = aTexture.y / 2.0;
			vTexture = vec2(x,y);
			// If you are going to change this final lightlevel calculation
			// you have to change line 4487 as well since it calculates lightlevel of entity based on this
			vShadow = aShadow * min(max(aSkylight * uTime, aBlocklight) * 0.9 + 0.1, 1.0);
			gl_Position = uView * vec4(aVertex, 1.0);

			float range = max(uDist / 5.0, 8.0);
			vFog = clamp((length(uPos.xz - aVertex.xz) - uDist + range) / range, 0.0, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="blockFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uTime;
    uniform vec3 skyColor;
		varying float vShadow;
		varying vec2 vTexture;
		varying float vFog;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
      if (color.a != 1.0) color.a = mix(color.a, 0.0, vFog);
			gl_FragColor = vec4(mix(color.rgb * vShadow, skyColor * uTime, vFog), color.a); //sky color here
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="x-shader/vertex" id="entityVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		uniform mat4 uView;

		void main() {
			float x = aTexture.x;
      float y = aTexture.y / 2.0;
			vTexture = vec2(x,y);
			gl_Position = uView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="entityFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
		varying vec2 vTexture;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
		}
	</script>
  <script type="x-shader/vertex" id="particleVertexShader">
		attribute vec3  aVertex;
		attribute vec2  aTexture;
		varying vec2  vTexture;
		uniform mat4 uView;

		void main() {
			float x = aTexture.x;
      float y = aTexture.y / 2.0;
			vTexture = vec2(x,y);
			gl_Position = uView * vec4(aVertex, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="particleFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		uniform float uLightLevel;
		varying vec2 vTexture;

		void main(){
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
		}
	</script>
	<script type="x-shader/vertex" id="2dVertexShader">
		attribute vec2 aVertex;
		attribute vec2 aTexture;
		attribute float aShadow;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vTexture = aTexture;
			vShadow = aShadow;
			gl_Position = vec4(aVertex, 0.5, 1.0);
		}
	</script>
	<script type="x-shader/fragment" id="2dFragmentShader">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
		#else
			precision mediump float;
		#endif

		uniform sampler2D uSampler;
		varying vec2 vTexture;
		varying float vShadow;

		void main() {
			vec4 color = texture2D(uSampler, vTexture);
			gl_FragColor = vec4(color.rgb * vShadow, color.a);
			if (gl_FragColor.a == 0.0) discard;
		}
	</script>
	<script type="application/javascript">
"use strict";
const urlParams = new URLSearchParams(location.search)
window.canvas = document.getElementById("overlay")
window.ctx = canvas.getContext("2d")
window.canvas2 = document.createElement("canvas")
window.ctx2 = canvas2.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.saveDirections = document.getElementById("savedirections")
window.message = document.getElementById("message")
window.worlds = document.getElementById("worlds")
window.servers = document.getElementById("servers")
window.marketplace = document.getElementById("marketplace")
window.quota = document.getElementById("quota")
window.messages = document.getElementById("messages")
window.messageHolder = document.getElementById("messagesHolder")
window.messageInput = document.getElementById("messageInput")
var hoverbox = document.getElementById("onhover")
window.onscreenControls={
    w:document.getElementById("controlW"),
    a:document.getElementById("controlA"),
    s:document.getElementById("controlS"),
    d:document.getElementById("controlD"),
    " ":document.getElementById("controlSpace"),
    "shift":document.getElementById("controlShift"),
}
window.onscreenControl_Element = document.getElementById("onscreenControls")
canvas.width  = window.innerWidth
canvas.height = window.innerHeight
canvas2.width  = window.innerWidth
canvas2.height = window.innerHeight
window.loadProg = document.getElementById("loadProgress")
window.loader = document.getElementById("loader")
window.themeColor = document.getElementById("themeColor")

let touchScreen = "ontouchstart" in document
if(!touchScreen) onscreenControl_Element.style.display = "none"
function MineKhan() {
	// cache Math object
	const { Math, performance, Date } = window;
	const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2 } = Math;
  const rand = function(a,b){
    if(arguments.length === 2){
      return (Math.random()*(b-a))+a
    }else if(arguments.length === 1){
      return Math.random()*a
    }else return Math.random()
  }
  Math.PI2 = Math.PI / 2

  // Shh don't tell anyone I'm override native objects
	String.prototype.hashCode = function() {
		var hash = 0, i, chr;
		if (this.length === 0) return hash;
		for (i = 0; i < this.length; i++) {
			chr   = this.charCodeAt(i);
			hash  = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		}
		return hash;
	}
  
	let setPixel, getPixels;

	const textures = {
		grassTop: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const d = Math.random() * 0.25 + 0.65;

					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;

					setPixel(n, x, y, r, g, b);
				}
			}
		},
		grassSide: n => {
			const pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");

			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
			}

			const { random } = Math;

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1;
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.25 + 0.65;
					const r = 0x54 * d;
					const g = 0xa0 * d;
					const b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		leaves: n => {
			const { floor, random } = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0;
					const g = floor(random() * 30 + 100);
					const b = floor(random() * 30);
 					const a = random() < 0.35
						? 0x0
						: 0xff;

					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		/*oakPlanks: n => {
			for (let y = 0; y < 16; ++y) {

				const a = 3 === (y & 3)
					? 0.7
					: 1.0;

				for (let x = 0; x < 16; ++x) {
					// these conditions are weird; can some comments be added here?
					const mid = x === 8 && (y & 7) > 3 && a === 1
						? 0.85
						: 1;

					const rit = x === 15 && (y & 7) < 3 && a === 1
						? 0.85
						: 1;

					const r = (Math.random() * 0.1 + 0.9) * a * mid * rit;

					setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
				}
			}
		},*/
    oakPlanks: "0g0g70ru00lb0yicsfz156v7cv17fehvj1bvja4f1f7pou71hfxp8f5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		hitbox: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0xff)
				}
			}
		},
         egg: "0g0gy0000000002i7lk002i96g002tjaw0034tfc0034v080050i60005bqpk005bsag005btvc005n2ew005n3zs005ycjc005ye480069l2w0069mns006kws80ddymt40flvfg80fm6mew0fm6nzs0fmhwjc0huenlk0hupxq00k2xywo0maupyw0mb5yig0mbh8mw0ojdzp40ojp88o0qrlzaw0qrm0vs0szu22g0t05am000000000000000000000000000000000000000043000000000000kkb85k000000000kopve8nj00000000kprtfcq300000004avvffc9830000004cfgfdom83000004cduwdasm8830000jocxfcaa88820000kmcfcsaa88k2000004acpol8mmh000000468omk8mjh00000003388872h00000000003ik10000000000000000000000",
    crack5: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000000100000000000000120000000000000120100010000000010010012000000111002112000000122210122000000020002120000000000000010000000000000001000000000000111200000000000022210000000000000002000000000000000000000000000000000000000",
    crack6: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000010110000000000002122000000000000120100011000001010010012200000111002112000000122210122000000120002120000000020000010000000000001001000000000000111200000000000122210000000000020002100000000000000020000000000000000000000",
    crack7: "0g0g300000000ixwa9r1jpkttr0000000000000000000001000000000000000210110000000000002122000000000010120100011000001010010012200000111002112000000122210121000000120002120200000010100012000000002021001000000000000111200000000000122210000000000020002110000000000000022200000000000000000000",
    crack8: "0g0g300000000ixwa9r1jpkttr0000000000000000000011000000000000002210110000000011002122000100002210120110011000001010010012210000111002112002000122210121000000120102120100000010120010021000002021001100200000000111221100000100122210220000021120002111000000221000122210000000200020002000",
    crack9: "0g0g300000000ixwa9r1jpkttr0000001000000000000111200010100001022210112021000211002122000100012210120110011002001010010012210000111002112002000122210121000000120102120100000010120010021010102021001100212021000111221101000100122210220200021120002111000000121100122211000020220010002210",
    crack10: "0g0g300000000ixwa9r1jpkttr0010001000101000002111200010100001022210112021000211002122000100112210120110011022001010010012210000111002112002110122210121000022120102120100000010120010021010102021001100212021000111221101000100122210220211021120002111002200121100122211000010220010002210",
    crack2: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000001000000000000000210100000000000002120000000000000010000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    crack3: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000000000000000000000000000000000000100000000000000010000000000000001000110000000000210122000000000002120000000000000010000000000000001000000000000001200000000000000200000000000000000000000000000000000000000000000000000000",
    crack4: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000000000000000000000100000000000000120000000000000010010010000000011002112000000002210122000000000002120000000000000010000000000000001000000000000011200000000000002200000000000000000000000000000000000000000000000000000000",
    crack1: "0g0g300000000ixwa9r1jpkttr0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000002100000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    none: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					setPixel(n, x, y, 0, 0, 0, 0)
				}
			}
		},
		dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
		stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
		logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
		bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
		glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
		cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
		mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
		stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
		mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
		bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
		coalOre: "0g0g70ehg7wf0hjr9j30j7xaf30sywflr0wb8hdr0zdjj0f13tzldr6556544543445666554536666553335454331453344511556665655105655644455443346545645556553215542143464552111065105555433556663334466661156543215455645565354100056665354514334663354455555666634106655443366412111054665105556005455554456665566544455555554655555566",
		ironOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1cpl2bj1gbvabj1o4exa71qwyvb33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217510131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167666421332542223442122221123332233211122222221322222233",
		goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
		diamondOre: "0g0g80h634zj0sagdtr0sywflr0wb8hdr0zdjj0f13tzldr1845xbz1ndl24f5445433432334555443425555442224343221342233461445554544604544533344332235434534445442764437632353447611054104444322445552223355556145432764344534454243600045554243413223552243344444555523605544332255367611043554604445004344443345554455433344444443544444455",
		redstoneOre: "0g0g90sywflr0wb8hdr0zdjj0f13oi67z13tzldr15wexa71b68mbj1f24cfz1yr4gsf4224211210112444221204444220002121005120011285224442422832422411122110014212412224220862218610141227655342532222100224440001144448524210862122412242021633324442021251001440021122222444401834422110044168655321442832224332122221124442244211122222221422222244",
		lapisOre: "0g0ga04hvenz04hvl6n04ihywv066fd3306r2ozj08z4sfz0sywflr0wb8hdr0zdjj0f13tzldr9889877876778999886669999886668787454386777813889889926329989977788776679867978889866428862576797861242398238888723679978767799993189872643386678998687222236258686627661237725788300799668893588779906612366339998700381039799887783339899877788888899888888899",
		emeraldOre: "0g0g7004swsf06mdmv30sywflr0wb8hdr0zdjj0f13tzldr1ohjdhb5445432232334555443445615442334343223310333422445555225555546133344361324555104445441061243255353445551054434444332232552323355555545461442244534444441053615224243433223310361344444556155551044223455103322553261334455444344441045554455433344554443544444455",
		coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
		ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
		goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
		diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
		redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
		lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
		emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
		tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
		tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
		tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
		acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
		acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
		birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
		birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
		birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
		darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
		jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
		junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
		spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
		sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
		sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
		gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
		blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
		blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
		blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
		blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
		brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
		brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
		cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
		cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
		grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
		grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
		greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
		greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
		lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
		lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
		lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
		lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
		limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
		limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
		magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
		magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
		orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
		orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
		pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
		pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
		purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
		purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
		redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
		whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
		whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
		yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
		yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
		bookshelf: "0g0gt03fxnnj04laqdb0a0ot1b0b6j6db0c8r6db0deww730df88ov0egz6rj0gpo9330ht5kov0k20av30nf40zj0pnc1dr0qoh8fz0sy416n0w8kcn30wc5n9b0yicu0v11vb08v11vskcf13z03jz16atkvz17fehvj1as1ce71czhmv31e50qv31g6nvgf1gbtpfj1ks44qnommllhlllmmmmlmoo44477444772534oo799kk999ni9637olkffqk99gpjk631lsqffqk64gnik631soqfdqf6gcngf651ookd9kf3c7igf350mlorrsssroorrroolollmmhmllmmmllhoo77227cb7427724ooqk763gck99cb97olpj063gckq4gc10hsqk063a8fqkgcpjsoqf065a87kqgc10omkfe35ccefkcb03oorrsssroorrrrooo",
		netherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		redNetherBricks: "0g0g70c7i51b0efew3j0fjiwov0ive1a70nbiubj0svgd1b0v3ir5r0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		netherQuartzOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330u2845b0v4m7sv10p0npb1bug2671e4e1vj1n1fv9b1smb9xb1312426644044643344320246610442164643068a921424676466baa866314246766ba8674662643166895678a8544641466565ba95146866310289856642b9742469b814466ab862467ba624646b952364a950268665602426852108b61623214642649a9164941364667689238976124667423804646442246624630246644",
		netherrack: "0g0g70hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1312425544044543344320245210442154543012432142456545423545531424565424566455254315431566554244541452054554214565531024541154246642454221445541452456540245455112354554025655200242254210254102321454254122154541354556512234565124556423204545442245524530245544",
		netherWartBlock: "0g0g60of09vj0suze9r0xana4f1539r7j1brbain1g7rcvz0122001222532010222235202110022112111222202202320122201003202242042220021211122103224300222201201022220122252002210210211223102220000221222200222022221132210202012201104100222102201012211021042230122022012022212012022002220222202202220234022205220322022302",
		quartzBlockBottom: "0g0g31sm5mv31tq9ngf1tqfbb32222221111000222121111000002222111100000012222110000001122221110001111000110000011100000110000011111222200001111222222211111111222211000112222220110012222222211222222222210000022222211000000222222110110112222111100112222221100101122222111101222222222210000",
		quartzBlockSide: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzBlockTop: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzPillar: "0g0g41qe37y71sm5mv31tqfbb31uujcov0202031312130212020302130313031202131313120313020313130213031313131303120302121313020312031203131302131313020303120313031303130312130303131303120213131302131212131312130202120313021213120302031302120313031303130202130303131303120313031213120212131302121202",
		quartzPillarTop: "0g0g51p9z6kf1qe37y71sm5mv31tqfbb31uujcov1021223242413020222122211221122002223434434322223123443344443211113412222221431242442344443244222243242222424423423324244142441222442424324234143244242211423322224423334432442421341222222143111123444444443213222234444443222002211222122112221203142423220200",
		chiseledQuartzBlock: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov0444404333022440043331222204444003322111000444300222223004443331023011101110022103315544432202200110441100220000554444144033344544433204314444440111230011441101054044444432154104400110111004401444454005544440133321100004443002323155440333300444414444132220",
		chiseledQuartzBlockTop: "0g0g51p9z6kf1qe37y71tq9ngf1tqfbb31uujcov0334314232133420021100022000112002044203204421200204120420412021020113032020003102233304212233200000000421110000323433442223344422222222222222220000001321000001044343142143222104011204214110201302130420313020120234032023403002111003201100400222314222133420",
		chiseledStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b6666655666566562644424444224444054110000111123205206665566561530640654434442154064064322334315405205430005421630540632000643062052054300053206306215435655420630641644545432053064163232322215406421110000011530556655666655543053343234433232202000000000000000",
		smoothStone: "0g0g70wb8hdr0yjgikf12zwkxr17gcnb318kgnwf1asop331d0wq9r1011002200220121054556666553445204334454444555501666455566655442255444545666645006555555554343412556664665545550243343443434466116656545555455620555554566656661054544334454454215555666665566622444566454433452165445556555455104456665566544401022112221000121",
		soulSand: "0g0g60egz94v0ht5n270k181z30oho3jz0sxyiv30xeekfz3130033202100434433135531100234004241451321012411423432542212230032442154212211332234104322433212002314322315332220023322345513032322211233445304302332013540423202342330242132302341043213032020354044321232020431445421112202350345131123302354202432103212415",
		glowstone: "0g0g80u1fugv0v5phbz10pn01r11uj6db1kqv1tr1x1ncov1y6jzlr1y711j35420045440276423654011240346654024032201131054033034542017510033014766405664136502566552454236751004554020132450531024010352320465230213276501576442654346640335420454220452013000320356304012311354016754036520357660354215764034654201003242013154216521100013",
		andesite: "0g0g60sywflr0wb8hdr0yjgikf11vsl4v17gcnb31asolxb2114332104423221245323445330122411334410122443224410133445433231235442223333211433323243210013432324542104543333423310154332333433114143343224533143342221154333332321101544332201331254422332333443443233212331543333334533112233301244323223541321322323234432",
		diorite: "0g0g60xfchz311vskcf19of1fj1gd8su71ktouf31smgykf1222352233524355201322135345543151355101325543235255312553213225351243153532255245355541332335235332455214554102243123234555521232203255443244250155213551234541244310134335513055510144221512352542543554223223212343125454353242115521455321245235554124421255",
		granite: "0g0ga0l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n1qczoxr7434244344046445431548244224422341444335249241464143446145532344234232113754334244255342143347242445524442555322424474302155243346344255522344245535242552464245557314243844212555415442024425030323244424324439435524312355344448553215435547245544733324244425",
		polishedAndesite: "0g0g90oilzi70sz23gf0v7a3270yjgjcv10ru60v11vyakf11w3ugv19okmwv1e4v30f7878888888788785843334442443134084444443376644307416763343446440844442456433334083344333424433318444634666554320833433332123444184562444466776608434433443344540844667633366444081444444664466208466654333134760844433334465334083333664444334406100000000110000",
		polishedDiorite: "0g0g80qqu0ov0xfi5tr11vy6m71asubcv1f94t1b1jpkttr1o60w731ri7bpb7776677777666774764556657643564166764466577434506565333565454441675334576435457176544567733456607566767655346450744765756564534063556655467534516566544565544761664334655465666075673555775644517557654375466340745654576435744072445566545654512101110001100110",
		polishedGranite: "0g0g90l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n8888786866866565843344345444334374744554442446418444243334553342844444453344443262343344443734428345543644444431844444423445544263422344554433636444433443344442734444444464334284473344244442318455444445543341633443264434455264443444334447412111001110111100",
    portal: "0g0gu0dbgv7j0dbgvzz0dbgwsf0dbgxkv0dbgydb0dbgz5r0dbgzy70dbh0qn0dbh1j30eff7y70eff8qn0efffun0effgn30fjdu670fjduyn0fjdvr30gnc9a70gnca2n0hranlr0hraoe70iv92pr0jz7h1b0l35vcv0m748vz0m749of0nb2n7j0of11j30pizfun0qn3fnj0qn3gfzjpked8bed36jh512kjjk5a8ci77h53656dj318mfpheof3ab1b418pl4662eqe014418mk311821dme1h8cpj4a67ef13crglbil3a5hkfoe12hkb1bb5677tjhrg248e47b54348bml724im8hm41322bdjh8dob46pn4a686cpj44bb616mo76bdqk3abfhq725pmccqm51bqjcor6a6lhgl43ctlbcbqm4187769bsj686ljgd8hhe88mh426",
		obsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    redstoneDust: "0g0g4000006w11qgs8o13ydjaw1jpkttk2220000220000222220000022000002220000022222000020003332222233300000333222223330000032222222233000002222222222300222000200200222222202020220222220020002002002200000222202102230000032222222223000003322222223300200332222333330222000022200000222220000220000222",
    redstoneDustOn: "0g0g5000006w1f1xam01jpkttk1nxkauw1wt7b3s0000000440000000000000044000000000000044444000000002224334422200000222444442220000024444144222000004433313444200444441131134444444443314114144440044341114144400000433433434420000024434144442000002244444442200000224444222220000000044400000000000000440000000",
    bufferMiddle:"0g0g502881dk0v31t6g11qs2d41cubto81x2x0xk4444444004444444444444400444444444444440044444444444444004444444444444400444444444444440044444444400000000000044444011233210044444400112210044444444001121044444444440121004444444444002204444444444440000444444444444400444444444444440044444444444444004444444",
    bufferTop:"0g0g802881dk0zivbaw13yotfc18eibjs1cubto81ha5bso1nxvkzc1x2x0xk7777777007777777777777700777777777777770077777777777770000777777777770011007777777770011210077777770011322100077000013363321100077001146631110007770013531100077777701331100777777770011100777777777700100777777777777000777777777777770077777777777777007777777",
    soup:"0g0ga0mewxrs0t3w8ag1jkvsag1jkw9o81job7y01smg9a01ullu601uunpx41x2kgzc1x2x0xk6666666626366666655666666666666666666666663663666666666366666666656666966666366666566666666666666565666766666666666166666666364665666666666636666661606666766666666666666666666666667667636666666561768673666666656660666966666666666666666636666666666666666666",
    soup2:"0g0gy08x7gmo090n2ls0b3ve9c0b96fhs0mav8xc0mewoa80mexbzk0qotmuo0qsjto00qskfsg0quq7zk0quqvow0qur5680v6iink0v7qghc0v8dxww0zotckw1apuuwg1atwxyo1cxrp4g1cxsb8w1cznca81d1ueb41f8631s1jkvsag1jkw9o81jne7lc1job7y01siecj41wt7b3s1wt7qq01wtiji01x0f4l41x2kws0tt54pm4p67460g0pt44tamaaa704gg0pkc67bbtma7a4gtr0m771bmbm9ta4qpt0a7acc45mo7qaq333m7bcaabm7h4i38r0aamccc477c4hh8r0mbaa7cdc774th8r07777jbdma7ibshs0dkk7j7am6babi8rpkk4jb7ccb7abtpu0ccf4775c7mm4mtts88lc1777mmmm6p0x82fmm87338v4tpss8m7q6gin934wts0xep4g62i0i322ss0x",
    soup3:"0g0gs00000000b3k0t40b46jhk0b6cwds0b6d8vk0b6d8zk0b7awx40b7m74g0b7x33k0m904m00mfk40o0mfk76g0ofo0mg0ofo0mw0ofo0qo0om805c1czc0ew1f2v0681f78bs01f78btc1f78rh41f78rm81f799001f79dqo1f79ic81lqabs81lu0ve81q7ozdkp0e440ece08ejj0000ee4l008f3ee99940404empfjf52509elm04pdfddee5pc0peee4c09bbgf8ph934edo4e35d0m86p633mel4e8n6h6bmp0b33lce46a45m0m003dj49e485a006j77m3pefee5dmb73cgjp3226p9447749007bpbf65ai4868620210q552fi48b33j4g13536ah2442f8ffm45455qm748437gfk0fff954762bjir0p",
    soup4:"0g0ga000006o0deayuo0v8z9ww0v9lr0011qgs8g1jkl90w1jnou0g1o6ay281ulak1c1urujg02222222222222222223222553322333222325233522222122232222222221222222003252332112222277322243331212277732224213322227772228482212222777232888222222277773288822322223777722322332226222332299232222222222299993222336362229999223226223322299222332262232222222222",
    randomSoup:function(n) {
			let r = 0, g = 0, b = 0
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = Math.random()*255
					g = Math.random()*255
					b = Math.random()*255
					setPixel(n, x, y, r, g, b)
				}
			}
		},
    redStain:"0g0gg1wt7ax41wt7axs1wt7ay01wt7ay81wt7ayo1wt7az41wt7azc1wt7azs1wt7b081wt7b0g1wt7b0w1wt7b141wt7b1c1wt7b1s1wt7b2o1wt7b3kfedb863102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acdfedb864102579acd",
    invis:"0g0g20000000009ppts0000000000000000000000000000000000110000000000000011111000000000010000111000000010000000100000001000000110111100100111110011110010111111110111111111110101100000111110001000000011110111111000001111111110000000111111101001011111001111111000010000011000000000",
    "poision potion":"0g0g40000000000006o18ikd0w1ulbvg00000000000000000000000000000000000000002200000000000001221000000000000100100000000000013310000000000001331000000000001330310000000001333303100000000133330310000000013333331000000000133331000000000001111000000000000000000000000000000000000000000000000000000",
    darkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 10 + 100);
					b = Math.floor(Math.random() * 10);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		redBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 255;
						g = 50;
						b = 0;
					} else {
						r = 0;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		blueBerryLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.10) {
						r = 0;
						g = 0;
						b = 255;
					} else {
						b = Math.floor(Math.random() * 30);
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		autumnLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 250;
					g = Math.floor(Math.random() * 80 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		pinkLeaves: function(n) {
			var r = 0, g = 0, b = 0, a = 0;
			for (var x = 0; x < 16; x++) {
				for (var y = 0; y < 16; y++) {
					r = 255;
					g = 205;
					b = 226;
					if (Math.random() < 0.30) {
						a = 0;
					} else {
						a = 255;
					}
					if (Math.random() < 0.30) {
						r = 255;
						g = 185;
						b = 196;
					} else {
						r = 255;
						g = 225;
						b = 236;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    flowerOftheValley: "0g0g800000000ekeqdb0mcq0hr0qtshkv0ym3u2n1o60w731smgykf1y711j30000000000000000000000000000000000000000000000000000000000000000000443000000000000760020000000000075020200000000000076020002000000657541002300000065000210330000000000011243000000000001143100000000000123200000000000013210000000000001110000000000000100000000",
		poppy: "0g0gd000000004jkcu704k17nj04k6txb05oxatb0fjd9mn0iv8e7z0qmx1q712uf5rz13ydk3j1f22ygv1lpt7nj1vpem7z0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa000000000000a78ab0000000000bb56990000000000ccb99000000000000b310000000000000004000000000000000400000000000000040000000000003404044000000000030230000000000000313000000",
		dandelion: "0g0g70000000017p88v03h660v143zt331e5azun1ktyynz1uuywvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000560646000000000005563000000000006643350000000000002200000000000000212100000000001221100000000000012100000000000000210000000",
    blueOrchid: "0g0gj000000004l4jjz05oxatb05p2x3306s98u706svocf06tdo8v06tdp1b07w7mdb07w7n5r07xc2kf0a6ccn30baaq670baaqyn0bax81r0djgfen0gsmpz30gssbgf0gssc8v0000000000000000000000000000007000000000000009f00000ec0ce000hac00000760cc00gc00000000ii900g7fd000007c4009020c000000eb00008ec00000000000003760000000000000i000000000000000190000000000000005000000000000000g00000000000000020000000000000099000000000000000000000",
    pinkTulip: "0g0gc00000000dfzitb0ek94vz0hwfl6n0j0p81r0l92txb0mcq1a70nhavwf0nhgi671p83v9b1skr5kv1utlnun00000000000000000000000000000000000000b0b0000000000000aba00000000000009a9000000000000009000000000004800104000000000073080840000000003708082000000000250626200000000024248200000000000684620000000000023820000000000000262000000000000002000000000000000000000000",
    orangeTulip: "0g0gg00000000cc14hr0ekeqdb0hwl6nz0j0p81r0l8rmyn0l92txb0mdchkv0nhm4fz1kpag3j1lt385b1mxo3jz1p61r0f1q9uj271qa5rlr1rdstfj00000000000000000000000000000000000000f0e0000000000000bcb00000000000009d900000000000000a000000000000800104000000000048050540000000002702082000000000264225200000000023248420000000000534520000000000083820000000000008352000000000000002000000000000000000000000",
    redTulip: "0g0gd00000000gssem70k4yuwv0md19tr0ol9b0f0olkhz30ppojcv0qty5fj1hb8m4f1ifclxb1lrj0n31mv641r1mvn18f00000000000000000000000000000000000000b0c00000000000009a900000000000008c8000000000000009000000000000030407000000000034010730000000001714061000000000171415100000000003731200000000000143240000000000001727000000000000142700000000000001000000000000000000000000",
    whiteTulip: "0g0gd00000000b7x3wf0cc6pz30fod69r0hwl6nz0k4nmdb0k4ysjj0l98gzj0mdcgsf1lxsv0f1pa4wsf1smgykf1uuozr300000000000000000000000000000000000000c0c0000000000000bcb0000000000000aba000000000000009000000000000040100080000000048050074000000002802073200000000252506200000000024842320000000000254350000000000002838000000000000253000000000000002000000000000000000000000",
    azureBluet: "0g0g700000000gruprz0j0e0an0ngu1331o66ku71riimm71uuoj5r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000006564000000000000432056000000006504553400000000530146200000000001320305600000000056230340000000005433300000000000003200000000000000300000000",
    cornFlower: "0g0gb00000000b6jldr0cbkf7j0gs0hkv0ht0npb0izbr3z0ngiyv30ol3u9r0qry3gf0v88hz312ynx1b000000000000000000000000000000000000000000000000000000000000000000000909580000000000599585500000000008114510000000000002a000000000000006600000000000000020000000000060006000000000000600700000000000036070000000000000367000000000000002700000000000000020000000",
    purpleFlower: "0g0g80000000003qupr0199eyn0l3bf9b0ohifpb17aa1of1e0teyn1mz9kvz0000000000000000000000000000000000000000000000000000000000000000000000000000000000000005500000000000005376700000000007775300000000000056337000000000007210000000000000040000000000000042000000000000000120000000000000002400000000000004100000000000000010000000",
    oxeyeDaisy: "0g0gb00000000dfzitb0ek94vz0j0p81r0mcq1a70nhgi671lxgm4f1pa4wsf1smb0fz1tqkz5r1vyt0cf000000000000000000000000000000000000000a0000000000000a7a7a00000000000986870000000000aa666aa00000000007868900000000000a7a7a0000000000000a400000000000000510000000000000040000000000000143000000000000001301000000000000051000000000000004100000000000000200000000",
    allium: "0g0gg00000000ppdce70rxldkv0t1pbsv0u5terj0ym3u2n11ya8sf1e1fw1r1f5v4e71ga4qgv1gafz0f1iiz75r1jn8t8f1n079q71p8qhvj1qd03y700000000000000000000000000000000000000a8a000000000000c89e80000000000aeae87b00000000077de8b70000000000fa8ea00000000000072ae00000000000006000000000000000400000000000000020000000000000004000000000000000500000000000000060000000000000003000000000000000100000000",
    lilacTop: "0g0gj000000002cqxof03gpb7j0j0uubj0k4nlkv0k4t7un0md191b0mdtblr0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr0000000000000000000000000000000000gh0000000dg00000dgd00000hgd000000hda000dgd00000000ae000bd0000000000690c300000000000042300000000000006900bdhf000fhg0009051id00000gdb00620c00000000b1c0g3000fg000000c37id00ghd000000000da0c1b0000000f000b02c0000000fh00086000000",
    lilacBottom: "0g0gl000000002cqxof03gpb7j04knoqn0j0p81r0j0uubj0k4nlkv0k4t7un0md191b0mdtce70nhrpxb17e0d8f17e0e0v18hyrjz1e21ywv1f60d8f1luohkv1mymvwf1p7bvun1qba9dr1qbaa67000ehe02800ehh00000f1d0a60chi0000000d298271c0000000000hk50d00000000000ebf00000000000000bc00ehig00000hj00502ceh000000f1f0a2db00000hhe0d5480000000hgic200a4000000000eed26a000000000000bd0800ehg000000000085dbeig000000000722d0000000000000300000000000000030000000",
    peonyTop: "0g0gq000000003dqnzz04hp1j304hp2bj04huolb05m9xq706q8b9b06q8c1r06qdybj07v4ef307vfmyn08z2sqn08ze0hr08ze1a71p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1sl2i2n1tp0vlr1tp6hvj1vy6ku700000000000000000000000000000000000000000000000000000000000000000000000000j00000000nnn000jnj000000jijmn09hnpin0000njipf6c5hnjj0000jnnkh6cb1gg000000eh16cb480ab0000009b4b74bd70000bcd38264b440000007ba1ok147da9000000kkinl6c9nk000000jnnph282nn0000000jeg18480000",
    peonyBottom: "0g0gv000000003dqnzz04hp1j304hunsv04huolb05m9xq706q8b9b06q8c1r06qdybj07v4dmn07v4ef307vfm6707vfmyn08z2ry708z2sqn08ze0hr08ze1a708zjnjz1p769kv1qb4n3z1qba9dr1qbaa671qbr4zj1rgbytb1rgbzlr1skad4v1skadxb1tp0vlr1tp6hvj1vy6ku71x24ydb0000ag4e743k000000e0r547f83k000000gaoq64e200000000a7aag45prn000000l947e2prmn000000kl6446ltrrce0004acd84e1ljo60000044h48482ac0000000822e484gal0000egbru17e47ga000006omrla46c44800000rnlb71ur60000000002e2smi000000000084e5po0000000000048460000000000004440000000",
    roseBushTop: "0g0go000000006q8c1r06qdybj08z2ry708z2sqn0900j5r0a3taf30a3ywov0c9ujun0de9szj0j0uubj0k4t7un0v3tuyn0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwl4v1tj27en1xznwu700000000000000000000000gk0000000000000jmem000000000000dnmg00000000kg002dd00gk0000memg07000dmem000gmn00a1300nmg0000cf00ij001fc00000070gmej0710000003b00nl500b00000000730d1007100000000100b3007100000000137000017000mhg001100070000meemd9b006b000000hmn04b80700000",
    roseBushBottom: "0g0gx000000005m9yin05mfksf06q8c1r06qdybj07v4ef308yx5of08z2ry708z2sqn0a3taf30a3ywov0de9s730j0p81r0j0uubj0k4t7un0mdtce70nhrpxb0v3o8ov0v3tuyn0w7mm7z0w7s8hr167835r17b6gov1g6z6db1g6z75r1haxjwf1haxkov1hb36yn1tiwkcf1tiwl4v1tj26m71tj27en1xznwu7000k400a703500000000030aba2qov0000003a03e3qvlov000e3a073a3jwvvl0000e30e3a3djil000n0d73ga3ge30000ovvlg3dppd3adpn0llstf9quwm2dpwvlqvwhdflvnvmfpvimiqs29gjlvmde1mr00k003edjk47a3800000739gea3ea300000003ae63ea3a000000ea3ae373aec000000ea373e379000000a9a3e3e3aaa00",
    witherRose: "0g0ga00000000000073015ikfz015o6pr015zf9b029s6in029xssf04ibenz08vn0fz0l5c2kf0000000000000000000000000000000000000000000000000000000000000000000000000000000000000009910000000000009191800000000000118110000000000001110000000000000010000000000000005720000000000027527700000000077240070000000007005000000000000000300000000000000436000000",
    TallGrass: "0g0ga000000006qdtkv07uhtdr08yrfgf08yx2in08z2osf0a312bj0a36olb0b7lwxr0dggef30000070000000000000009000006000000900300906000010031033030103091903303103013003381030310313390309103031013109030881313331310301008131330333337300810113310113130081010141013313001801014101331000118131718131300058813175813132002218215151111202821211212221210",
    
    warpedDoorTop: "0g0gc04i0ge707u6vwf07uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb3353533535353338588828883662488653362665666264539775445768827227b867476768628882a886566288629992988328829962999683362997998298839667299698827537576629968862577636882998633276643888288654636646389929936772356298992993772227727899288576139912b898286466098607",
    warpedDoorBottom: "0g0gb04i0ge707uz2f3092ophb0a5jpj30a60p330b7xmv30cb3t330fodrlr0fouosf0k1jhmn0pmetxb9724153655100061825533667751157125551676885158812577177688515886278815568851577647881776775122754775188677625547854418865521611642752576564155757566255566315775a65512256311624695551114316125648777166165514655487717757534657148881775735157715115151115616111",
    spruceDoorTop: "0g0gc0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0zm5jpb16anym7bab4bb4bb4bb4bb4aaa39a3a939a4962ba94aa3a649a4962ba94a6356469469201741741741741728564563564563562b6a36a4aa36a4952b6a36946a36a3a52b6a3994563963a62b993964564953962a963994653a53992ba54a93653a64692ba64a64a54a945a2ba94a63a64a945929aa4653aa4aa35620173173174173172",
    spruceDoorBottom: "0g0gh0ehg7wf0gpo9330l50ohr0nd8pof0ohnzlr0rtudj30sxyewv0sywflr0u30g730xe36db0xfchz30zm5jpb10rojr312zwkxr16anym717gcnb318kgnwf85645645645gd562b6b3b635b3g53db2e6949635b4fb3ab2e6b46936b45ca5b2e6b4b94994653b62e6b4b93b64963b62b9639b4b639b4662b9636b4b53b93652eb635b49536539529b6356465455395201731741731731728564563563564562e9b4bb45649b4bb2e9b4bb35b49b4b92b994bb36b4993b622553553554553552",
    oakDoorTop: "0g0gb00000000m9fzzz0ru00lb0sz251b0u30g730yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou7a88aaaa8aaaa8aa78777777777777772a712222712222772a720000820000871672000092000097547200008200008728758998858998872a712222712222771a7200008200008758720000920000972a720000820000872a758998858998871a788875588875575a71222271222277287277778277663726525555825531551",
    oakDoorBottom: "0g0g90m9fzzz0ru00lb0sz251b0yicsfz0znvvnj156v7cv19n5mnz1e3g0e71f7pou72515533715500753653677763677765165665533555335518501111501111650851555561555565385155537155537518515533715533751853677763677763065666533566533338501111531111651451555561555565125155537155537506515533715533753653677763677763183356653356653311000000000000000",
    jungleDoorTop: "0g0ge00000000ddc7b30ehg7wf0k20av30sxhjb30sywflr0u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn3ccddddccdddddcc4c8abb8bbbb8bba94d9bb97877879bba7dbba87700448abb72bb8708008078bb76b8700d00d007bb7dab700d00d007bb7d8a700b00c007a84c777cdbcdbcd7444dccc99777799ccc8c9bba800008abaa4c9bb87b00c8ab9b4cabb97accb8abab7db9b97aaaa8abba7db7ba78aab7531a72b8ba8bbbb718aa4",
    jungleDoorBottom: "0g0ga0ehg7wf0sxhjb30u30g730xdxk3j156edbz18ikr9b1buwttr1f738jj1hfgvzz1lw2kn32777647777147741967664777714775186665466661577618666634444367763856763888847777384776167654665738477516775366463947751777635656394774175763477610467436476147751255554637715555193113455764431318477434776467743875761477515757395455155543554539333111333311133",
    ironDoorTop: "0g0gc00000000hts9of0l64bgf0znkj5r18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz3a99aaaa9aaaa9aa89888888888888884a846666846666884a8600009600009842860000b60000b8438600009600009849879bb9979bb9984a846666846666884a8600009600009849860000b60000b84a860000960000984a879bb9979bb9984a899987799987784a84666684666688498688889688133842767777967714775",
    ironDoorBottom: "0g0ga0c986pr0hts9of18kgnwf19okohr1d0wq9r1gd8s1r1ktj7cv1lxsv0f1o60w731ricxz30646655946644962765799975799976276776655666556628624444624444762864666674666676286466659466659628646655946655962865799975799975276777655677655538624444654444762164666674666676306466659466659627646655946655962765799975799975385567765567765234233333333333333",
    darkOakDoorTop: "0g0gf0b4hji70dcpj3z0egnxfj0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv2719mocu71krh2bj1y61y4f88888888888888828776667777776664875000077500006486044496704449643604549670454964a7045596704559748705559670555964870565b660565b74870666b560666b74870666b560666b64860667b760667b64860677b760677b64861777b761777b64861777b661777b7486199b967199b97436676677776edc74",
    darkOakDoorBottom: "0g0gc0b4hji70dcpj3z0ehg7wf0govx1b0hsuakf0k12ayn0m94p330ohiewv0qpf4e70u30g730v5jv271krh2bj95666666665b556375400005640000637503338560333863750343856034386375034485603448537604448550444853760454a550454a53750555a550555a53750555a650555a63750556a650556a63250566a660566a53951666a661666a53751666a561666a5376188a855188a85375555555665655536111111111111113",
    crimsonDoorTop: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b6998899988989984844434444443444396473646464364739676367776737764533333333333333128887888888888848677667777677773967766777747777396663467764664449444334433333333611111111111111183331333333133319443144434314431964414644443444176663666461886135766366666086403",
    crimsonDoorBottom: "0g0ga0iwhlvj0k0lmgv0m9g6bj0pkufb30swv7r30sy9wxr0ygss1r10ov667140vym71bsvx1b2777367667400033878737867761666387883887876166838888388888718881033333333333333198887888888888869777667777677774877766777747777477663467764664443444334433333333511111111111111124441434443134439644364466434463976637687763677377873788787387836343134443313131",
    birchDoorTop: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v1y6vain677777777777777675566665556665537542222233333453752bbbabbabbb853052bbbabbabbb8531529999aa9999863762bc9cccc9cb763762cc9cbbc9cc763763999baab999863763ccabaabacc863763cdacaacadc86376399a9999a99863753bb9cbbc9bb863753bb9cbbc9bb752763ab9cbbc9ba702063ab9cbbc9ba712",
    birchDoorBottom: "0g0ge0iwyb5r0ohcphb17fk83j19nxurj1f8hwxr1josanz1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v173bbaddddabb852873aaaaaaaaaa972873dccdaadccd972873dbbcaacbbd972874999998899995286567557577575628557555756755673856756576675667385775767756576738677677775667773077667677557777317765757675776728775575657567662867566555755756285667656565565525222222222222223",
    acaciaDoorTop: "0g0ge00000000ehg7wf0ma8c1r0u0yyv30u30g730v74gsf0zlddz3155rt3317du7zz1btnojj1cxgglb1f5itxb1ii651b1jma5mndcccddddddccccc6ca999bb99bb99998da33673367336798da300c300c300c961a600c600c300c964a600c700c600cb6ba700c700c700cb6ba700d600d700db6da600d600d600db6da700d600d600d93db700d700d700d93cb700d700d700db3db600d700d700db6db600d700d600db3c9700d700d700db619acddacddac1256",
    acaciaDoorBottom: "0g0gc00000000ehg7wf0neccn30u0yyv30u30g730zlddz3155rt331btnojj1cxgglb1f5itxb1ii651b1jma5mn473356335633562599300a300a30076599300a300a300975a9500a500a500a75b9600a600a600a93b7500b500b600b93b7600b500b600b93b9600b500b600b93b9600b600b600b95a9600b600b500b9517600b600b500b7647500b500b500b7697600b600b600b75998abb8abb8abb75a9997779997777755633335555556665",
    
    crimsonDoor: "0g0g700000000iwhlvj0m9g6bj0pkufb30sy9wxr10ov6671bsvx1b0000000000000000000000000000000000015535553550000001553555355000000466666666600000025555555550000001333333333000000155355535500000045535556650000002553555115000000155355535500000015535553550000004666666666000000255555555500000013333333330000001111111111000",
    warpedDoor: "0g0g9000000004i0ge7092ophb0a60p330b7xmv30cb3t330fouosf0k1jhmn0pmetxb0000000000000000000000000000000000056643646640000005622664664000000826266463300000076626626630000005624624234000000336463466400000086646343340000007664364114000000522436466400000036626642340000008664662663000000733462466400000036632646330000005555555555000",
    acaciaDoor: "0g0g500000000c8fxtr0zldfjz1asop331cxxczj0000000000000000000000000000000000024444444440000002440404044000000144040404400000024404040440000002440404044000000244040404400000024444443340000002440404044000000244040404400000024404040440000001440404044000000244040404400000024404040440000002222222222000",
    jungleDoor: "0g0g400000000qpkttr18iqfwf1cz0uf30000000000000000000000000000000000023333333330000002333202333000000133020203300000023302020330000002333333333000000233300033300000023333333330000002333333113000000233333333300000023333333330000001333333333000000233333333300000023333333330000002222222222000",
    birchDoor: "0g0g8000000011v5mnz16bx3wf1bvdn271n1fmkf1n1foxr1o60w731x2r9xb0000000000000000000000000000000000024544444440000002477667744000000146666664400000024767767440000002476776744000000246666664400000024767767340000002476776734000000246666664400000024776677440000001444444444000000244444444400000024444444440000002222222222000",
    darkOakDoor: "0g0g500000000a0j56n0iwyb5r0m94p331y5lkov0000000000000000000000000000000000013333333330000001322232223000000432223222300000013222322230000001322232223000000132223222300000013333334430000001322232223000000132223222300000013222322230000004322232223000000132223222300000013333333330000001111111111000",
    ironDoor: "0g0g500000000l64bgf1584m4f1hhcsn31ktouf30000000000000000000000000000000000024444444440000002400040004000000140004000400000024444444440000002400040004000000240004000400000024444444440000002433343334000000243334333400000024444444440000001433343334000000243334333400000024444444440000002222222222000",
    spruceDoor: "0g0g600000000ddc7b30ma8c1r0qpkrgf0xe36db12zwkxr0000000000000000000000000000000000034444444440000003444444444000000122222222200000034444444440000003444444444000000344444444400000032222222520000003444444454000000344444444400000034444444440000001222222222000000344444444400000034444444440000003333333333000",
    oakDoor: "0g0g5000000008wkrnj0sy416n17fehvj1czsw730000000000000000000000000000000000023333333330000002300030003000000130003000300000023333333330000002300030003000000230003000300000023333331130000002344434443000000234443444300000023333333330000001344434443000000234443444300000023333333330000002222222222000",
    
    torch: "0g0gd00000000egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi7156v85b17f3a4f1y2mc5b1y5l3b31y70gzj1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a900000000000000bc000000000000008600000000000000750000000000000084000000000000008500000000000000750000000000000063000000000000008200000000000000610000000",
    soulTorch: "0g0gd0000000006fbb30dkjoxr0egz6rj0fl37cv0gp77y70htb8jj0ndpnnj0u22fi70xkd0qn156v85b17f3a4f1y711j3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021000000000000009c00000000000000b800000000000000a700000000000000b600000000000000b700000000000000a7000000000000008500000000000000b400000000000000830000000",
    
    lantern: "0g0gc000000008x7i7z0gptzb30hu3nr30iy7p4v0zkwgsf12xjrwf1ihjf9b1uqx79b1x10sfz1y70fen1y70tmn0244200000000000065560000004220024444200000201005788750000020100689986000001210069ba96000000000069ab960000020100589985000001210024444200000000002233220000000000234432000004220034444300000201003444430000000000234432000000000022332200000000000000000000000000",
    soulLantern: "0g0gb0000000005sq9r07z7enz08x7i7z0a7fgn30gptzb30hu3nr30iy7p4v0u80yyn1inns3j1vyyo730577500000000000075570000007550057777500000503005144150000050300728827000003530078a9870000000000789a870000050300528825000003530057777500000000005566550000000000567765000007550067777600000503006777760000000000567765000000000055665500000000000000000000000000",
    
    beaconGlass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
    beaconObsidian: "0g0g50000073013yfb304gainz0a0p1q70fksanz1000012104311343101202104211342100443013322023010432231212001210032220000001110122200211114311002212344310301001102422020000043000432223310032223200213321021211211011121100210302112012144322221442022234212421332111022211103103112131122010012102012320111111",
    beacon: "0g0ga0bar6rj0bbdr0f0k7hofz0u7k07317jn2tb1inns3j1kuxzpb1n3ha7z1tr7jen1y711j39999999999999999900000111111000690011112211110069011222322221106911222333322211691122345543221169012345775432116902235788753321691233578875322069112345775432116911223455432211691122233332221069011222232221106901111122111110690000011110000066666666666666666",
    
    cactusTop: "0g0g900000000fmt0cf0hv6n0f0hv6nsv0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70000000000000000013331337313311003444344444444100345735565355430034564586546543001345665658444100375655666555430034664466666643003466846656654300345666668547430014456656654441003456455664554300345547555357430014443144424441001133133331331100000000000000000",
    cactusSide: "0g0g900000000fmt0cf0hv6nsv0k3k9of0mbxwcf0okh5a70rwt69r17gnmdb1f9a6m70156534665156410024548456516658087454144653665100155514565756420015662466414541001665146641455808166414864146510016651465415651001564245441664200146524644166420024657565416547802455156541644108745515665265410014641566426541001465145658554100156614455146410",
    cactusBottom: "0g0g7000000002aeqrj03fm41r131ary718ljny71jppypr1lxsdmn0000000000000000012222111222211002555566555566100265334444335520026455666655352001535566665536200253555435554610025456466365461001646646646645100164665345664520026456666555452002535565555545200255434444336520015555666666661001122212222221100000000000000000",
    
    glassPaneSide: "0g0g400000001d2bim71hje60v1y711j30000000320000000000000031000000000000003200000000000000220000000000000023000000000000003100000000000000210000000000000021000000000000003100000000000000210000000000000032000000000000003100000000000000320000000000000032000000000000003100000000000000310000000",
    glassPaneTop: "0g0g400000001d2bim71hje60v1y711j30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000333333232232233311221211111322120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    ladder: "0g0g700000000fl385b0m9fzzz0ru00lb0yicsfz156v7cv1e3g0e70052000000005200046456566665646003432333333243300021000000002100005200000000520006645666565564600343233333324330002100000000210000520000000052000664566666656440034323333332433000210000000021000052000000005200066456566665646003432333333243300021000000002100",
		vine: "0g0g500000000ok5z3z0qse0an0u4q22n0zpa51b0002143113023440033213000202134044312000004311004321000004432100002100000112320003221002210032111332331230032100200234403032440000001340000234000000210000321330000031000021000000132130044100001332133004321021043110300302111303211000001220020021232021013300",
    
    Water: function(n) {
			let r = 0, g = 0, b = 0, a = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
				    a = 200;
					r = 0;
					g = 0;
					b = random(200, 255);
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
    Lava: "0g0gp1jjxhbz1jjxi4f1jk33lr1knvuv31ko1hxb1lsrytb1lsrzlr1mwqd4v1o1mhvj1o1minz1p5kven1p5kw731p67ev31p6io731qa5se71qabfgf1qaxxbz1qaxy4f1rewbnj1sjmuwv1sjmvpb1to7sov1ut3zsv1ut9m2n1y687b3965ckke60666999cf996f8c66cd69fjddd96606669f67hold967629c96669lll966666dhc9969jfh97666chh69df699c96999kk969kd69f99696dlnf069536669ha66fh960066456hhk97690017ll66chgl96000009ml5696969hg63066862666666kl7066c60068li69990669d6609knldh66046699hb6hefckh960656fhd69",
    
    craftingTableTop: "0g0g903c6e4f06oif3z0hsj18f0k0r37j0nd8r9b0v4xd6n17dojcv1bu4kxr1gbtpfj1001255555521011088267777776288008277777777772801274344433334721267467477377476257747736746747755774434434434775577477477477477557747747747747755773334334434775577367376377477526746737736747621274434444444721082777777777728018826777777628811101255555521001",
    craftingTableSide: "0g0gh04gaepr06oif3z0a0ufb30b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731ceff486684fffe11eccab4664cceeb11eeecec22bbccee1199aa971197977911fbffff66ffeccb11ee5b5b44cceeee11bc3c3c44eeccbb11799g97117999a911ffgcgf66fffffe11cededc44bcbcbb11eccbbb44cccbbe1179aa97009a997711beffee66ffbfef11ceebbc44eececc11bbcecb44ecbbbb1199779a119797771",
    craftingTableFront: "0g0gh04gaepr06oif3z0b4n4zj0fkmbr30hsj18f0k0r37j0ru00lb0v4xd6n0yicsfz156v7cv17fehvj1bvja4f1e50qv31f7pou71hfxp8f1o60w731y711j31bdee375573eeed11dbb9a3553bbdda11dddbdb33aabbdd118899861186444811eaeeee55ee2b2a11dd4aba33bb222d11ab2bbb33ddccca116829861168gff811ee2bbe55eegffd11bfffdb33abaffa11dcfgaa33bbbgfd11689986008988f611adeedd55eeaege11bddaab33ddbdbb11aabdba33dbaaaa11886689118686661",
    
    crimsonNyliumTop: "0g0gb0rs4iyn0rsa60v0v4gkqn0v4m7sv0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cv665022781508847275526677572777880356a2357825787420153555726274776351871536a625293557027508476266575376488726530535326787982a205776357474843262155557532671535783753a62635150735530762355175784375788774726357820557536726663777553017357a62743152625305526787057",
    crimsonNyliumSide: "0g0gl0gnskcf0l3m2gv0l3xclb0m7kfzz0nbzqpr0nc5drz0of09vj0rs4iyn0rsa60v0sutrzz0v4gkqn0v4m7sv0w8ey9r0w8klbz0xana4f0yelnnj10p0npb152yh331br00e71g7lptr1hbk3cvhihiheijhhhihijifhijehijjihjjih99fehfhhe99ekef96f6f9f9ff69hf696636966696639f66333336346653666344348f0d474563547ac49627cb99b76fb7727a7229f6aa797b67aga7067a7ac1964c7aa706bgac2002726b72302a71024237b96b73223d7a734c7aaga32247aga327aag724207a7a77227aa27c4027aa77",
    warpedNyliumTop: "0g0gf01a28e702e0lxb02eybjz02eyccf03fmgov03gq1a703gq22n03gvocf03iwp330gqauwv0hvcjjz0hvi5tr0izax330izgjcv0ng7r3zee49aa519491146c744aee6646c655119d4e3cc460c45154a994c4447cea7465ec490794ce3ea4c2c4479c749046eaee474c6e4115ce4b94c4cae61580c3c9476ec4746414caea9444464cae694c460c74c2eaea49497c44c96eac44974714c747106647aea450c94474ce7ceeec65744c997c462ea64c94aea4c944ce616946",
    warpedNyliumSide: "0g0gn02e0lxb02eybjz03fmgov03fmhhb03gq1a703gq22n03gvocf03iwp330b5qosf0c9p2bj0gnskcf0gqauwv0gqavpb0l3m2gv0l3rpj30l3xclb0m7kfzz0nbzqpr0rs4iyn0v4gkqn0w8ey9r0w8klbz10p0npb40406b0744404070b507b607704770522bb6b66b22b1bb29c9b2b2bc936b9399g93999398g3c99ggggg8gh98hg998ghhghicalhihh8ghhijkh38fikk33ki8ckiifikife3c8kji3ik8ijmjia9ikijkg38hkijjia8kmjkfaafie8kifgafjidafhfgik38kigffglijighkikjmjgffhijmjgfijjmifhfaijijiiffijjfikhafijjii",
    warpedStemTop: "0g0gk01a28e703fmgov03gvocf06r0ovz0900vsv0b75erj0dhkflr0dhq1vj0ekl0cf0ekl14v0ekwb9b0el1xj30hs7z0f0hsp3b30hsupkv0iwng1r0iwngu70iwt33z0k0fzen0k0g073cce1ii2f0hcic2ecebbbb9b8689bbabe2b33554544445562cb366aaaa8aab5bcj95a88888888a49jcb4a85544558b59ch9588398895885bd084a85944848a480f94a85945958b59f284a859998488582i95a85535448a49ii94a88888888a59i1b4ba8baaaa6b591eb454555555555becbbb99b98799babccce1ii2f0gcjc2ec",
    warpedStemSide: "0g0gp018yq6702bzev302c514v02cx3pb02dp9fj02duvpb03fmgov03fmhhb03gk7wf03gk8ov03hnmyn04lar5r0gp1ybj0gp7klb0hs7y7z0hs7z0f0hsdm2n0hsunzz0hsuosf0hsupkv0iwng1r0iwngu70k0fzen0k0g0730ncmewvffjann6j3jfnf2jfffj3fn6j3jnnj6jfj26jjnj22fofjj2jafn6jffj2jon6j33jnoj6jnj6jnoj23jfooj6jonj6jnfj2jj6ooj6nooj6jj2jn2nomj6fmooj66jmm2ffjfj6jfnnj6fooj0f2nmj66jf66jonk50jeoofj6l6knne0jnfjnoof66j1ffj2nm6jenok6jf0kekjmi2j6fn2ifnj4i2fj1jf7lfj0kmnk0jff9cnf6gdb8hf2jf",
    crimsonStemTop: "0g0gh0hs7z0f0l3rn5r0m7q0ov0ogqepr0ogqfi70pkot1b0swplhb0yelnnj0ygn5rz0zkljb310ov66711stjpb140qccf152yh33154opvj154uc5b1br00e7002700d1g2000d202bbbb9a8c89bbab2da004464666644ed0b0feaaaa8aab4b0094a88888888a6900b6a85466448a49029488098894884b2g86a85866868a68g196a84864948a491d86a84999868848d094a84505668a690096a88888888a4907a6ba8aaaaaeb4872b636444444444b20bba99a98f99bab0002700d1g2000d20",
    crimsonStemSide: "0g0gj0hs7y7z0hs7z0f0k0fzen0k0g0730l3rn5r0m7q0ov0m7q1hb0nboe7z0ncmewv0xana4f0yelnnj11qmfb313yughr13yuha7152su0v166r7jz1ancwzj1cv9o1r1dz81kv115h33a5e5131b51115e13a5e5335a515ba5535bb18155b5h13a5115b583a5ee5385a535a5385be51885a5835a5315b55a885a3885a55b53b3835a13885aa522b11515a51335a1885e1b325aa51aa5834if518815a4a4331e53153881aa5b115b33951384a51f414535b5a13b5135h5b15b51a415e4334f511c731a07gd61b51",
    warpedWartBlock: "0g0g702e0lxb03gq1a703gq22n03gvocf03iwp3304jkwlb04k1s731111656111151116116604151665511666116111151351015611156550153141541115536166611650114055111156356511115611142551165365366110651115555116111155111511116601165351561156654625613651156563666626541105613512561531161561511651115111151151115104511154165011511051",
    shroomlight: "0g0gh1dzj3sv1mwkohr1o0j20v1o0ooan1rdsr271rdydbz1y2bd331y2bdvj1y2h05b1y3vvnj1y3vwfz1y41ipr1y4tp8f1y4zbi71y5rl6n1y5x7gf1y6perj303518843009ee7105444199852de9d838899dc991879dc92489eeed94996998519eg9d819cc96a4249f99719cgge9841811dda19cgg998484ff14481de994a88aec7eed84dd819984d96eg9d4811b984847dd99d8a99444884d44dd944eefa184fc9a48129eg9451dc9a4ddb1a97843489844d9834444304414424200352300",
    polishedBlackstoneBricks: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj3554554554554430343435443223334034544423224424404343433443432120443333433332112023441233212212302243232221132330110011000011111154554440124555453343434034344544234544402355444343343420443443344343232045432323323221104432121221121210332211110011100000101100",
    gildedBlackstone: "0g0ga05k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70iw63un0l5yqrj0yh98n31o36n0f1y6dkvz2332220233343553308750023334435308122103389432107233332334791121133444244662812544643213222271253443222533225211122225732133211311233034318752233331013215133225222378112364433713344192114664383344438211113472446622272222255244631125011103313221112022235322",
    chiseledPolishedBlackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj5554555555554452534344333334334053111212222215315315555555452541541544444434244144253433333425315413555555431541542451555153254154235154414315315323444444432431542533222234154154244443443315314312222121111531335554555545453123334344333333322212100000102121",
    blackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj2332220233343113300110023334431301122103344432100233332334451121133444244552112144543213222211213443222133221211122220032133211311233034310112233331013210133220222320112354433013344102114554313344431211113412445522212222210244531120011103313221112022232322",
    blackstoneTop: "0g0g505k8ttr07sb8qn0a0uhof0dd6ltr0gpioe72344331234322300044332111232103404342234311134231232033442144342220002442003433122242013000033211244343012100211134343314422013322342024333302342201122443320011400234324421012343233444200134244034402321024442124432121102343213342323432023223211332344400430",
    netheriteBlock: "0g0ga0a0oven0c92jnj0dd0x6n0flk8hr0gp7bwf0hts9of0k1uolb0l5ne9r0l5yp6n0oiaqyn4244444444424420269999999998998049366888567766804956778868875380496578788886546049565768988854624955568889666360496538888865638049688886685653624988985556556362288878555533448049878763353341802836665335341180283433341111148228666888688888602000022000220000",
    basaltSide: "0g0g506p53b30ddc9of0flkbnj0l5yp6n0pmkdtr3023343444343313101134344434332201133444443432330033444434341233203434323322330221144322343231021114242344323123113122334341313213343243444102331333434444441244113343443443034411344344234403413334433213432321133123231332342213234244313224333033434443432343",
    basaltTop: "0g0g706p53b30ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf4455351155441441456511331442211325311344412652343145234531556413056542441155542004544221451442440044001444512332511033244551032544133442550001542223454220155144344044144154451344550145545444014555224533144100054145233100144001144450155145541443445056434544",
    polishedBasaltSide: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0wb8hdr1235443544334421023545354543342202354545454534221335555545554422123455454555433222344545455543321234355543544321113335555354432101353545545353210135354555545320014545455554431012444545555543101345453555453321234545355545433123454535454543312345443545444432",
    polishedBasaltTop: "0g0g70ddc9of0ehga9r0gpoc8v0l5yp6n0pmkdtr0wb8hdr11vskcf0255331155431320054464436445343225656554655654443453434433333553244366665555333226546434434535442433636565354664566363634545354444435364353636532563545555364665345354343346354444535555566635523554333434333653246653645644555225565455564545420245443555434520",
    chain: "0g0g400000000a1bitb0gpzlkv0k2boxr0001010000000000322112000000000020100000000000001123220000000000000201000000000000010100000000003221120000000000201000000000000010100000000000001122220000000000000201000000000000010100000000003221120000000000201000000000000011232200000000000002010000000000",
    warpedTrapdoor: "0g0g7000000007uz2f30b7xmv30cb3t330elit4v0fodrlr0fouosf3111131113113111165456464444656315335333345332513630540036200351166024600600045315200240045024631422006002405661344200600040365116400450004033511620462000402543352062000550044115305500052002411630252005050363163325422442334336446544444444533111133131113331",
    warpedPlanks: "0g0g704i0ge707u6vwf07uz2f30b7xmv30cb3t330fodrlr0fouosf5356666656666652553324355533554435553534444335522112210011010010564666646665334535534342433555534435333255533444001121000011121056653366666666545355553444343442653344443333445400122100012110006456655466646566335544344553533334435342553444440110012221010000",
    warpedFungus: "0g0gc000000004lrqpr05nj7r305omscf05qtg5b0gqavpb0iwhlvj0k0lmgv0ncs16n1sfq5fj1y125fj1y3kmbj00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a4444ab41000000314444aa13000000233a913332000000222995522200000000006600000000000000760000000000000087000000000000007800000000000000870000000",
    magma: "0g1ca0hs27zz0m81d6n0rsft330v4m7sv1jkpkov1rdbzen1vu37y71vueiv31wzat4v1wzrrwf042101272002542133100025210374129953225412381257531745425784212451245421223520124002731001127321201382310003845742328755212742447445432452542125215220124742102712721001252002820387210025210272413252102712315274125122585784242455788733215312154223731012472005210125200247313310003521025512599323771225125553174883455731244124473122383013400253100113723120127121000255745221755731245387777542388345213521532013755210271242100135200272025421002421025371225210341231425812712385457524387445783221831214522243101348300521012720027421231000282102841259932274122812555318457257742125712644212225201280025310011252212013723100037445522154452138835754554225427831272152201245531025128310012420025203853100252103735122731037123283751251235887583524544458333173121572225210124520",
    crimsonFungus: "0g0gg00000000jz6rr30k181z30m81blr0m81d6n0oho3jz0v2w6wv0v4m7sv0xeekfz10p0npb1539r7j19jk7b31hbe96n1iftrsv1y125fj1y3kmbj0000000000000000000000000000000000000000000000000000000000000000000000ddbf00000000000fedbba0000000000eedefa00000000006aaee6000000003bddb633c60000001366633661000000013311331000000000004200000000000000570000000000000098000000000000008900000000000000970000000",
    warpedRoots: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410102000000201310010140000410303303001000003020030300110000303001030410000430310142010000010003001003000003003203300300000320200322020000002020220202000",
    twistingVines: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000003300000000000003130000000000000143140000000000044421300000000004412000000000001441200000000000141120000000004134130000000003134432000000000002113200000000000213300000000000034320000000000044432000000000004412200000000000241220000000",
    twistingVinesPlant: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000211320000000000002112014000000000231413130000000002144300000000000211410000000000023111300000000000231130000000000021132000000000004132200000000003443200000000410443320000000313444320000000000014322000000000031132000000000001132200000000000233220000000",
    netherSprouts: "0g0g4000000004lrqpr05omscf05qtg5b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000010300301003000001031030101300002101201020230100220120202021020",
    crimsonRoots: "0g0g500000000m79czj0rr17un13yjfun1bqosn30000000000000000000000000000000000000000000000000000000000000000000002002000000000004020202000000001443020020000002043403020200000203241303003000003244320232400320414203241042020040310404000403003003040300130030310223023131000303121021341000010310101013000",
    weepingVines: "0g0g400000000of09vj0suze9r0xana4f0000233002210000000013300221000000001210002300000000011000330000000001000231000000000000012000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    weepingVinesPlant: "0g0g800000000of09vj0suze9r0xana4f1539r7j19jk7b31iftrsv1y125fj0000232000320000000033100032670006513300001455606751310000111000001130000022200000233000002230000023156600033560000315756002210000001110000032000000033000012300000003320763220000000222001220000000665103220000000665440335600000000110033476000000223002310000",
    spruceTrapdoor: "0g0g90ehg7wf0gpo9330nd8pof0ohnzlr0rtudj30sxyewv0sywflr0xe36db0zm5jpb4873882853783754487385245357357445827734527528540163163163163160445345245345245445825735825828444582773452752854477275345374275447527735428427744843872542853574485385384387348448835428838824540162162163162160485385384387348448738828537837544873852453573574",
    oakTrapdoor: "0g0g700000000k1j85b0qq1m9r0v6c0sf11uughr17exm9r1czhmv31111111111111111245445554544545213122235512223412520006542000642242000654200064224200065420006521236565543666421254555454555555225554445545454422412223541222352252000655200065214100055420005412420006542000652253566554356664224555545455555421111111111111111",
    jungleTrapdoor: "0g0gb00000000ddc7b30k20av30sxhjb30sywflr0v5v6rj156edbz17emdq71cz0uf31f739bz1hfgvzz5533555355553555579989988999897339888768768768933789807007089873579800800a008975579000a0080009755780007007000875599a9a9aa9a9a995568767687686a8655787007007009875578800a008008875578870800807887537988878878889733798aa9888aa997557787122421787755535553533555335",
    ironTrapdoor: "0g0g800000731d0wq9r1f94rgf1hhcsn31lxn7y71n1wvlr1pa4wsf1ricxz31222333333322221244444455444444224233354423335422430005443000542343000544300054334300064430006433445567554567743354444555544445335444455554444533423335552333543343000544300054324300054430005432430006443000642244567744455674224444445544444421222233333322221",
    darkOakTrapdoor: "0g0g80b4hji70dcpj3z0govx1b0hsuakf0k12ayn0m94p330qpf4e70v5jv274455554554444444430000155300001440222275402222744024447440244475414445754144457541455575514555754166776551667764455455555455545444555545444555444300001543000015402222745022227540244475502444754144457551444575414555755145557441667764516677644445554455554444",
    crimsonTrapdoor: "0g0g700000000k0lmgv0pkufb30swv7r30ygss1r10ov667140vym72111121112112111154645656666545214223222233223412520000000000241151223211112214214556666556654521612211112322151262000000000024115200000000002411511121233221162244566664645546114122232112111611520000000000252152232233323226225665466666666422111122121112221",
    birchTrapdoor: "0g0ge0iwyb5r0ohcphb0sxn37j17fk83j19nxurj1f8hwxr1n14cfz1n1fmkf1o5pclb1qdxekf1tq9lvj1tqf9q71vyn9bz1y6po8v344433344434444336777766777766644733333333333374478bccbccaccb374478ccdaddbdcc374469abbaaabaaa374369cdcacdacdc374378cddbddaddc364379cdcbdcacdc363479bbaaabbaab374479cdcbddbcdc373479ccdaddadcc373379bc788999cb363378998666658836436776601206677733344433334444334",
    acaciaTrapdoor: "0g0ga00000000ehg7wf0ma8c1r0v74gsf11t4irj12xe4u7169evpb1btnnr31f5zoqn1jm4gzj4444444444444444466778888888877445558745587455844600974009740084460097400974008446009740097400844600974009740084460097400974008446009750097500844600975009750084460097500975008446009750097500844600975009750084477898778987789446898233332898644444412222144444",
    
    bedplanks: "0g0g70ru00lb0yicsfz156v7cv17fehvj1bvja4f1f7pou71hfxp8f5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    bedbottom: "0g0g418fls731brmj271dzuk8v1g82lfj1212222200123330121110011223333012221222333333321123333333222321012222222222222101222222221112210012222222221123101222222220112321012222222101233111122222221133321211122222123333012222222113322320122221110221133333332210011101222111121122100001222211221000",
    bedtop: "0g0gd0svgc8v10ng93313zmnsv18fls731aszz7j1brmj271dzuk8v1g82lfj1hhcsn31ilxqf31o66j9b1tqkz5r1y711j3aabbaa9999aabbaaab988888888889babb89abbbbbba98bbbb8abccccccba8bbba8bccccccccb8abaa8bccccccccb8aaa989abbbbbba989a444444444444444400000000000000002222222111112332333322222223773367777633333332226777777763222222112222111111111155333355533335555555666555335676",
		bedlegs: "0g0g70sy416n0yicu0v16atkvz17fehvj1czhmv31gbtpfj1y711j36660003226666666666000402666666666600032266666660244202233226666125520123321666602442000000066666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666",
    bedbottomsides: "0g0gb0svgc8v0sy416n0yicu0v10ng93313zmnsv16atkvz17fehvj18fls731czhmv31gbtpfj1y711j3434444777777744333333334444444333444333333333333000000000000000055858985588999851111111111111256344777777774433333344333333333343333344444444444000000000000000058999885589858556521111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    bedtopsides: "0g0gh0svgc8v0sy416n0w7h4ov0yicu0v10ng93313zmnsv16atkvz17fehvj18fls731aszz7j1czhmv31dzuk8v1gbtpfj1ilxqf31o66j9b1tqkz5r1y711j3eeffffe90588b288defffed905888285ddddddd90455824499999999000000006acccaa66aca6a667631111111111111882585409effffee852584409defffed552555509ddddddd000000009999999966a6aca66aaccca61111111111111367gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg",
    bedfrontback: "0g0gf0svgc8v0sy416n0tzeprz0yicu0v10ng93313zmnsv16atkvz18fls731aszz7j1czhmv31gbtpfj1ilxqf31o66j9b1tqkz5r1y711j344455557777775444444555555554444444444444444444400020000000000009669996696999669a63311111111336accddddddddddddccbcccddddddddcccbbbbccccccccccbbb88888888888888889669996696999669a63311111111336aeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    bedIcon: "0g0g01g00000000eh4s8v0ehaein0fl8su70fl8tmn0govx1b0gp1iin0gp1jb30gp1k3j0gp775r0hsuakf0hszw1r0hszwu70hszxmn0iwyadb0l50pa70rqvegv0sutrzz0sxycjj0tys5j30u1wqv30u1wsfz0u3639b0v2qj270v6yuin0v74gsf0w6owlb0wb2ubj0wb2v3z0wb8hdr0xana4f0yelnnj0zik16n0zmscn310miepr11qmfb312uf6kf12uksu713yotfj16783y717b6i9r17bc5bz18f4wlb18j77jz1ilb6yn1joyb5r1joycqn1jp3xfj1smgykf1tqkz5r1tqqm7z1vyc4qn0000000000000000000000000mrs00000000000nq1b1f1dt00000000nq1414j181d1ds00000gq1111111413q191c1do000n1011151111111614j1a1ep00u1114151111111111zwux400u11141111111111ynjjlc00uq11111111wqnnh5lc003jj12ynnqndf01600kaunnqv980000000005hj2e00000000000017d00000000000000i900000000000000b700000000000000000000000000",
    
    respawnAnchorTop1: "0g0gl000007307sgwlb08wkzjz09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k7b30b3kf7j0c7imf30c92oe70dbh0qn0dbh1j30efff270gnc7pb0l35s730ndeuwv0qn3ke70ziwirjicaiiiaiiiiiaicic222ccc222cck22ci21111111111112aaj100000000001cii2100000000001cii2100006700001ciic10005dfb0001kaic100677he90012ii210054589g0012iac1000433900012ii2100006800001ciic100000000001ciic100000000001jaa21111111111112ic22k2cc22c2cc22cicijiiiiiaiiiaci",
    respawnAnchorTop2: "0g0gr000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjogcooocooooocogog222ggg222ggq22go21111111111112ccp100000000001goo2100053390001goo21006a78ef001goog105a6hjfie01qcog106788nibm012oo21066569blk012ocg1063544bdi012oo21006a797b001goog100087bd0001goog100000000001pcc21111111111112og22q2gg22g2gg22gogopooooocooocgo",
    respawnAnchorTop3: "0g0gv000007307sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgcssscssssscsgsg222ggg222ggu22gs21111111111112cct1000l6770001gss210mk5339e301gss210j6a78efo01gssg1b5a6ikfje31ucsg1b6788rjbqh12ss21m66569bml812scg1o63544bdji12ss210n6a797bo01gssg10mo87bdpk01gssg1000mbbp0001tcc21111111111112sg22u2gg22g2gg22gsgstssssscssscgs",
    respawnAnchorTop: "0g0gv07sgwlb08wkzjz09zlo8v09zlp1b09zlptr09zlqm709zlren09zls7309zlszj0b3k0zj0b3k7b30b3kf7j0c7iku70c7ilmn0c7imf30c7ipkv0c92oe70dbgzy70dbh0qn0dbh1j30efff270fjdtdr0gnc7pb0hral8f0hram0v0iv90cf0jz7dvj0l35s730ndeuwv0qn3ke70ziwirjsgbsssbsssssbsgsg111ggg111ggu11gs10000000000001bbt028ol5663dp0gss108mk4228d2c0gss10oj5967deo40gssg0a495ikejd20ubsg0a5677rjaqh01ss10m55458aml701sbg0o52433acji01ss106n59686aoj0gssg03mo76acpk40gssg065omaapf520tbb10000000000001sg11u1gg11g1gg11gsgstsssssbsssbgs",
    respawnAnchorTopOff: "0g0g8013yfb307sgwlb08wkzjz0b3kf7j0c92oe70ndeuwv0qn3ke70ziwirj5435553555553545422244422244722452111111111111233610000000000145521000000000014552100000000001455410000000000173541000000000012552100000000001253410000000000125521000000000014554100000000001455410000000000163321111111111112542272442242442245456555553555345",
    respawnAnchorSide3: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd44749997144311ed34417911113391d933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide1: "0g0gf0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1x1ncov1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743d13479949994744de114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorBottom: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    respawnAnchorSide4: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd447499971443dfed3441791111339dd933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide2: "0g0gh0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirj1kqv1tr1x1ncov1y6jzlr1y711j3a9a6aaa99b9a9b9a7469a733337a694744999333333999449499743ed3479949994744egfd4474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    respawnAnchorSide0: "0g0gd0000073013yfb304gainz07sgwlb08wkzjz0a0p1q70b3kf7j0c92oe70fksanz0k1dyin0ndeuwv0qn3ke70ziwirja9a6aaa99b9a9b9a7469a733337a69474499933333399944949974311347994999474411114474999714431111344179111133911933111197991379973199790047939aa97972226267737777377266266462333320260502162612188522b618820cb658c12b215521c10262bcc051051b21511b20b001210b012526111611",
    
    flintAndSteel: "0g0gc000000001440sf05kk35r0b5464f0ddc7b30ixwa9r0neccn30v74gsf0yjgikf17gcnb31asop331f94rgf000000000000000000005500000000000005bb5000000000005b947400000000005b4044000000000059500000000000005950000000000000575054000200000047959400262000000479400234100000004400246831000000000234a321000000000268322310000000026423461000000000132111000000000001100000",
    oakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000003000000000005002200000000103500187100000077231187660000535270177625000005378607705350000000774700055000000217530120000006762535276400003227678476423003330657746403300000053273500030000003547530000000000006745000000000000664000000",
    cryingObsidian: "0g0g80000073013yfb304gainz0a0p1q70b3kf7j0fksanz0qn3ke70ziwirj1000412105311353101204405216352100553013322723014532236212701640034244667701116122760211165311406712355410306004102522764006053000534723346032224260276321621264244671141100260302142612155322441552042235612421332161022264403103162131162040012106012324111411",
    netherGoldOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1cwijun1ihp1j31wzx4ov1y6dkvz1y70nb3131242554404454334432024521044215454771243914245654ab93545a814245659a45664552543154385665548445414520545542ba56553102454985894664245422744554145245ab40245455112354594025655270247254218254179321454254ba21545413545565a9834565124556423274545442245524530245544",
    
    potDirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
    flowerPot: "0g0g600000000rt2ayn0w91g5b0xd5gqn0zldh4v11tfugv0000000000000000000000000000000000000000000000000000000000000000000000000000000000000455321000000000050000200000000005000020000000000500002000000000050000300000000005443430000000000534423000000000054323100000000005443210000000000543421000000000053222100000",
		acaciaSapling: "0g0g700000000rvpou70sxskqn0wc5pmn0yi6z270ykjcan12yn0n30000000030000000000010035300000000015503405100000015355441561000000166364546510000001643526600000000543514431000000335512455110000003166446100000000064462100000000004354233000000033123121000000000314122400000000000464220000000000046420000000000002422000000",
    birchSapling: "0g0g700000000mbmpdr0ojuprz0u4vl6n1bxerr31jq1hj31qe337j0000000020000000000000033000000000000002422000000000032051330000000003325433200000003341651200000000302564412000000000231423200000000233543343000000233141241300000021346651020000033456663300000000303365030000000000233210000000000004210000000000000443000000",
    blueOrchidPot: "0g0g8000000005om32707xc2kf0a66pkv0bax81r0cfi2nz0k4nn5r0nhm4fz0000000000000000000000000000000000000000000000000000000000000000000000540000000000000343200003000000032630003440000000270000620000000000600700000003200020700000003436023430000000020070450000000000006720000000000000016000000000000000610000000000000010000000",
    crimsonRootsPot: "0g0g700000000m79czj0rr17un0yerif613yjfnm13yjfun1bqosn30000000000000000000000000000000000300000000000000003000000000000000042002052000000006020206000000000665020060000000005605020000000005261505000000000266520250000000016205261000000000510606000000000005060500000000000225020000000005121021500000000510101010000",
    darkOakSapling: "0g0g9000000004ixywv07vl8fz0hwqwvz0l50ohr0nhrtvj0ohcphb0v5v56n0yict8f0000000000000000000000000000000000000000000320000001233000130100000035213521320000132442521651000001412321431000000002111226640000003116221442000001106661441530000001326641000000003527674000000000147877600000000000787640000000000068674700000000066764660000",
    jungleSapling: "0g0g9000000006otm2n08x1lof0b6cyrj0c9dlvj0cbpz3z0ddhlof0ekev3z0flpm2n0000000000000000000007503000000000000573453000000000043647750000000057444347000000000378340300000000006853000000000534857430000000007737375000000000505863440000000000068457000000000035830300000000004387000000000005784530000000000058630000000000034214300000",
    spruceSapling: "0g0g7000000004g4qv308xo8an0c8liin0cabim70fmt6nz0m94p330000000000000000000000020000000000000021200000000000004150000000000005432400000000002426122000000000063245300000000003442552000000005442245000000000424522200000000003556254000000003546354500000002422635505000000004422244000000000023202000000000000110000000",
    warpedRootsPot: "0g0g5000000004lrqpr05nj7r305omscf05qtg5b0000000000000000000000044100000000000004410000000000000132044100004410002004430000443040300332000033201410002000000200310013100000012303303000000000020030300000000003001030000000000310142000000000003001000000000003203300000000000200322000000000020220200000",
    
    smoothBasalt: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0sywflr3244223333332244234332234421123332132134434213344321234444502344332322445510244321321234410123331131233321024322022344232113444123344332323444303344444111244322243344321212343232344543112344432145521123244443233210012433443343210012443444344423211343343244",
    crackedNetherBricks: "0g0g80282ebj06o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf1111111111111111667626773666274643451541544516144513244144432441111222111112221126776053265656651654144417444333254404332543333322111111121111125520751203270125441144105515141534250425442044251222122212221222527525775434220542441544344310744423144333341544",
    polishedBlackstone: "0g0g605k8ttr07sb8qn0a0uhof0dd6ltr0gpioe70l5yqrj5545554554555443543445343343433043544333234544315534433443343421554323234343232353554443234544334434433443343423453544325442322155453422443232404434354432233341545444232144244253434334324321325433334342321331534412334334144143432322211334323222221222222212",
    chiseledNetherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf6666366565563664656526433335255062342533333526305430000000000630301055455345110053306654555615405330353533531630643053555666143031105115511500006430665355361630533034111143063053306533566604303111011100000110564414666666164053330433344303404111011111110110",
    
    oakLogSW: "0g0g60fkxl330l5hmgv0pls0730wa4su7142r7jz16az8qn2222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    acaciaLogSW: "0g0g60m9x0cf0oi51j30oiaolb0syl3wf0xf169r12zl7nj2222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    birchLogSW: "0g0g80ehg5j30qqiprz1gd8ovz1o60ttr1p9o0e71tqqkn31uujbwf1y711j36677202376630016637310367376101334673155537720233437636576473136646773647645531363677373773754134666367377677464376313775767637667710467556766776760144775763777663013477577373736412637647767363642336734776631467363633667361364776124673642036377311377334006",
    darkOakLogSW: "0g0g60b4ssu70dcv6670dcv6yn0gp77y70k1dl330oho0e72222333333333332333444444001233343331112233333441111333344453311441021322110011333333444443333330012223322232211333355433335543332222134430001014553332222334344000101233322233333333444333344313222233355443344452331100133311111001333133113333334442233335544",
    jungleLogSW: "0g0g90gp75kv0htb5dr0m9fwu70ne0s8v0ohnx8f0qqct8f0sxsphb0walkhr0yi730f4164406440761642418230824056144240127082415114426042514242301462614230428242416464144141826131142412112461643164240413260162426421081526136262422418432415616402245642404741630241764240854083118134626082404514841464416251431664164460415112464416146141741644",
    spruceLogSW: "0g0g60c8a9z30c8liin0dcjw1r0fkrx8f0l50ohr0nd8pof1111333333333331333444444002133343332221133333442222333344453322442012311220022333333444443333330021113311131122333355433335543331111234430002024553331111334344000202133311133333333444333344323111133355443344451332200233322222002333233223333334441133335544",
    crimsonStemSW: "0g0g80iwhlvj0k0lmgv0m81blr0ncs16n0xana4f11qxpfj153445b1cvfb3z0026221131022520225665213310026254225252021027250224202444256210110131242442011201331242102420262202242312444267665542330420252222522131240331004420131042331024111022442131044010224422010222017624223125204522224133330061125600501341067211200027202552265200",
    warpedStemSW: "0g0g804k1s7304kturj05nj7r305pkd8f0iwhlvj0iwypdr0k0lmgv0ncs16n4451556676455054550110567764451502550505456453504552545222501564664676525225466546776525645254515545525765222513110025774254505555055676524776442254676425776452666455225676422464552255464555463152557650542055552677774416650144046726413566544453545005510544",
    basaltSideSW: "0g0g506p53b30ddc9of0flkbnj0l5yp6n0pmkdtr3233223234411233123300233444223433223111223334433331333301002322444422211434322333332334444443344444344344433313444333444432113444442233344423443344322344443244444443422333332333343422344442443133444143344133211331133333332300100111331133303100221111113113",
    polishedBasaltSideSW: "0g0g606p53b30ddc9of0flkbnj0l5yp6n0pmkdtr0wb8hdr1222221110001112222233222211233344443333333333344334444455443444335555443445555434455555555544444555553345555555444444455555554455555555555555553345445544443333455555555555555444455433334444445555444355545555333333333344444422232221111233331001121100011222",
    
    crimsonPlanks: "0g0g70gof7r30iwhlvj0k0lmgv0pkufb30swv7r30ygss1r10ov6675456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
    deadBush: "0g0g500000000ogvp4o0ogvqpk1424k541424lq00000000030000000000000003000000000000003100030000000000310003200000340033213300000001400333113000000023131201000000000131100000000000333100100000333331332333300000111034110113000003000311000300000300231000000000000033100000000000003310000000000000131000000",
    
    chainIcon: "0g0g400000000a1bitb0gpzlkv0k2boxr0000000000000000000000101000000000000013100000000000000200000000000000312000000000000020100000000000001010000000000000131000000000000002000000000000000100000000000000212000000000000020100000000000001010000000000000132000000000000002000000000000000000000000",
    lanternIcon: "0g0ga00000000gpzlkv0k2boxr0zl23un11tlf5r1hdl2in1uqx81r1x10sfz1y70em71y70tmn0000000000000000000000001000000000000001200000000000000210000000000000010000000000000012210000000000004334000000000001222210000000000356653000000000046776400000000004798740000000000478974000000000036776300000000001222210000000000000000000000000000000000000",
    soulLanternIcon: "0g0g80000000005sq9r0bbdtdr0gpzlkv0k2boxr0wg3d331kvkj5r1y711j30000000000000000000000003000000000000003400000000000000430000000000000030000000000000034430000000000004334000000000003444430000000000312213000000000042552400000000004576540000000000456754000000000032552300000000003444430000000000000000000000000000000000000",
    
    coal: "0g0ga000000004gg3cv07sgwlb07ss4cf0a0owzj0a105j30c986pr0ddc7b30ehg7wf0flpx4v0000000000000000000000000000000000000333300000000000367763000000000358975530000000038576765300000003445898753000003565458865710000369756665451000035666555644410003555456452521000324544444242100001224524422100000012222111100000000111100000000000000000000000",
    stick: "0g0g800000000b4n4zj0ehg7pc0ixwa2o0k17x8f0sxsoov11udg5b1584lxc0000000000000000000000000000033000000000000034100000000000034610000000000034610000000000034510000000000034610000000000034510000000000034610000000000034510000000000004610000000000004517200000000004617720000000004610220000000000110000000000000000000000000000",
    emerald: "0g0gb0000000001pt6n0034dmn004op33005s45b006k8an05sdfr30i0nv270zs3pq71bzx9fj1o7fjsv000000000000000000000000000000000000002222000000000002a77620000000002a97756100000002a997755610000002966995451000000296698535100000029669853510000002966885361000000296687346100000002543348100000000025436100000000000111100000000000000000000000000000000000000",
    lapisLazuli: "0g0g80000000015dh4v04ic5j306q3b3z07utxj30ej169r0ok1atb0wci2gv0000000000000000000000000000000000000003333100000000003466541000000003567542410000003565642451000000376454256100000036674255610000035465255610000035764256441000003265245541000000152256541000000014564111000000000111100000000000000000000000000000000000000000",
    diamond: "0g0gb000000004k7hmn05ndjwf06ub56n07xbqpr093bbb30cg9ywv0k8fgfz18nwo3j1n3h8n31y711j3000000000000000000000000000000000000001111000000000001aaa910000000001a77895200000001a788987520000001a7a9a9772000001a7a7788353200001a797888453200001aa58887433200001977333355420000027355553520000002635555382000000024778852000000000222222000000000000000000000",
    goldIngot: "0g0g900000000w893b31cxx3i71p7anlr1sk94vz1x1hhq71y6oxdr1y70vzz1y711j30000000000000000000000000000000000000000002200000000000222552000000022266666620002225666666665102766666666667761257666666777635125676677764333512565876433334551246564333345511002456433441110000024544111000000000221100000000000000000000000000000000000000000",
    ironIngot: "0g0g900000000ehg7wf0oigd8f0pmkdtr0v74gsf0znkj5r1asop331o60w731y711j30000000000000000000000000000000000000000003300000000000333664000000033367777640003336777777776403877777777778874368777777888746136687788875445613666887544446661356675444466511003567544551110000035652111000000000331100000000000000000000000000000000000000000",
    copperIngot: "0g0g900000000u0tddr11sywhr17cwef317d7ojj1hd9xxb1rea2gv1x0pzpb1y33w8v0000000000000000000000000000000000000000003300000000000333552000000033365445620003335665445665203856665445668862368665556888544136586688865542413645785445542251364485445542411003548445541110000034645111000000000331100000000000000000000000000000000000000000",
    rawIron: "0g0g900000000flej270ne0ykf11v06pr1bvjgfz1o4aozj1sl7pbz1y5rt331y6pptr0000000000000000002222200000000002577652220000000278787675222000268887878776520026568877676565201644654433454520153454443223442015335443222223101433322227864410144332226667543101433311466532210011110014443221000000000144221000000000001111000000000000000000",
    rawGold: "0g0g800000000u1fsvz1cxx3i71qb3chr1vwwidb1x29fjz1y6pa0v1y711j30000000000000000000000000000000000000022222220000000223446533200000234545544332000267545544544100277767766543310027766665434321002565454433322100135454433345641013354432456743100143332244333210013432213443221000133210132221000001110001111000000000000000000",
    rawCopper: "0g0gh00000000a1sc1r0b6u4n30fnwqgv0l8mghr0lacfsv0qqczjz0u0tddr10va4n311st9fj156jy0v19kyqyn1jlcb9b1jrgg731si2sxr1y33w8v1y4od8f000000000000000000000000000000000002220002999900002433222aeffc9002554534aefgfe70028d855aaccec97093a5433ab99bc7009fe4a3ab99bbb7009ffecacb99b977707efcecb99bfcebb707eccb9b9fgecb61016b9b997effb631014369777ccb93310011170007c9911000000000001110000000000000000000",
    copperOre: "0g0ge0fnfu2n0fnwqgv0lacfsv0oksv7j0pmkdtr0sywflr0wb8hdr0yjgikf0znkb9b12zwkxr18kgnwf1hdqvwf1q9usjj1uqaxa79999799765667767776766777775567776115445556cb966779641145979a767666418cb897766777958bcda9664456967779aa9654884676564456770323b579951845799038cb6732238797691aa976913a9745779a776779a755b457797667666518cdb6565579918a9181a97512679aa979aa97799797776767977777997",
    
    netherWart: "0g0g700000000jz6rr30m81blr0v2w6wv0zjnjen19jk7b31iftrsv0000000000000000000000000000000000221100000000000246541000000000255556410003320025655441003465201455543103455642013543200265554100154200024565310014420331255410021441345414421023243125431441002324311432143100021331013101310001132101310121000112210121012100",
		wheat: "0g0g700000000oj2fb30wb835r11vmhhb19nxqtb1kskvlr1p8pon30000006000000000056000560000000006400065000600000450002420650000042400455456006000454004450446500053300500032562304340650304044056435354030304504550432405640050334042040445005033403005033500403050203503042045206010345002403410545021450520301042102101041010",
    
    lodestoneSide: "0g0g80flk9a70k20cfz0sywflr0wb8hdr0yjgikf12zwkxr18kmcjj1at00sf7677656555565667764001112122146664423434332424466112430000432106613335034045430541545044340445154250035004300515413034000054041442414510115513154241136116411524424661566516651442254615526345254244551222552225477255666654266555522422222426544556665655566655",
    lodestoneTop: "0g0g50sywflr0yjgikf12zwkxr18kmcjj1at00sf4344433444433444411100101100011441444434443444134143323232323403304321232123331441322111121224034042121111112314404221111111331431421111111224043133211112113404403222121122240331432321123233144043322223233404414444334434441441100001001011144443333334434444",
    anvilTop: "0g0g600000000flk8hr0gpo9330hts9of0k20av30ma8c1r0000000000000000000000000000000000000000000000003343222333222211345434553444433244534454445454325453545345545433555455545545553245555455553555434545545554354543454553455434354334434234554334333321122212222331000000000000000000000000000000000000000000000000",
    anvil: "0g0g60flk8hr0gpo9330hts9of0k20av30ma8c1r0oigd8f1122335555443211123445554444432111333444445534311223444455544322133233444444344101233234433321101233211233322200122333223333431011223322234444310123333212443211011222112333211101221122332111100001101221111000012221001112221100122211112210000001122211100000",
    
    slime: "0g0g50olklv80qty9bo0va8r040xigqlw0ximegk2213321122213342244444223222220434321221112321231421013222222121241002221200212223211122340122222321222233222122231210222222213223120022222220322212223222011232122122222111232112322222221003213224322021101342300112111222334240123333444444422432221122222122",
    soulSoil: "0g0g50egz94v0gp1n9b0k181z30oho3jz0sxyiv33221122101123344221023101013233421003310012224231111320012223332100230222233232101133223332332211133233344322210232233234322111221133443222112221133443221113321343443221123211144432121133200133432211133210124432210023310023443120012321012434221012221012334",
    blueIce: "0g0g50t0y9kv0u52a670wda9rz131n01r1aty3un0112221002343211001121100043211100111112102321011010123320131001110024322012101221013343200102222002333230003322101333221100243210233222112103431122312211220121012121221021002100012121000110110110110100122210111122100122222011123320022222321123322023223321",
    packedIce: "0g0g60yl1czj10t9ddr145ldkv18lq48v1ge6ubj1jqd7gf0012233221023330012243112213310012243012311100002231003310110011222100210022122221222110022223321122111222223311001113321223321001123220113431001222221002531000322321002420010123321002321001123321001121001222331101111221122231111112232122341111222233122353",
    ice: "0g0g610t9e4e131brge145ldj218lq4721ge6u9q1jqd7em0002243222113332002233222112321001222222112321002212221112121101211221210001112211222110001222330122112011223322001112221223432101122220113432201222220003532200222320002322200123321002322221023322000122221122532100122221122232100022322112352000224322111343",
    calcite: "0g0g61d0wq9r1jpkt1b1o60ven1tqkxkv1uuumtb1y711j34323123211454233322210221553322332210012354333233210011234444322211012334443421212012322243331005532221233232012343321123222112332255431245223442233453112425543123334212333432223332323433342213332245553223211123213543221001225541344221001225433234321211124",
    
    loomTop: "0g0gd0dcv7r30m9lm9r0sy416n0zmb5z310qqnsv1576pdr19n5lvj1arwg731czhmv31e4e51b1gbifb31jo5rzz1lx68e7b39393937393939b80709090907070788171719191919178819171917171719881919191919191988090c09090c190c8829292c2c2c2c29886c6c6c6c6c6c6c881c1c17171c1c1c88191c1c19191919881717171717171788040404040404048abbaabbabbbbbbba81417151715171488010101010101018bb8ba8aaabbb8bab",
    loomSide: "0g0g90ncxji70u1ac5b0zmb5z310phiin12xpiwv19n5lvj1gbifb31ik1ptr1jo5rzz8888868866666888611111111111111861033333333330166343333344333416633333333111100660113133333333166333333333333316655555555555552667888686888678866111111111111116633344444333341661111131333311166103333333333016614444443344431668887688868886762222222222222222",
    loomFront: "0g0gf0dcv7r30m9lm9r0ncxji70sy416n0u1ac5b0zmb5z310qqnsv16bapz319n5lvj1arwg731czhmv31e4e51b1gbifb31ik1ptr1jo5rzzebebebebe9e9ebee89898989898b89888b8989898989898889a9a9a9a9a9a9a887a7a7a7a7a7a7a887a7a7a7a7a7a7a8871717171717171886363636363636388eeddeeeededdde88d244444444442c88aacaccccccacaa88000000000000008801111111111110880355555555553088aeeddeedeeecda85555555555555555",
    loomBottom: "0g0g40dcv7r30m9lm9r0sy416n0zmb5z31111111111111111100000000000002110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001110111111111111211011111111111121100000000000001113333333333333311111111111111111",
    jukeboxTop: "0g0g706oigov0b544jj0eh4wzj0oh1hq70ohcrun0xdrym7155xhq71122112222212111134554444455443114566654456665422465554114555642246555410455565214655540045556521465554004555652256555400455564225655540045556422565554004555642246555400455565124655540145556512465554114555652245666544566654213455444555444311112222222212111",
    jukeboxSide: "0g0g60b544jj0hsuc5b0oh1hq70ohcrun0xdrym7155xhq70000000000000000034554455554543004515151515141400515212521252150055152515251425004212521252124500552515241524140041521252125213003415241524142500421252125212440054241524152414004142124212421300431424142414140031114111411143003333333333333300000000000000000",
    noteBlock: "0g0g60b544jj0hsuc5b0oh1hq70ohcrun0xdrym7155xhq70000000000000000034554455554543004515151515141400515212521252150055152515251425004212521252124500552515241524140041521252125213003415241524142500421252125212440054241524152414004142124212421300431424142414140031114111411143003333333333333300000000000000000",
    furnaceFront: "0g0gd04gg2kf08ww4xr0gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr10rojr31440lj317gcnb31asop331d0wq9r1ilgt8f3333233322232233355665656656564324686756787865633577211111127653367200000000264226500011110008423650022222200843268aabbbbbbaa86226765465456565533cbccccccccccca33aaaba7777abab9239a8410000148a933883000000003693368000111100098328601111111106922522233333322252",
    furnaceSide: "0g0gc0gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr0yjgikf10rojr31440lj317gcnb31asop331d0wq9r1ilgt8f1111011100010011123343643334332112477232664366411366672347663661124664243676243002233267634631101377436676334421046673664276664003443224276664311babbbbbbbbbbb911899a9aaaaaa8a8008899999999999710788889899999871157878888987875113344344444433311111011100001111",
    furnaceTop: "0g0g70gpim0v0ma2ozj0pmeqrj0sywflr0wb8hdr10rojr31440lj31111011100010011122235542334532112466442565355411365662466653441145654234666243003233254334522101256356665225531046653666356664006666445356664511666653353455511146664566653223002454366666536410522324566645551146224234443554112434541233234311111011100001111",
    blastFurnaceFront: "0g0gg04gg2kf0gpo9vj0k20av30l64bgf0oigd8f0rumry70sywflr0v7fojj0wb8hdr0yjgikf11vmy2n12zwkxr17gcnb31asubcv1e50qv31ilgt8ffdbb68686886fdbbd12632112221d126b24722333443b247877a12221133877a61134544432211168122244312233338823aaaaa88886338633afffffddd62266118cd0d0d0c6116befc6d0d0d0c4eeb6b6c6d0c0c0c4cc66b847cfcfcf74ac66ba2777777772ba64aa2222444444a9449a98888888899944444444444444444",
    blastFurnaceSide: "0g0gf0gpo9vj0k20av30l64bgf0oigd8f0rumry70sywflr0v7fojj0wb8hdr0yjgikf11vmy2n12zwkxr17gcnb31asubcv1e50qv31ilgt8fecaa57757775ecaac01521001110c015a13611222332a136766901110022766950023433321100055011133211122335712332121233332772332122011222175011000000111005adddddddddddddda59babbabaa999aa559a9ba9aa9a9a8a55989a9a989998985389889899898787337887877887877733333333333333333",
    blastFurnaceTop: "0g0g60gpo9vj0k20av30l64bgf0oigd8f0sywflr0wb8hdr4554433333344555541211000112214441123321000121155021100011222225412331012333210432100000001100043232101233333203311011233221111330001101000010133122022122333223311233222112221342221100010110035001111101332105511232123321011554122101121001454545443333335353",
    smokerBottom: "0g0g80fl385b0gpim0v0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr10rojr34422122211121144402357763556720422677663777577222577773677775662267776356777365115355376556733212377577777337752167775777577776117777667577776722777775575677722267776777775335113676577777757621733536777767772227336356665772244256762355352040422122211112244",
    smokerFront: "0g0gj06oo3r308wku0v0a105j30egz9xb0fl385b0gpim0v0k20av30m9fzzz0ma2ozj0oigd8f0ru00lb0sywflr0wb8hdr0yicsfz0yjgikf11vmy2n156v7cv1asubcv1ilgt8fga555555555555ggd74aadda7dd7a47aga47aa7477aa74a7gg9bbbbbbbbbc9daad6ii2000002bbgg7a9ii0000000fcadda9ih0000002fc7adg6ie2222222cfa777ffcfhfhhhhff77a7113731137111gddg1da3d33da3a1daad4477474477447aga4da4da4da4a4ddgd3a73a73a7377adad133133133131a77488888888888874",
    smokerSide: "0g0gc0fl385b0gpim0v0m9fzzz0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr0yicsfz10rojr31440lj3156v7cvb5111111111111bb8205588528825025b502552022552052bb4666466666648558699479999676bb257974679994775885664976679447258b76999994499452227767776777772252002202002200b88b085085085050855805205205202225b53aa4a4aaa6a388b8399a467a9963585839974769a943522033333333333320",
    smokerTop: "0g0ga06oo3r30a105j30fl385b0gpim0v0ma2ozj0pmeqrj0ru00lb0sywflr0wb8hdr10rojr36644344433343366624579985778942644877887777799444777995899997884487943111134587337573111111355434579110000119774387911000011978339791100001197944979110000119744487931111113557335894311113477843955758999989794449558578887774466478984577574262644344433334466",
    
    chiseledSandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656655565555433332233333333221211111111010006666665555555550634330033003323053333103310332204344344004433320534333000033322044334404403432202111111111100000555555555555454053303300333000404302112112144020414143414313313043443333223323201111111110100000",
    cutSandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656555555554433222223323332222111111100000006666652555555540644343332442323164323333333332405333433322333340433224433243432052333343333333305223333333223320532342334323322024334433234333405434433333333330433333333322234144214344332134410100001100000000",
    sandstoneTop: "0g0g51n1a1vj1o5jqbj1p9td6n1qdxfcv1ricpa70322342222123321232223333131233133133234222102234233222323233212333321033333312222333013134311222132332132332212102232332131232121022343112232113202333321333321331134313233323332323310232332323123310133214311331333223332233222431233233322332023133222343332",
    sandstone: "0g0g71ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa71tqf5rz6666656555555554433222223323332200001100011000005014555515551015313232514433313335114410434340533331100013321003333504551214551013014333414343501002335300323334344253315514433133301015325104011315530323333024415441533324135231442015410001333311145114512211",
    sandstoneBottom: "0g0g61ikin0f1lwur5r1n1a1vj1o5pclb1qdxfcv1ricpa70244131433351344243310003331044213314441010030213014332315551105313232514433313335114410434340533331100013321003333504551214551013014333414343501002335300323334344253315514433133301015325104011315530323333024415441533324135231442015410001333311145114512210",
    
    tallGrassTop: "0g0g600000000000073091f2tb0cdr4lb0gu76yn0pqs35r3111111110011011100110311001100115414001154141011451510114525101155254001551050115500501450005011000050115000411120000103100003100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    tallGrassBottom: "0g0g7000000000000730cdwqv30em4s1r0gu76yn0k6j8qn0pqs35r1000000110000651100005615100006044000060040000500400005003100050602000605030006000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    
    //pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
    
    //pigFace: "0g0gr000006w14172ew1hejb3s1heul881luzbw81lvx4oo1o2w1dk1qb44541qbfcoo1sj0ws81sjc3qw1sjc5bs1sjndvc1sjnfg81sjynzs1sjypko1sk9y481skl9tk1ur8we01urk6ig1urvf201urvgmw1urvi7s1us6p6g1us6qrc1ustb081x2x0xkaa669999ddddbbddaa669999ddddbbdd7766ccii99kknnnn7766ccii99kknnnn88cceeeeddddeenn88cceeeeddddeenn00qqbbbbjjjjqq0000qqbbbbjjjjqq0099ddhhppppppggdd99ddhhppppppggddcccc11ddff11llllcccc11ddff11llll999922335544oomm999922335544oommbbbbddeellffffnnbbbbddeellffffnn",
    /*
    steveFace: "0g0gw08wkrnc0b4hipk0b4sr940dcpjw80fkxji00hs7rw80hsj0fs0hsuak80m9axh40sxbw8o0sxbxtk0xdgohk0zloo3c0zlopo811ta86w11twpa0141thx416a1hiw16acrnc16ao3co18i9h4o1aqhlh41aqsvlk1ar45q01cypmns1cz0ws81cz0yd41czc5bs1f78we01f78xyw1hfh0qg1x2x0xk221111110000111122111111000011111111113377441111111111337744111111rrttuuttttll3311rrttuuttttll33mmppmmnnjjttiiiimmppmmnnjjttiiiippvv88oott88vvmmppvv88oott88vvmmhhooqqaaaasskkcchhooqqaaaasskkccgggg66eeee66ffddgggg66eeee66ffdd999966556666ddbb999966556666ddbb",
    steveHeadTop: "0g0g406ocs1k08w9j3s08wkrnc0b4hipk3333223333222200333322333322221133223333332222223322333333222222333333223322222233333322332222222233332233333333223333223333333333333322223333333333332222333333333322223333333333332222333333333322333333113333332233332200333333333322222233333333222222223333",
    lexiFace: "0g0g6009pbso06oo3qw1urv2ew1utfnco1wxln201x2x0xk3333333333333333333333333333333333332222222233333333222222223333331111222211113333111122221111333355002222005533335500222200553333550022220055333355002222005533332222222222223333222222222222333322224444222233332222444422223333332222222233333333222222223333",
		lexiTop: "0g0g11utfnco0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sarahFace: "0g0g6009ehh406o1hx406oo3qw1wugttk1x1114o1x2x0xk1111111111111111111111111111111111114411111111111111441111111111111122441111111111112244111111111155004444111111115500444411111111550044444411111155004444441111114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		sarahTop: "0g0g106o1hx40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    sallyFace: "0g0g6000006w006lb0806oo3qw1sgim7s1wzrth41x2x0xk0000000000000000000000000000000000004444444400000000444444440000000022444422000000002244442200000000114444110000000011444411000000551144441155000055114444115500004444444444440000444444444444000044443333444400004444333344440000444444444444000044444444444400",
		sallyTop: "0g0g1000006w0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		face: "0g0g60077lrs0fkme480ohifp41unspvc1x1114o1x2x0xk1111111111111111111111111111111111114444444411111111444444441111112222444422221111222244442222111155004444005511115500444400551111550044440055111155004444005511114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
		faceTop: "0g0g10fkme480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    //*/
    
    cowSide:"0g0g400000000qoh7n40qoh7nc1uuozqw0000000000000000000000000000000000000000000000000000000000000000001111111111100011111111331111112233222333322322223332233332332222333222332233222233322222223322222222233322332222222222222222220220000000002200022000000000220002200000000022000220000000002200",
    cow: "0g0g20xd56go1uuozqw0000000000000000000100000001110000111000100111100011100000001111000110000000111100000001100001110010000111000000001100111100000000010011100110000000011100011000100001110000000011000000000001101100110000000100110011100011000010001111000110000000011100011100",
    
    error:"0g0g2000006w1ulbvg81111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000000000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111",
	}
  window.textures = textures

	const blockData = [
		{
			name: "air",
			id: 0,
			textures: [],
			transparent: true,
			shadow: false,
		},
		{
			name: "grass",
			textures: [ "dirt", "grassTop", "grassSide" ],
      breakTime: 0.9,
      drop:"dirt",
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{ name: "dirt", breakTime:0.75,
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]
    },
		{ name: "stone", drop:"cobblestone", breakTime:7.5, stoneSound:true},
		{ name: "bedrock", breakTime:Infinity, stoneSound:true},
		{ name: "sand", breakTime:0.75,
      onupdate: function(x,y,z){
        fall(x,y,z,blockIds.sand)
      },
      digSound: ["block.sand.dig1", "block.sand.dig2", "block.sand.dig3", "block.sand.dig4"],
      stepSound: ["block.sand.step1", "block.sand.step2","block.sand.step3","block.sand.step4","block.sand.step5"]},
		{ name: "gravel", breakTime:0.9,
      onupdate: function(x,y,z){
        fall(x,y,z,blockIds.gravel)
      },
      digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
      stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"]},
		{
			name: "leaves",
			transparent: true,
      breakTime: 0.3,
      drop: function(){
        if(rand() > 0.8){
          if(rand() > 0.5){
            return "stick"
          }else return "oakSapling"
        }
      },
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
		{
			name: "glass",
			transparent: true,
			shadow: false,
      breakTime: 0.45,
      glassSound: true
		},
		{ name: "cobblestone", breakTime:10, stoneSound:true},
		{ name: "mossyCobble", breakTime:10, stoneSound:true},
		{ name: "stoneBricks", breakTime:7.5, stoneSound:true},
		{ name: "mossyStoneBricks", breakTime:7.5, stoneSound:true},
		{ name: "bricks", breakTime:10, stoneSound:true},
		{ name: "coalOre", breakTime:15, drop:"coal", stoneSound:true},
		{ name: "ironOre", breakTime:15, drop:"rawIron", stoneSound:true},
		{ name: "goldOre", breakTime:15, drop:"rawGold", stoneSound:true},
		{ name: "diamondOre", breakTime:15, drop:"diamond", stoneSound:true},
		{ name: "redstoneOre", breakTime:15, stoneSound:true},
		{ name: "lapisOre", breakTime:15, drop:"lapisLazuli", stoneSound:true},
		{ name: "emeraldOre", breakTime:15, drop:"emerald", stoneSound:true},
		{ name: "coalBlock", breakTime:25, stoneSound:true},
		{ name: "ironBlock", breakTime:25, stoneSound:true},
		{ name: "goldBlock", breakTime:15, stoneSound:true},
		{ name: "diamondBlock", breakTime:25, stoneSound:true},
		{ name: "redstoneBlock", breakTime:25, stoneSound:true},
		{ name: "lapisBlock", breakTime:15, stoneSound:true},
		{ name: "emeraldBlock", breakTime:25, stoneSound:true},
		{ name: "oakPlanks", breakTime:3, woodSound:true},
		{
			name: "oakLog",
			textures: [ "logTop", "logSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "acaciaPlanks", breakTime:3, woodSound:true},
		{
			name: "acaciaLog",
			textures: [ "acaciaLogTop", "acaciaLogSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "birchPlanks", breakTime:3, woodSound:true},
		{
			name: "birchLog",
			textures: [ "birchLogTop", "birchLogSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "darkOakPlanks", breakTime:3, woodSound:true},
		{
			name: "darkOakLog",
			textures: [ "darkOakLogTop", "darkOakLogSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "junglePlanks", breakTime:3,woodSound:true},
		{
			name: "jungleLog",
			textures: [ "jungleLogTop", "jungleLogSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "sprucePlanks", breakTime:3, woodSound:true},
		{
			name: "spruceLog",
			textures: [ "spruceLogTop", "spruceLogSide" ],
      breakTime:3,
      woodSound:true
		},
		{ name: "whiteWool", breakTime:1.2, clothSound:true},
		{ name: "orangeWool", breakTime:1.2, clothSound:true},
		{ name: "magentaWool", breakTime:1.2, clothSound:true},
		{ name: "lightBlueWool", breakTime:1.2, clothSound:true},
		{ name: "yellowWool", breakTime:1.2, clothSound:true},
		{ name: "limeWool", breakTime:1.2, clothSound:true},
		{ name: "pinkWool", breakTime:1.2, clothSound:true},
		{ name: "grayWool", breakTime:1.2, clothSound:true},
		{ name: "lightGrayWool", breakTime:1.2, clothSound:true},
		{ name: "cyanWool", breakTime:1.2, clothSound:true},
		{ name: "purpleWool", breakTime:1.2, clothSound:true},
		{ name: "blueWool", breakTime:1.2, clothSound:true},
		{ name: "brownWool", breakTime:1.2, clothSound:true},
		{ name: "greenWool", breakTime:1.2, clothSound:true},
		{ name: "redWool", breakTime:1.2, clothSound:true},
		{ name: "blackWool", breakTime:1.2, clothSound:true},
		{ name: "whiteConcrete", breakTime:9, stoneSound:true},
		{ name: "orangeConcrete", breakTime:9, stoneSound:true},
		{ name: "magentaConcrete", breakTime:9, stoneSound:true},
		{ name: "lightBlueConcrete", breakTime:9, stoneSound:true},
		{ name: "yellowConcrete", breakTime:9, stoneSound:true},
		{ name: "limeConcrete", breakTime:9, stoneSound:true},
		{ name: "pinkConcrete", breakTime:9, stoneSound:true},
		{ name: "grayConcrete", breakTime:9, stoneSound:true},
		{ name: "lightGrayConcrete", breakTime:9, stoneSound:true},
		{ name: "cyanConcrete", breakTime:9, stoneSound:true},
		{ name: "purpleConcrete", breakTime:9, stoneSound:true},
		{ name: "blueConcrete", breakTime:9, stoneSound:true},
		{ name: "brownConcrete", breakTime:9, stoneSound:true},
		{ name: "greenConcrete", breakTime:9, stoneSound:true},
		{ name: "redConcrete", breakTime:9, stoneSound:true},
		{ name: "blackConcrete", breakTime:9, stoneSound:true},
		{
			name: "bookshelf",
			textures: [ "oakPlanks", "bookshelf" ],
      stoneSound: true
		},
		{ name: "netherrack",
      digSound: ["block.netherrack.dig1", "block.netherrack.dig2", "block.netherrack.dig3", "block.netherrack.dig4", "block.netherrack.dig5", "block.netherrack.dig6"],
      stepSound: ["block.netherrack.step1", "block.netherrack.step2","block.netherrack.step3","block.netherrack.step4","block.netherrack.step5","block.netherrack.step6"]},
		{ name: "soulSand",
      _1PixLower: true,
      speedFactor: 0.5,
      digSound: ["block.soul_sand.dig1", "block.soul_sand.dig2", "block.soul_sand.dig3", "block.soul_sand.dig4", "block.soul_sand.dig5", "block.soul_sand.dig6","block.soul_sand.step7","block.soul_sand.step8","block.soul_sand.step9"],
      stepSound: ["block.soul_sand.step1", "block.soul_sand.step2","block.soul_sand.step3","block.soul_sand.step4","block.soul_sand.step5","block.soul_sand.step6"]},
		{
			name: "glowstone",
			lightLevel: 15,
      glassSound: true
		},
		{ name: "netherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "redNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
		{ name: "netherQuartzOre", 
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
		{
			name: "quartzBlock",
			textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
      stoneSound: true
		},
		{
			name: "quartzPillar",
			textures: ["quartzPillarTop", "quartzPillar"],
      stoneSound: true
		},
		{
			name: "chiseledQuartzBlock",
			textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"],
        stoneSound: true
		},
		{ name: "chiseledStoneBricks", stoneSound:true},
		{ name: "smoothStone", stoneSound:true},
		{ name: "andesite", stoneSound:true},
		{ name: "polishedAndesite", stoneSound:true},
		{ name: "diorite", stoneSound:true},
		{ name: "polishedDiorite", stoneSound:true},
		{ name: "granite", stoneSound:true},
		{ name: "polishedGranite", stoneSound:true},
		{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
		  name: "tnt",
		  textures: ["tntBottom", "tntTop", "tntSides"],
      //onupdate: function(x,y,z){
      //  explode(x,y,z,5)
      //}, flint and steel explodes it
      explode: function(x,y,z){
        var e = new BlockEntity(blockIds.tnt, x,y,z)
        e.velx = (Math.random() * 0.1) - 0.05
        e.vely = Math.random() * 0.1
        e.velz = (Math.random() * 0.1) - 0.05
        world.addEntity(e)
        world.setBlock(x,y,z,0)
        playSound("entity.tnt.fuse", 0, posSound(x,y,z))
        var i = 0
        var int = setInterval(() => {
          e.changeBlock((i % 2) ? blockIds.tnt : blockIds.whiteConcrete)
          if(i >= 8){
            clearInterval(int)
            e.canDespawn = true
            explode(round(e.x),round(e.y),round(e.z),4)
          }
          i++
        },500)
      },
      digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
      stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
		},
    {
      name: "portal",
      solid:false,
      shadow: false,
      portal: true,
      transparent:true,
      lightLevel: 11,
      ontouch: function(){
        portalEffect += 2
        if(portalEffect >= 100){
          portalEffect = 0
          //releasePointer()
          if(world.type === "nether"){
            world = dimensions.overworld
            //world.loadSave(world.getSaveString())
            //changeScene("loading")
          }else{
            world = dimensions.nether
            //world.loadSave(world.getSaveString())
            //changeScene("netherLoading")
          }
        }
      },
      glassSound: true
    },
    { name: "obsidian", stoneSound:true},
    {
      name:"redstoneDust",
      onupdate: function(x,y,z){
        var neigbors = [
          world.getBlock(x+1,y,z),
          world.getBlock(x-1,y,z),
          world.getBlock(x,y,z+1),
          world.getBlock(x,y,z-1),
          world.getBlock(x,y+1,z),
          world.getBlock(x,y-1,z)
        ];
        
        if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
          world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
        }
        
      }
    },
    {
      name:"redstoneDustOn",
      hidden: true,
      onupdate: function(x,y,z){
        var checked = []
        
        function touchingSource(x,y,z, t){
          t = t || 0;
          t ++;
          
          var neighbors = [
            [x+1,y,z],
            [x-1,y,z],
            [x,y,z+1],
            [x,y,z-1],
            [x,y+1,z],
            [x,y-1,z]
          ];
          
          for(var i=0; i<neighbors.length; i++){
            var value = neighbors[i];
            var block = world.getBlock(value[0], value[1], value[2])
            
            if(block === blockIds.redstoneBlock){
              return true;
            }
            
            if(t<10){
              if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
                checked.push(value);
                return true
              };
            }
            
          }
          return false;
        }
        
        if(!touchingSource(x,y,z)){
          world.setBlock(x,y,z, blockIds.redstoneDust);
        }
        
        //world.setBlock(x,y,z, blockIds.redstoneDust);
      }
    },
    {
      name: "buffer",
      textures: ["bufferTop", "bufferMiddle"],
      onupdate: function(x,y,z){
        setTimeout(() => {
          var isOn = world.getBlock(x,y+1,z);
          isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
          if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
            setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
          }
        }, 10)
      }
    },
    { name: "soup"},
    { name: "soup2"},
    {
      name: "soup3",
      transparent:true,
    },
    { name: "soup4"},
    { name: "randomSoup"},
    {
      name: "redStain",
      transparent: true,
    },
    {
      name:"poision potion",
      transparent:true,
      crossShape:true,
    },
    
    {
      name: "light",
      textures: "none",
      transparent:true,
      lightLevel: 15,
      solid: false,
      icon: "glass",
      shadow: false
    },
    
    {
			name: "autumnLeaves",
			transparent: true,
		},
		{
			name: "darkLeaves",
			transparent: true,
		},
		{
			name: "redBerryLeaves",
			transparent: true,
		},
		{
			name: "blueBerryLeaves",
			transparent: true,
		},
    {
      name: "pinkLeaves",
      transparent: true,
    },
    
    { name: "flowerOftheValley",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "poppy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
		{ name: "dandelion",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "blueOrchid",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
		},
    { name: "pinkTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "orangeTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "redTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "whiteTulip",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "azureBluet",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "cornFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "purpleFlower",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "allium",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "oxeyeDaisy",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
		},
    { name: "lilac",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "lilacTop",
        tallcrossShape: true,
		},
    { name: "roseBush",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "roseBushTop",
        tallcrossShape: true,
		},
    { name: "peony",
		    solid: false,
		    transparent: true,
		    shadow: false,
      textures: "peonyTop",
        tallcrossShape: true,
		},
    { name: "witherRose",
		    solid: false,
		    transparent: true,
		    shadow: false,
      potCross: true,
        crossShape: true,
      ontouch: () => {witherEffect = 120; witherDamage = 1; witherTime = 2000}
		},
    { name: "TallGrass",
		    solid: false,
		    transparent: true,
		    shadow: false,
        crossShape: true,
		},
    
		{ 
      name: "oakDoor",
		  transparent: true,
		  shadow: false,
      textures: "oakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "spruceDoor",
		  transparent: true,
		  shadow: false,
      textures:"spruceDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "ironDoor",
		  transparent: true,
		  shadow: false,
      textures:"ironDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "darkOakDoor",
		  transparent: true,
		  shadow: false,
      textures:"darkOakDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "birchDoor",
		  transparent: true,
		  shadow: false,
      textures:"birchDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "jungleDoor",
		  transparent: true,
		  shadow: false,
      textures:"jungleDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "acaciaDoor",
		  transparent: true,
		  shadow: false,
      textures:"acaciaDoorBottom",
      door:true,
      woodSound:true
    },
		{
      name: "warpedDoor",
		  transparent: true,
		  shadow: false,
      textures:"warpedDoorBottom",
      door:true,
      woodSound:true
		},
		{
      name: "crimsonDoor",
		  transparent: true,
		  shadow: false,
      textures:"crimsonDoorBottom",
      door:true,
      woodSound:true
		},
    
    {
      name: "torch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 13,
      woodSound:true
		},
		{
      name: "soulTorch",
		  transparent: true,
		  shadow: false,
      torch: true,
      lightLevel: 10,
      woodSound:true
		},
    
    {
      name: "lantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 13,
      iconTexture: "lanternIcon",
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      stepSound: ["block.lantern.step1", "block.lantern.step2","block.lantern.step3","block.lantern.step4","block.lantern.step5","block.lantern.step6"]
		},
    {
      name: "soulLantern",
		  transparent: true,
		  shadow: false,
      lightLevel: 10,
      iconTexture:"soulLanternIcon",
      lantern: true,
      digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
      stepSound: ["block.lantern.step1", "block.lantern.step2","block.lantern.step3","block.lantern.step4","block.lantern.step5","block.lantern.step6"]
		},
    
    {
      name: "beacon", 
		  transparent: true,
		  shadow: false,
      beacon: true,
      lightLevel: 15,
      glassSound: true
		},
    
    {
      name: "cactus",
		  textures: ["cactusBottom", "cactusTop", "cactusSide"],
		  transparent: true,
      cactus: true,
      damage: 1,
      potCross: true
		},
    
    {
			name: "glassPane",
			transparent: true,
			shadow: false,
      breakTime: 60,
      pane:true,
      textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
      glassSound: true
		},
    
    { name: "ladder",
		  transparent: true,
		  shadow: false,
		  wallFlat: true,ladder:true
		},
		{ name: "vine",
		  transparent: true,
		  shadow: false,
		  wallFlat: true,ladder:true
		},
    
    {
      name: "Water",
      transparent: true,
      liquid: true,
      shadow: false //to hide faces
    },
    {
      name: "Lava",
      transparent: true,
      liquid: true,
      lightLevel:15,
      damage:4,
      dieMessage: () => username+" tried to swim in lava.",
      shadow: false
    },
    
    {
      name: "craftingTable",
      textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
      onclick: () => {changeScene("crafting"); releasePointer()},
      woodSound: true
    },
    
    {
      name: "crimsonNylium",
      textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
      nyliumSound: true
    },
    {
      name: "warpedNylium",
      textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
      nyliumSound: true
    },
    {
      name: "crimsonStem",
      textures: ["crimsonStemTop", "crimsonStemSide"],
      stemSound: true
    },
    {
      name: "warpedStem",
      textures: ["warpedStemTop", "warpedStemSide"],
      stemSound: true
    },
    { name: "netherWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "warpedWartBlock",
      digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
      stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
    { name: "shroomlight", lightLevel:15,
      digSound: ["block.shroomlight.dig1", "block.shroomlight.dig2", "block.shroomlight.dig3", "block.shroomlight.dig4", "block.shroomlight.dig5"],
      stepSound: ["block.shroomlight.step1", "block.shroomlight.step2","block.shroomlight.step3","block.shroomlight.step4","block.shroomlight.step5","block.shroomlight.step6"]},
    { 
		  name: "warpedFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
    {
			name: "blackstone",
			textures: ["blackstoneTop", "blackstone" ],
      stoneSound: true
		},
		{ name: "gildedBlackstone", stoneSound: true},
		{ name: "polishedBlackstoneBricks", stoneSound: true},
		{ name: "chiseledPolishedBlackstone", stoneSound: true},
		{ name: "netheriteBlock", 
      digSound: ["block.netherite.dig1", "block.netherite.dig2", "block.netherite.dig3", "block.netherite.dig4"],
      stepSound: ["block.netherite.step1", "block.netherite.step2","block.netherite.step3","block.netherite.step4","block.netherite.step5","block.netherite.step6"]},
    {
			name: "basalt",
			textures: [ "basaltTop", "basaltSide" ],
      basaltSound: true
		},
    {
			name: "polishedBasalt",
			textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
      basaltSound: true
		},
		{ name: "chain", transparent:true, shadow:false, chain:true, iconTexture:"chainIcon",
      digSound: ["block.chain.dig1", "block.chain.dig2", "block.chain.dig3", "block.chain.dig4"],
      stepSound: ["block.chain.step1", "block.chain.step2","block.chain.step3","block.chain.step4","block.chain.step5","block.chain.step6"]},
		{ name: "warpedPlanks", woodSound:true},
		{ 
		  name: "warpedTrapdoor",
		  transparent: true,
      shadow: false,
      trapdoor: true,
      woodSound:true
		},
		{ name: "magma", lightLevel:15},
		{
		  name: "crimsonFungus",
		  solid: false,
		  shadow: false,
      transparent: true,
      crossShape: true,
      potCross: true,
      digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
		},
		{ 
		    name: "warpedRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
        rootSound: true
		},
		{ 
		    name: "crimsonRoots",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true,
      rootSound: true
		},
		{ 
		    name: "twistingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "twistingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true
		},
		{ 
		    name: "weepingVines",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "weepingVinesPlant",
      transparent: true,
		    solid: false,
		    shadow: false,
      crossShape: true
		},
		{ 
		    name: "netherSprouts",
		    solid: false,
		    shadow: false,
      transparent: true,
      crossShape: true,
      digSound: ["block.nether_sprouts.dig1", "block.nether_sprouts.dig2", "block.nether_sprouts.dig3", "block.nether_sprouts.dig4"],
      stepSound: ["block.nether_sprouts.step1", "block.nether_sprouts.step2","block.nether_sprouts.step3","block.nether_sprouts.step4","block.nether_sprouts.step5"]
		},
    
    { name: "stoneButton", textures:"stone", button:true, transparent: true },
    
    { 
		  name: "RespawnAnchorOff",
		  textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
      onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
		},
		{ 
		  name: "RespawnAnchor1",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor2",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor3",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
      //hidden: true
		},
		{ 
		  name: "RespawnAnchor",
		  textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
      //hidden: true
		},
    
    {
      name:"redBed",
      textures: "bedbottom",
      iconTexture: "bedIcon",
      flatIcon: true,
      onclick: (x,y,z) => {
        if(world.type !== ""){explode(x,y,z,5); return}
        world.spawnPoint.x=x
        world.spawnPoint.y=y
        world.spawnPoint.z=z
        Messages.add("You can't sleep in beds yet")
        Messages.add("Respawn point set")
      },
      transparent: true,
      bed: true,
      bounciness: 0.6
    },
    
    {
      name: "flintAndSteel",
      textures: "flintAndSteel",
      item: true,
      onuse: (x,y,z, block) => {
        if(block === blockIds.tnt){
          blockData[blockIds.tnt].explode(x,y,z)
        }
      }
    },
    
    {
      name: "barrier",
      textures: "none",
      icon: "redConcrete",
      transparent:true
    },
    {
      name: "oakSapling",
      crossShape: true,
      potCross: true,
      transparent: true,
      solid: false,
    },
    
    { 
		  name: "crimsonTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "oakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "spruceTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "darkOakTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "birchTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "jungleTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "acaciaTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    { 
		  name: "ironTrapdoor",
      transparent: true,
      trapdoor: true,
      woodSound: true
		},
    
    { 
      name: "cryingObsidian",
      shadow: false,
      lightLevel: 10
    },
    { name: "netherGoldOre",
      digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
      stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"]},
    {
			name: "flowerPot",
			transparent: true,
			shadow: false,
      pot: true
		},
		{
			name: "acaciaSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "birchSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "darkOakSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "jungleSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "spruceSapling",
			transparent: true,
			shadow: false,
			solid: false,
      crossShape: true,
      potCross: true
		},
		{
			name: "blueOrchidPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "warpedRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
		{
			name: "crimsonRootsPot",
			transparent: true,
			shadow: false,
			solid: false,
      potCross: true
		},
    { name: "whiteCarpet", textures: "whiteWool", carpet: true, clothSound:true},
		{ name: "orangeCarpet", textures: "orangeWool", carpet: true, clothSound:true},
		{ name: "magentaCarpet", textures: "magentaWool", carpet: true, clothSound:true},
		{ name: "lightBlueCarpet", textures: "lightBlueWool", carpet: true, clothSound:true},
		{ name: "yellowCarpet", textures: "yellowWool", carpet: true, clothSound:true},
		{ name: "limeCarpet", textures: "limeWool", carpet: true, clothSound:true},
		{ name: "pinkCarpet", textures: "pinkWool", carpet: true, clothSound:true},
		{ name: "grayCarpet", textures: "grayWool", carpet: true, clothSound:true},
		{ name: "lightGrayCarpet", textures: "lightGrayWool", carpet: true, clothSound:true},
		{ name: "cyanCarpet", textures: "cyanWool", carpet: true, clothSound:true},
		{ name: "purpleCarpet", textures: "purpleWool", carpet: true, clothSound:true},
		{ name: "blueCarpet", textures: "blueWool", carpet: true, clothSound:true},
		{ name: "brownCarpet", textures: "brownWool", carpet: true, clothSound:true},
		{ name: "greenCarpet", textures: "greenWool", carpet: true, clothSound:true},
		{ name: "redCarpet", textures: "redWool", carpet: true, clothSound:true},
		{ name: "blackCarpet", textures: "blackWool", carpet: true, clothSound:true},
    
    { name: "polishedBlackstone", stoneSound:true},
    { name: "chiseledNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
    { name: "crackedNetherBricks",
      digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
      stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
    { name: "smoothBasalt", basaltSound: true},
    
    {
			name: "oakLogSW",
			textures: ["logSide","logSide","logTop","oakLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "acaciaLogSW",
			textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "birchLogSW",
			textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "darkOakLogSW",
			textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "jungleLogSW",
			textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSW"],
      rotate: true, woodSound:true
		},
		{
			name: "spruceLogSW",
			textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSW"],
      rotate: true, woodSound:true
		},
    {
			name: "crimsonStemSW",
			textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSW"],
      rotate: true, stemSound:true
		},
    {
			name: "warpedStemSW",
			textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSW"],
      rotate: true, stemSound:true
		},
    {
			name: "basaltSW",
			textures: ["basaltSide","basaltSide","basaltTop","basaltSideSW"],
      rotate: true, basaltSound:true
		},
    {
			name: "polishedBasaltSW",
			textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSideSW"],
      rotate: true, basaltSound: true
		},
    { name:"crimsonPlanks",woodSound:true },
    {
      name:"deadBush",
      solid: false,
      transparent: true,
      shadow: false,
      potCross: true,
      crossShape: true,
      drop: "stick",
      dropAmount: [0,2]
    },
    { name:"stick", item:true },
    { name:"coal", item:true },
    { name:"ironIngot", item:true },
    { name:"copperIngot", item:true },
    { name:"goldIngot", item:true },
    { name:"diamond", item:true },
    { name:"lapisLazuli", item:true },
    { name:"emerald", item:true },
    { name:"copperOre", breakTime:140, drop:"rawCopper", stoneSound:true },
    { name:"rawIron", item:true },
    { name:"rawCopper",item:true },
    { name:"rawGold",item:true },
    
    {
      name: "netherWart",
      transparent: true,
      shadow: false,
      solid: false,
      crop: true
		},
		{
      name: "wheat",
      transparent: true,
      shadow: false,
      solid: false,
      crop: true
		},
    {
      name: "lodestone",
      textures: ["lodestoneTop", "lodestoneSide"]
    },
    {
      name: "anvil",
      transparent: true,
      anvil: true,
      digSound: "block.anvil.land",
      stepSound: ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
      onupdate: function(x,y,z,b){
        fall(x,y,z,b)
      },
		},
    
    { name: "slime",
		  transparent: true,
		  shadow: false,
		  bounciness: 0.8,
      speedFactor: 0.5
		},
    { 
      name:"soulSoil",
      _1PixLower: true,
      speedFactor: 0.5,
    },
    { name:"blueIce", slide:0.9 },
    { name:"ice", slide:0.9 },
    { name:"packedIce", slide:0.9 },
    { name:"calcite" },
    {
      name:"furnace",
      textures: ["furnaceTop","furnaceTop","furnaceFront","furnaceSide","furnaceSide","furnaceSide"],
      rotate: true
    },
    {
      name:"blastFurnace",
      textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide","blastFurnaceSide"],
      rotate: true
    },
    {
      name:"smoker",
      textures: ["smokerBottom","smokerTop","smokerFront","smokerSide","smokerSide","smokerSide"],
      rotate: true
    },
    {
      name:"noteBlock"
    },
    {
      name:"jukebox",
      textures: ["jukeboxTop","jukeboxSide"]
    },
    {
      name:"loom",
      textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
      rotate: true
    },
    
    {
      name:"sandstone",
      textures: ["sandstoneBottom", "sandstoneTop", "sandstone"]
    },
    { name:"chiseledSandstone",
      textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"]
    },
    { name:"cutSandstone",
      textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"]
    },
    { name:"smoothSandstone", textures:"sandstoneTop" },
    { name: "tallGrass",
      solid: false,
      transparent: true,
      shadow: false,
      textures: "tallGrassTop",
      tallcrossShape: true,
		},
    
    /*
    { name: "pigFace" },
		{ 
		  name: "steveFace",
		  textures: ["steveHeadTop", "steveFace"]
		},
    { name: "sarahFace",
      textures: ["sarahTop", "sarahFace"]
    },
    {
      name: "lexiFace",
      textures: ["lexiTop","lexiFace"]
    },
    {
      name: "sallyFace",
      textures: ["sallyTop","sallyFace"]
    },
    {
      name: "face",
      textures: ["faceTop","face"]
    },//*/
    {
      name: "cow",
      textures: "egg",
      item: true,
      solid:false,//error in the console 
      onuse: function(){
        playSound("block.glass.dig1")
        world.entities.push(new Cow(p2.x, p2.y, p2.z))
      },
    },
	];

	const BLOCK_COUNT = blockData.length;
  window.console.log(BLOCK_COUNT)

  const emptyFunc = function(){}
  var stoneDigSound = ["block.stone.dig1", "block.stone.dig2", "block.stone.dig3", "block.stone.dig4"],
      stoneStepSound = ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
      woodDigSound = ["block.wood.dig1", "block.wood.dig2", "block.wood.dig3", "block.wood.dig4"],
      woodStepSound = ["block.wood.step1", "block.wood.step2","block.wood.step3","block.wood.step4","block.wood.step5","block.wood.step6"],
      clothDigSound = ["block.cloth.dig1", "block.cloth.dig2", "block.cloth.dig3", "block.cloth.dig4"],
      clothStepSound = ["block.cloth.step1", "block.cloth.step2","block.cloth.step3","block.cloth.step4"],
      glassDigSound = ["block.glass.dig1", "block.glass.dig2", "block.glass.dig3"],
      nyliumDigSound = ["block.nylium.dig1", "block.nylium.dig2", "block.nylium.dig3", "block.nylium.dig4", "block.nylium.dig5", "block.nylium.dig6"],
      nyliumStepSound = ["block.nylium.step1", "block.nylium.step2","block.nylium.step3","block.nylium.step4","block.nylium.step5","block.nylium.step6"],
      stemDigSound = ["block.stem.dig1", "block.stem.dig2", "block.stem.dig3", "block.stem.dig4", "block.stem.dig5", "block.stem.dig6"],
      stemStepSound = ["block.stem.step1", "block.stem.step2","block.stem.step3","block.stem.step4","block.stem.step5","block.stem.step6"],
      basaltDigSound = ["block.basalt.dig1", "block.basalt.dig2", "block.basalt.dig3", "block.basalt.dig4", "block.basalt.dig5"],
      basaltStepSound = ["block.basalt.step1", "block.basalt.step2","block.basalt.step3","block.basalt.step4","block.basalt.step5","block.basalt.step6"],
      rootDigSound = ["block.roots.dig1", "block.roots.dig2", "block.roots.dig3", "block.roots.dig4", "block.roots.dig5", "block.roots.dig6"],
      rootStepSound = ["block.roots.step1", "block.roots.step2","block.roots.step3","block.roots.step4","block.roots.step5","block.roots.step6"]
	// Set defaults on blockData
	for (let i = 1; i < BLOCK_COUNT; ++i) {
		const data = blockData[i];
		data.id = i;

		if ( !("textures" in data) ) {
			data.textures = new Array(6).fill(data.name);
		} else if (typeof data.textures === "string") {
			data.textures = new Array(6).fill(data.textures);
		} else {
			const { textures } = data;

			if (textures.length === 3) {
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
			} else if (textures.length === 2) {
				// Top and bottom are the first texture, sides are the second.
				textures[2] = textures[1];
				textures[3] = textures[2];
				textures[4] = textures[2];
				textures[5] = textures[2];
				textures[1] = textures[0];
			}else if(textures.length === 4){
        textures[4] = textures[5] = textures[3]
        textures[3] = textures[2]
      }
		}
    for(let t = 0; t<data.textures.length; t++){
      if(!textures[data.textures[t]]){
        console.log("Missing texture for "+data.textures[t])
        data.textures[t] = "error"
      }
    }

		data.transparent = data.transparent || false

		data.shadow = data.shadow !== undefined ? data.shadow	: true

		data.lightLevel = data.lightLevel || 0
    
    data.onupdate = data.onupdate || emptyFunc
      
    if(data.solid === undefined)data.solid = true
    
    data.breakTime = data.breakTime ? data.breakTime*1000 : 0.05*1000 // frames for total mine
    
    if(data.dropAmount === undefined) data.dropAmount = 1
    
    if(data.item || data.crossShape || data.tallcrossShape || data.ladder || data.torch || data.door || data.lantern || data.chain) data.flatIcon = true
    if(data.door) data.iconTexture = data.name
    
    if(data.liquid) data.noHitbox = true
    
    if(data.stoneSound){
      data.digSound = stoneDigSound
      data.stepSound = stoneStepSound
    }
    if(data.woodSound){
      data.digSound = woodDigSound
      data.stepSound = woodStepSound
    }
    if(data.clothSound){
      data.digSound = clothDigSound
      data.stepSound = clothStepSound
    }
    if(data.glassSound){
      data.digSound = glassDigSound
      data.placeSound = stoneDigSound
    }
    if(data.nyliumSound){
      data.digSound = nyliumDigSound
      data.stepSound = nyliumStepSound
    }
    if(data.stemSound){
      data.digSound = stemDigSound
      data.stepSound = stemStepSound
    }
    if(data.basaltSound){
      data.digSound = basaltDigSound
      data.stepSound = basaltStepSound
    }
    if(data.rootSound){
      data.digSound = rootDigSound
      data.stepSound = rootStepSound
    }
	}
  
  let textureIds = {}
  let idx = -1
  for(var i in textures){
    idx ++
    textureIds[i] = idx
  }
  window.textureIds = textureIds
  
  // survival inventory
  let invItems = [1];
  let invLength = 13*9;
  for(let i=0; i<invLength; i++){
    if(!invItems[i]){
      invItems.push({id:0,amount:64})
    }
  }
  //add something to inventory
  function newInvItem(id){
    //look for empty slot
    for(let i=0; i<inventory.hotbar.length; i++){
      if(!inventory.hotbar[i].id){
        inventory.hotbar[i] = {id:id, amount:1}
        return true
      }
      if(inventory.hotbar[i].id === id && inventory.hotbar[i].amount < 64){
        inventory.hotbar[i].amount ++;
        return true
      }
    }
    for(let i=0; i<invLength; i++){
      if(!(invItems[i] && invItems[i].id)){
        invItems[i] = {id:id, amount:1}
        return true
      }
      if(invItems[i].id === id && invItems[i].amount < 64){
        invItems[i].amount ++;
        return true
      }
    }
    return false
  }
  
  const crafts = {
    "oakLog": {name:"oakPlanks", amount:4},
    "acaciaLog": {name:"acaciaPlanks", amount:4},
    "birchLog": {name:"birchPlanks", amount:4},
    "darkOakLog": {name:"darkOakPlanks", amount:4},
    "jungleLog": {name:"junglePlanks", amount:4},
    "spruceLog": {name:"sprucePlanks", amount:4},
    "oakPlanks,air,air,oakPlanks": {name:"stick", amount:4},
    "acaciaPlanks,air,air,acaciaPlanks": {name:"stick", amount:4},
    "birchPlanks,air,air,birchPlanks": {name:"stick", amount:4},
    "darkOakPlanks,air,air,darkOakPlanks": {name:"stick", amount:4},
    "junglePlanks,air,air,junglePlanks": {name:"stick", amount:4},
    "sprucePlanks,air,air,sprucePlanks": {name:"stick", amount:4},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
    "acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
    "birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
    //i dont want to make the rest of the doors
    "oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
    "redWool,redWool,redWool,oakPlanks,oakPlanks,oakPlanks":{name:"redBed", amount:3},
    "oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"craftingTable"},
    "air,air,air,air,coal,air,air,stick":{name:"torch",amount:4},
    "coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
    "ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
    "goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
    "diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
    "lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
    "emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
  }
  
	// implementation of xxHash
	const {
		seedHash,
		hash
	} = (() => {
		// closure around mutable `seed`; updated via calls to `seedHash`

		let seed = Math.random() * 2100000000 | 0;

		const PRIME32_2 = 1883677709;
		const PRIME32_3 = 2034071983;
		const PRIME32_4 = 668265263;
		const PRIME32_5 = 374761393;

		const seedHash = s => {
			seed = s | 0;
		}

		const { imul } = Math;

		const hash = (x, y) => {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += imul(x, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += imul(y, PRIME32_3);
			h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};

		return {
			seedHash,
			hash
		};
	})();

	const win = window.parent;
	const doc = document;
	const { console } = win;
	win.world = undefined;
	let worldSeed;
  let dimensions;
  function setSeed(seed){
    worldSeed = seed
		seedHash(worldSeed)
		caveNoise = openSimplexNoise(worldSeed)
		noiseProfile.noiseSeed(worldSeed)
  }

	class Marsaglia {
		// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

		nextInt() {
			const { z, w } = this;

			this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
			this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

			return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
		}

		nextDouble() {
			const i = this.nextInt() / 4294967296;

			const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

			return is_less_than_zero + i;
		}

		constructor(i1, i2) { // better param names
			this.z = (i1 | 0) || 362436069;
			this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
		}
	}

	// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls

	const {
		randomSeed,
		random
	} = (() => {
		// closure around mut `currentRandom`

		let currentRandom = null;

		const randomSeed = seed => {
			currentRandom = new Marsaglia(seed);
		};

		const random = (min, max) => {
			if (!max) {
				if (min) {
					max = min;
					min = 0;
				} else {
					min = 0;
					max = 1;
				}
			}

			return currentRandom.nextDouble() * (max - min) + min;
		};

		return {
			randomSeed,
			random
		};
	})();

	class PerlinNoise {
		// http://www.noisemachine.com/talk1/17b.html
		// http://mrl.nyu.edu/~perlin/noise/

		static grad3d(i, x, y, z) {
			const h = i & 15; // convert into 12 gradient directions

			const u = h < 8
				? x
				: y;

			const v = h < 4
				? y
				: h === 12 || h === 14
					? x
					: z;

			return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
		}

		static grad2d(i, x, y) {
			const v = (i & 1) === 0
				? x
				: y;

			return (i & 2) === 0
				? -v
				: v;
		}

		static grad1d(i, x) {
			return (i & 1) === 0
				? -x
				: x;
		}

		static lerp(t, a, b) {
			return a + t * (b - a);
		}

		// end of statics

		// permutation
		perm = new Uint8Array(0x200);

		// prototype functions:
		noise3d(x, y, z) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;
			const Z = floor(z) & 0xff;

			x -= floor(x);
			y -= floor(y);
			z -= floor(z);

			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const fz = (3 - 2 * z) * z * z;

			const { perm } = this;

			const p0 = perm[X] + Y;
			const p00 = perm[p0] + Z;
			const p01 = perm[p0 + 1] + Z;
			const p1 = perm[X + 1] + Y;
			const p10 = perm[p1] + Z;
			const p11 = perm[p1 + 1] + Z;

			const { lerp, grad3d } = PerlinNoise;

			return lerp(
				fz,
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00], x, y, z),
						grad3d(perm[p10], x - 1, y, z)
					),
					lerp(
						fx,
						grad3d(perm[p01], x, y - 1, z),
						grad3d(perm[p11],x - 1, y - 1, z)
					)
				),
				lerp(
					fy,
					lerp(
						fx,
						grad3d(perm[p00 + 1], x, y, z - 1),
						grad3d(perm[p10 + 1], x - 1, y, z - 1)
					),
					lerp(
						fx,
						grad3d(perm[p01 + 1], x, y - 1, z - 1),
						grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
					)
				)
			);
		}

		noise2d(x, y) {
			const { floor } = Math;

			const X = floor(x) & 0xff;
			const Y = floor(y) & 0xff;

			x -= floor(x);
			y -= floor(y);

			const { perm } = this;
			const fx = (3 - 2 * x) * x * x;
			const fy = (3 - 2 * y) * y * y;
			const p0 = perm[X] + Y;
			const p1 = perm[X + 1] + Y;

			const { lerp, grad2d } = PerlinNoise;

			return lerp(
				fy,
				lerp(
					fx,
					grad2d(
						perm[p0],
						x,
						y
					),
					grad2d(
						perm[p1],
						x - 1,
						y
					)
				),
				lerp(
					fx,
					grad2d(
						perm[p0 + 1],
						x,
						y - 1
					),
					grad2d(
						perm[p1 + 1],
						x - 1,
						y - 1
					)
				)
			);
		}

		noise1d(x) {
			const { floor } = Math;

			const X = floor(x) & 0xff;

			x -= floor(x);

			const fx = (3 - 2 * x) * x * x;

			const { lerp, grad1d } = PerlinNoise;

			return lerp(
				fx,
				grad1d(perm[X], x),
				grad1d(perm[X + 1], x - 1)
			);
		}

		constructor(seed) {
			if (seed === undefined) {
				throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
			}

			const rnd = new Marsaglia(seed);

			// generate permutation
			const { perm } = this;

			// fill 0x0..0x100
			for (let i = 0; i < 0x100; ++i) {
				perm[i] = i;
			}

			for (let i = 0; i < 0x100; ++i) {
				const j = rnd.nextInt() & 0xFF;
				const t = perm[j];
				perm[j] = perm[i];
				perm[i] = t;
			}

			// copy to avoid taking mod in perm[0]
			// copies from first half of array, into the second half
			perm.copyWithin(0x100, 0x0, 0x100);
		}
	}

	const noiseProfile = {
		generator: undefined,
		octaves: 4,
		fallout: 0.5,
		seed: undefined,
		noiseSeed(seed) {
			this.seed = seed;
			this.generator = new PerlinNoise(noiseProfile.seed);
		},
		noise(x, y, z) {
			const { generator, octaves, fallout } = (this || noiseProfile);

			let effect = 1,
				k = 1,
				sum = 0;

			for (let i = 0; i < octaves; ++i) {
				effect *= fallout;

				const k = 1 << i;

				let temp;
				switch (arguments.length) {
					case 1: {
						temp = generator.noise1d(k * x);
						break;
					} case 2: {
						temp = generator.noise2d(k * x, k * y);
						break;
					} case 3: {
						temp = generator.noise3d(k * x, k * y, k * z);
						break;
					}
				}

				sum += effect * (1 + temp) / 2;
			}

			return sum;
		}
	};
  const noise = noiseProfile.noise

	let caveNoise;
	// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
	function openSimplexNoise(clientSeed) {
		const SQ4 = 2
		const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
		const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
		const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
		const NORM_3D = 1.0 / 206.0
		const SQUISH_3D = 1 / 3
		const STRETCH_3D = -1 / 6
		var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
		const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
		var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
		var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
		const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
		const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }

		function shuffleSeed(seed,count){
			seed = seed * 1664525 + 1013904223 | 0
			count -= 1
			return count > 0 ? shuffleSeed(seed, count) : seed
		}
		const types = {
			_3D : {
				base : base3D,
				squish : SQUISH_3D,
				dimensions : 3,
				pD : p3D,
				lookup : lookupPairs3D,
			}
		}

		function createContribution(type, baseSet, index) {
			var i = 0
			const multiplier = baseSet[index ++]
			const c = { next : undefined }
			while(i < type.dimensions) {
				const axis = ("xyzw")[i]
				c[axis + "sb"] = baseSet[index + i]
				c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
			}
			return c
		}

		function createLookupPairs(lookupArray, contributions){
			var i
			const a = lookupArray()
			const res = new Map()
			for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
			return res
		}

		function createContributionArray(type) {
			const conts = []
			const d = type.dimensions
			const baseStep = d * d
			var k, i = 0
			while (i < type.pD.length) {
				const baseSet = type.base[type.pD[i]]
				let previous, current
				k = 0
				do {
					current = createContribution(type, baseSet, k)
					if (!previous) { conts[i / baseStep] = current; }
					else { previous.next = current; }
					previous = current
					k += d + 1
				} while(k < baseSet.length)

				current.next = createContribution(type, type.pD, i + 1)
				if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
				if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
				i += baseStep
			}
			const result = [conts, createLookupPairs(type.lookup, conts)]
			type.base = undefined
			type.lookup = undefined
			return result
		}

		let temp = createContributionArray(types._3D)
		const contributions3D = temp[0], lookup3D = temp[1]
		const perm = new Uint8Array(256)
		const perm3D = new Uint8Array(256)
		const source = new Uint8Array(setOf(256))
		var seed = shuffleSeed(clientSeed, 3)
		doFor(256, function(i) {
			i = 255 - i
			seed = shuffleSeed(seed, 1)
			var r = (seed + 31) % (i + 1)
			r += r < 0 ? i + 1 : 0
			perm[i] = source[r]
			perm3D[i] = (perm[i] % 24) * 3
			source[r] = source[i]
		})
		base3D = undefined
		lookupPairs3D = undefined
		p3D = undefined

		return function(x, y, z) {
			const pD = perm3D
			const p = perm
			const g = gradients3D
			const stretchOffset = (x + y + z) * STRETCH_3D
			const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
			const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
			const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
			const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
			const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
			const inSum = xins + yins + zins
			var c = lookup3D.get(
				(yins - zins + 1) |
				((xins - yins + 1) << 1) |
				((xins - zins + 1) << 2) |
				(inSum << 3) |
				((inSum + zins) << 5) |
				((inSum + yins) << 7) |
				((inSum + xins) << 9)
			)
			var i, value = 0
			while (c !== undefined) {
				const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
				let attn = 2 - dx * dx - dy * dy - dz * dz
				if (attn > 0) {
					i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
					attn *= attn
					value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
				}
				c = c.next
			}
			return value * NORM_3D + 0.5
		}
	}
  
  //copied from https://gist.github.com/bzdgn/d722c961f45d97ea8efc6cef3aa39e76
  function nodeRotationX(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var y = node.y;
				var z = node.z;
				
				node.y = y * cosTheta - z * sinTheta;
				node.z = y * sinTheta + z * cosTheta;
	}
  function nodeRotationY(node, theta) {
				var cosTheta = Math.cos(theta);
				var sinTheta = Math.sin(theta);
				
				var x = node.x;
				var z = node.z;
				
				node.x = x * cosTheta - z * sinTheta;
				node.z = x * sinTheta + z * cosTheta;
	}
  var node = {x:0, y:0, z:0}
  function getRotation(rotX, rotY){
    //node.x = -sin(rotY) * cos(rotX)
    //node.y = sin(rotX)
    //node.z = cos(rotY) * cos(rotX)
    node.x = 0;node.y=0;node.z=1
    nodeRotationX(node,rotX+Math.PI)
    node.z = -node.z
    nodeRotationY(node,rotY)
    
    return node
  }
  win.getRotation = getRotation

	class PVector {
		constructor(x, y, z) {
			this.x = x
			this.y = y
			this.z = z
		}
		set(x, y, z) {
			if (y === undefined) {
				this.x = x.x
				this.y = x.y
				this.z = x.z
			} else {
				this.x = x
				this.y = y
				this.z = z
			}
		}
		normalize() {
			let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			this.x /= mag
			this.y /= mag
			this.z /= mag
		}
		add(v) {
			this.x += v.x
			this.y += v.y
			this.z += v.z
		}
		mult(m) {
			this.x *= m
			this.y *= m
			this.z *= m
		}
	}
	let fill = function(r, g, b, a) {
		if (g === undefined) {
			g = r
			b = r
		}
    a = a || a === 0 ? a : 100
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ", "+a+"%)"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1)
		ctx.lineTo(x2, y2)
	}
  let ellipse = function(x,y,w,h){
	    if(ctx.ellipse){
	        ctx.ellipse(x,y,w,h,0, 0,Math.PI*2)
	    }
	}
	function text(txt, x, y, h) {
		h = h || 0

		let lines = txt.split("\n")
		for (let i = 0; i < lines.length; i++) {
      if(lines[i].includes("§")){
        let middle = ctx.measureText(lines[i].replace(/§./g, "")).width
        let m2 = middle / 2
        let codes = lines[i].split("§")
        ctx.fillText(codes[0], x-m2, y + h * i)
        let tx = ctx.measureText(codes[0]).width
        for(var j=1; j<codes.length; j++){
          let str = codes[j]
          ctx.fillStyle = colors[str.substring(0,1)]
          str = str.substring(1)
          ctx.fillText(str, x+tx-m2, y+h*i)
          tx += ctx.measureText(str).width
        }
      }else{
        ctx.fillText(lines[i], x, y + h * i)
      }
		}
	}
	function textSize(size) {
		ctx.font = size + 'px VT323' // VT323
	}
	let strokeWeight = function(num) {
		ctx.lineWidth = num
	}
  function map(v, min, max, min2, max2){
    return min2 + (max2 - min2) * ((v - min) / (max - min));
  }
  function dist2(x,y,x2,y2){
    let xDist = x - x2
    let yDist = y - y2
    return sqrt((xDist*xDist)+(yDist*yDist))
  }
  function dist3(x,y,z,x2,y2,z2){
    let xDist = x - x2
    let yDist = y - y2
    let zDist = z - z2
    return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
  }
  win.dist2 = dist2; win.dist3 = dist3
	const ARROW = "arrow"
	const HAND = "pointer"
	let cursor = function(type) {
		canvas.style.cursor = type
	}
	randomSeed(Math.random() * 10000000 | 0)

	async function createDatabase() {
		return await new Promise(async (resolve, reject) => {
			let request = window.indexedDB.open("MineKhan", 1)

			request.onupgradeneeded = function(event) {
				let DB = event.target.result
				// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
				// and a "data" string that's identical to the copy/paste save string
				let store = DB.createObjectStore("worlds", { keyPath: "id" })
				store.createIndex("id", "id", { unique: true })
				store.createIndex("data", "data", { unique: false })
			}

			request.onsuccess = function(e) {
				resolve(request.result)
			}

			request.onerror = function(e) {
				console.error(e)
				reject(e)
			}
		})
	}
	async function loadFromDB(id) {
		return await new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = id ? store.get(id) : store.getAll()
			req.onsuccess = function(e) {
				resolve(req.result)
				db.close()
			}
			req.onerror = function(e) { 
				resolve(null)
				db.close()
			}
		})
	}
	async function saveToDB(id, data) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.put({ id: id, data: data })
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}
	async function deleteFromDB(id) {
		return new Promise(async (resolve, reject) => {
			let db = await createDatabase()
			let trans = db.transaction("worlds", "readwrite")
			let store = trans.objectStore("worlds")
			let req = store.delete(id)
			req.onsuccess = function() {
				resolve(req.result)
			}
			req.onerror = function(e) {
				reject(e)
			}
		})
	}

	function save() {
    world = dimensions.overworld
		saveToDB(world.id, {
			id: world.id,
			edited: Date.now(),
			name: world.name,
			version: version,
			code: world.getSaveString(),
      nether: world.getNetherSaveString(),
      inv: world.getInv(),
      surviv: world.getSurvivStr(),
      mod: world.mod
		}).then(() => world.edited = Date.now()).catch(e => console.error(e))
	}
  win.save = save

	// Expose these functions to the global scope for debugging
	win.saveToDB = saveToDB
	win.loadFromDB = loadFromDB
	win.createDatabase = createDatabase
	win.deleteFromDB = deleteFromDB

	//globals
	//{
	let version = "Alpha 1.0.3"
  doc.title = "MineKhan "+version
  let normReach = 5
  let bigReach = 40
  let playerDead = false;
  let reach = normReach // Max distance player can place or break blocks
	let sky = [/*0.33, 0.54, 0.72, <originl sky>*/  0.6, 0.8, 0.9] // 0 to 1 RGB color scale
  function changeSky(type){
    if(type === "nether"){
      sky = [0,0,0]
    }else{
      sky = [0.6, 0.8, 0.9]
    }
  }
  let soundOn = true
	let superflat = false
	let trees = true
	let caves = true
  win.survival = false;
  let dieMessage = ""

	let blockIds = {}
	blockData.forEach(block => blockIds[block.name] = block.id)
	win.blockData = blockData
	win.blockIds = blockIds
  
  //fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
  let arr = []
  for(let i in crafts){
    arr = i.split(",")
    for(let j = 0; j<9; j++){
      if(arr[j]){
        arr[j] = blockIds[arr[j]]
      }else{
        arr.push(0)
      }
    }
    crafts[i].id = blockIds[crafts[i].name]
    if(crafts[i].amount === undefined) crafts[i].amount = 1
    crafts[arr.join(",")] = crafts[i]
    
    delete crafts[i]
  }
  window.crafts = crafts

	let currentFov

	// Configurable and savable settings
	let settings = {
		renderDistance: 4,
		fov: 70, // Field of view in degrees
		mouseSense: 100, // Mouse sensitivity as a percentage
    soundVolume: 100, //Volume as a percentage
	}
	let locked = true
	let generatedChunks
	let mouseX, mouseY, mouseDown
	let width = window.innerWidth
	let height = window.innerHeight
  
  let colors = {
    0: "#000",
    1: "#00a",
    2: "#0a0",
    3: "#0aa",
    4: "#aa0",
    5: "#a0a",
    6: "#fa0",
    7: "#aaa",
    8: "#555",
    9: "#55f",
    a: "#5f5",
    b: "#5ff",
    c: "#f55",
    d: "#f5f",
    e: "#ff5",
    f: "#fff",
    g: "#DDD605",//minecoin gold
  }

	if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")

	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00, // Redefined right above where it's used
    biomeSmooth: 0.007, // Smoothness of biomes
	}
	let maxHeight = 255
	let blockOutlines = false
	let blockFill = true
	let updateHUD = true
  
  let images = {
    deadHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==",
    heart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=",
    halfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC",
    whiteHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARUlEQVQoU61QQQ4AIAiK/z+aBsuNbN7ykKQEJtYJkhQEgMSu6VBRzQn7VRFKNbP7/0h9jscqZ+m2efePcg21ghS4SJP1BvDiR/68vCmnAAAAAElFTkSuQmCC",
    witherHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJ1BMVEUAAAAAAAA7ExPLy8srKysvDw8nJycdHR0qDg4gICA5HBxHHBz///8BX2maAAAAAXRSTlMAQObYZgAAAAFiS0dEDIGzUWMAAAAHdElNRQfkCBcNAScIdsCqAAAAAW9yTlQBz6J3mgAAADpJREFUCNdjYBBkFGBgYFQSUmRgEDJRcRJgEHVxcxdgkJjmMkuAgbHTcyEDA4PEbKAaBsaNDCAAZAIArksGwN+RpQkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTM6MDE6MzkrMDA6MDAs2fv0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDEzOjAxOjM5KzAwOjAwXYRDSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MTg3Njk53UrJaAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTA3NzIwNzAyOTQ0NjEzMTIwMzcf2rzMAAAAAElFTkSuQmCC",
    witherHalfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAlElEQVQoU2NkQID/UCYjAwMDMpsBJAAC/y24ucGME1+/MoiLi4PZL1++BFGMYF0gBVMOHmSIjo5mEHzyhOE+Dw/cfJBCsCJtNjaGP4qKcIkPHz5gKlJlY2P4KiLCwMHBwcDKysqATRHYTTCFvLy8cEXIboIZDVf49+9fuKPBLkcKArCJrqKiDLtfv0aRQ1cEVoiuGQBusjgHiQpSWAAAAABJRU5ErkJggg==",
    bubble: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEUAAAAAAAAAlP/R6/9WuP////8DieLBAAAAAXRSTlMAQObYZgAAAAFiS0dEBfhv6ccAAAAHdElNRQflBhwAOQFmUYA6AAAAAW9yTlQBz6J3mgAAAC9JREFUCNdjYGAUZAACISUBBgZGBQZFIJPZgEUASDKASAYQCRR3BKoRcQGqAasHADZEAh1qmnpBAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA2LTI4VDAwOjU1OjAxKzAwOjAwEE5qGwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNi0yOFQwMDo1NTowMSswMDowMGET0qcAAAAASUVORK5CYII=",
    bubblePop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADFBMVEUAAAAAlP8AAAD///8Mq+G/AAAAAXRSTlMAQObYZgAAAAFiS0dEAxEMTPIAAAAHdElNRQflBhwBAwbcXqHXAAAAAW9yTlQBz6J3mgAAACVJREFUCNdjYHBgYHBwZGCY0MbAoMDBAAYOjA4MLUwNDBIsYDEAStwDy/jv20gAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDYtMjhUMDE6MDM6MDYrMDA6MDB0NlEVAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA2LTI4VDAxOjAzOjA2KzAwOjAwBWvpqQAAAABJRU5ErkJggg==",
  }
  for(var i in images){
    var url = images[i]
    images[i] = new Image()
    images[i].src = url
  }
  win.images = images
  let audioCtx
  
	let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
      CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,WALL,
      WALLU,//wall withe exteion under another wall
      FENCQ,//fence (one extension)
      BUTTON,CHAIN,POT,POTCROSS,CARPET,
	    FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
  let isCube
  var prevConstVersion = null
  
  var curConst = 0
  function nextConst(rotate, flip){
    var n = 1
    if(rotate) n = 4
    if(flip) n = 8
    var p=curConst
    curConst += n*500
    return p
  }
  function verMoreThan(a,b){
    a = a.split(".")
    b = b.split(".")
    if(a[0] > b[0]) return true
    if(a[1] > b[1]) return true
    if(a[2] > b[2]) return true
  }
  function constVersion(v){
    if(v === prevConstVersion) return
    prevConstVersion = v
    isCube = 0xff
    var verNum = v.replace(/Alpha /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
    if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
SLAB = 0x100<<5 // 9th bit
STAIR = 0x200<<5 // 10th bit
CROSS = 0x300<<5
TALLCROSS = 0x700<<5
LANTERN = 0x900<<5
LANTERNHANG=0x1100<<5
BEACON = 0x1300<<5
CACTUS = 0x1400<<5
POT = 0x1500<<5
POTCROSS = 0x1700<<5
TORCH = 0x1800<<5
CHAIN = 0x1900<<5
DOOR = 0x2100<<5
PORTAL = 0x2200<<5
WALLFLAT = 0x2300<<5
PANE = 0x4400<<5
TRAPDOOR = 0x2800<<5
TRAPDOOROPEN=0x4000<<5
FENCE = 0x6000<<5
WALLPOST = 0x6200<<5
WALL = 0x6400<<5
WALLU = 0x6600<<5 //wall withe exteion under another wall
FENCQ = 0x4100<<5 //fence (one extension)
BUTTON = 0x4200<<5
CARPET    = 0x4300<<5
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
isCube = 0xff*2
    }else if(verNum >= 1){
CUBE = 0
SLAB = 0x100 // 9th bit
STAIR = 0x200 // 10th bit
CROSS = 0x300
FLIP = 0x400 // 11th bit
TALLCROSS = 0x700
LANTERN = 0x900
LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
TORCH = 0x1800
CHAIN = 0x1900
DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
WALL = 0x6400
WALLU = 0x6600 //wall withe exteion under another wall
FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
    }else{
      CUBE      = 0
      SLAB      = 0x100 // 9th bit
      STAIR     = 0x200 // 10th bit
      CROSS     = 0x2000
      TALLCROSS = 0x2200
      DOOR      = 0x2400
      TORCH     = 0x2600
      LANTERN   = 0x2800
      LANTERNHANG=0x3000
      BEACON    = 0x4200
      CACTUS    = 0x4400
      PANE      = 0x4600
      PORTAL    = 0x5000
      WALLFLAT  = 0x4800
      TRAPDOOR  = 0x5200
      TRAPDOOROPEN=0x5400
      FENCE     = 0x6000
      WALLPOST  = 0x6200
      WALL      = 0x6400
      WALLU     = 0x6600 //wall withe exteion under another wall
      FENCQ     = 0x6800 //fence (one extension)
      BUTTON    = 0x7000
      CHAIN     = 0x7200
      POT       = 0x8000
      POTCROSS  = 0x8200
      CARPET    = 0x8400
      FLIP      = 0x400 // 11th bit
      NORTH     = 0 // 12th and 13th bits for the 4 directions
      SOUTH     = 0x800
      EAST      = 0x1000
      WEST      = 0x1800
      ROTATION  = 0x1800 // Mask for the direction bits
    }
    initBlockData()
    genIcons()
  }
	let blockMode   = CUBE
	let tex
	let textureAtlas
	let textureMap
	let dirtBuffer, netherBuffer
	let dirtTexture, netherTexture
	let textureCoords
	let texCoordsBuffers
	let mainbg, dirtbg, netherbg // Background images
	let bigArray = win.bigArray || new Float32Array(600000)
	win.bigArray = bigArray

	// Callback functions for all the screens; will define them further down the page
	let drawScreens = {
		"main menu": () => {},
		"options": () => {},
		"play": () => {},
		"pause": () => {},
		"creation menu": () => {},
		"inventory": () => {},
		"multiplayer menu": () => {},
		"comingsoon menu": () => {},
		"loadsave menu": () => {},
    "marketplace": () => {},
	}
	let html = {
		pause: {
			enter: [window.message],
			exit: [window.savebox, window.saveDirections, window.message]
		},
		"loadsave menu": {
			enter: [window.worlds, window.boxCenterTop, window.quota],
			exit: [window.worlds, window.boxCenterTop, window.quota],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter Save String (Optional)"
				if (navigator && navigator.storage && navigator.storage.estimate) {
					navigator.storage.estimate().then(data => {
						window.quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
					}).catch(console.error)
				}
				window.boxCenterTop.onmousedown = e => {
					let elem = document.getElementsByClassName("selected")
					if (elem && elem[0]) {
						elem[0].classList.remove("selected")
					}
					selectedWorld = 0
					Button.draw()
				}
			},
			onexit: () => {
				window.boxCenterTop.onmousedown = null
			}
		},
    "multiplayer menu": {
			enter: [window.servers],
			exit: [window.servers],
      onenter: initServersMenu
		},
		"creation menu": {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
		loading: {
			onenter: () => {
        startLoad()
        constVersion(world.version || version)
      }
		},
    netherLoading: {
			onenter: startLoad
		},
		editworld: {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
    marketplace: {
      enter: [window.marketplace],
      exit: [window.marketplace]
    },
    play: {
      enter: [window.messageHolder, window.onscreenControl_Element],
      exit: [window.messageHolder, window.onscreenControl_Element],
      onexit: () => Messages.clear()
    }
	}

	let screen = "main menu"
	let previousScreen = screen
	function changeScene(newScene) {
		if (screen === "options") {
			saveToDB("settings", settings).catch(e => console.error(e))
		}

		if (html[screen] && html[screen].exit) {
			for (let element of html[screen].exit) {
				element.classList.add("hidden")
			}
		}

		if (html[newScene] && html[newScene].enter) {
			for (let element of html[newScene].enter) {
				element.classList.remove("hidden")
			}
		}

		if (html[newScene] && html[newScene].onenter) {
			html[newScene].onenter()
		}
		if (html[screen] && html[screen].onexit) {
			html[screen].onexit()
		}

		previousScreen = screen
		screen = newScene
		mouseDown = false
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
    
    if(newScene === "main menu" || newScene === "play" || newScene === "paused" || newScene === "inventory" || newScene === "options"){
      themeColor.content = "#fff"
    }else{
      themeColor.content = "#110"
    }
	}
	let hitBox = {}
	let holding = 0
  let crack = {
    0: "crack1",
    1: "crack2",
    2: "crack3",
    3: "crack4",
    4: "crack5",
    5: "crack6",
    6: "crack7",
    7: "crack8",
    8: "crack9",
    9: "crack10",
    10: "crack10",
    length: 10,
    idx: 0, // block will break if idx is 4
    tex: "crack1",
    shape: null,
    pos: [0,0,0],
    prevPos: [-1,-1,-1],
    breakStart: 0,
    delayBetween:60*3/10,
    delayDone:0,
    entity: null, //define later
    soundTimer: 0
  }
  win.crack = crack
  {
    //command system
    var copiedBlocks = [];
    var prevPos;
    function fill(x,y,z,x2,y2,z2, blockID){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            world.setBlock(X,Y,Z,blockID)
          }
        }
      }
    }
    function copy(x,y,z,x2,y2,z2){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}

      copiedBlocks = [];
      for(var X=x; x2>=X; X++){
        var xRow = [];
        for(var Y=y; y2>=Y; Y++){
          var yRow = []
          for(var Z=z; z2>=Z; Z++){
            yRow.push(world.getBlock(X,Y,Z));
          }
          xRow.push(yRow);
        }
        copiedBlocks.push(xRow);
      }
    }
    function paste(x,y,z){
      for(var X = 0; X<copiedBlocks.length; X++){
        var xRow = copiedBlocks[X];
        for(var Y=0; Y<xRow.length; Y++){
          var yRow = xRow[Y];
          for(var Z=0; Z<yRow.length; Z++){
            var block = yRow[Z];
            world.setBlock(X+x,Y+y,Z+z,block)
          }
        }
      }
    }
    function replaceBlocks(x,y,z,x2,y2,z2, replace, into){
      if(x>x2){var px=x; x=x2; x2=px}
      if(y>y2){var py=y; y=y2; y2=py}
      if(z>z2){var pz=z; z=z2; z2=pz}
      for(var X=x; x2>=X; X++){
        for(var Y=y; y2>=Y; Y++){
          for(var Z=z; z2>=Z; Z++){
            if(world.getBlock(X,Y,Z) === replace){
              world.setBlock(X,Y,Z,into)
            }
          }
        }
      }
    }

    function fromPlayer(){
      prevPos = [p2.x, p2.y, p2.z]
    }
    function fillToPlayer(id){
      //fills at player feet
      fill(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, id)
    }

    function copyToPlayer(){
      copy(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z);
    }
    function pasteAtPlayer(){
      paste(p2.x,p2.y-1,p2.z)
    }

    function hcyl(bottom, height, radius, id) {
        let radsq = radius * radius
        let innerRadsq = (radius - 1.2) * (radius - 1.2)
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq && d >= innerRadsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function cyl(bottom, height, radius, id) {
        let radsq = radius * radius
        height += bottom
        for (let x = -radius; x <= radius; x++) {
            for (let y = bottom; y < height; y++) {
                for (let z = -radius; z <= radius; z++) {
                    let d = x * x + z * z
                    if (d < radsq) {
                        world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                    }
                }
            }
        }
    }

    function sphereoid(w, h, d, id, X,Y,Z) {
        let w2 = w * w
        let h2 = h * h
        let d2 = d * d
        let w3 = (w - 1.5) * (w - 1.5)
        let h3 = (h - 1.5) * (h - 1.5)
        let d3 = (d - 1.5) * (d - 1.5)

        for (let y = -h; y < h; y++) {
            for (let x = -w; x <= w; x++) {
                for (let z = -d; z <= d; z++) {
                    let n = x * x / w2 + y * y / h2 + z * z / d2
                    let n2 = x * x / w3 + y * y / h3 + z * z / d3
                    if (n < 1 && n2 >= 1) {
                        world.setBlock(X + x, Y + y, Z + z, id)
                    }
                }
            }
        }
    }
    var cmds = [
      {
        name: "fromPlayer",
        info: "Sets position 1 to player"
      },
      {
        name: "fillToPlayer",
        args: ["block_name"],
        info: "Fills from position 1 to player position"
      },
      {
        name: "copyToPlayer",
        info: "Copys blocks from position 1 to player position"
      },
      {
        name: "pasteAtPlayer",
        info: "Pastes copied blocks at the player's position"
      },
      {
        name: "sphereoid",
        args: ["width", "height", "depth", "block_name", "x", "y", "z"]
      },
      {
        name: "replaceToPlayer",
        args: ["replace_what", "with_what"]
      },
      {
        name: "give",
        args: ["block_name", "amount"],
        info: "Gives you the the specified amount of specified blocks"
      },
      /*{
        name: "kill",
        args: ["selector"],
        info: "Kills someone. Selectors: @s, your username"
      },*/
      {
        name: "ban",
        args: ["username"],
        info: "Bans a player. They cannot rejoin the world. Only bans them until multiplayer turns off"
      }
    ]
    function getCmd(name){
      for(var i=0; i<cmds.length; i++){
        if(cmds[i].name === name){
          return cmds[i]
        }
      }
    }
    
    function runCmd(str){
      str = str.replace("/", '')
      let split = str.split(" ")
      let name = split[0]
      if(name === "?"){
        if(split[1]){
          var cmd = getCmd(split[1])
          if(cmd){
            var str = "<b>/"+split[1]+"</b><br>"
            str += "Syntax: /"+cmd.name+" "
            if(cmd.args) str += cmd.args.join(" ")
            str += "<br>"
            if(cmd.info) str += "Description: "+cmd.info
            Messages.add(str)
          }else Messages.add("There is no information for /"+split[1])
        }else{
          var str = "List of commands:<br>"
          str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
          cmds.forEach(r => {
            str += "<span style='color:lightblue;'>/"+r.name+"</span> "
            if(r.args) str += r.args.join(" ")
            str += "<br>"
          })
          Messages.add(str)
        }
      }else if(name === "fromPlayer"){
        fromPlayer()
      }else if(name === "fillToPlayer"){ //args: <block name>
        let id = blockIds[split[1]]
        if(!split[1]) id = 0
        fillToPlayer(id)
      }else if(name === "copyToPlayer"){
        copyToPlayer()
      }else if(name === "pasteAtPlayer"){
        pasteAtPlayer()
      }else if(name === "sphereoid"){ //args: width, height, depth, <block name>, x,y,z
        let id = blockIds[split[4]]
        if(!split[4]) id = 0
        let x = split[5] ? parseInt(split[5]) : p2.x,
            y = split[6] ? parseInt(split[6]) : p2.y,
            z = split[7] ? parseInt(split[7]) : p2.z
        sphereoid(split[1], split[2], split[3], id, x,y,z)
      }else if(name === "replaceToPlayer"){
        let replace = blockIds[split[1]]
        if(!split[1]) replace = 0
        let into = blockIds[split[2]]
        if(!split[2]) into = 0
        replaceBlocks(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, replace, into)
      }else if(name === "give"){
        let id = blockIds[split[1]]
        if(id){
          if(split[2] && split[2] > 1){
            for(var i=0; i<split[2]; i++){
              newInvItem(id)
            }
          }else newInvItem(id)
        }
      }else if(name === "kill"){
        if(split[1] === "@s" || split[1] === username){
          dieMessage = split[2] || (username+" killed themself with the kill command. Why would you do that???")
          die()
        }else if(split[1] === "@a" || hasPlayer(split[1])){
          send({type:"kill", data:split[1]})
        }else{
          Messages.add("Can't select with selector "+split[1])
        }
      }else if(name === "ban"){
        if(win.ban){
          ban(split[1])
        }else{
          Messages.add("Error: can't ban.")
        }
      }else{
        Messages.add("Error: no such command called "+name)
      }
    }
    win.runCmd = runCmd
  }
  let Messages = {
    array: [],
    update:function(){
      if(this.array.length === 0){
        messages.innerHTML = ""
      }else messages.innerHTML = this.array.join("<br>")
    },
    clear: function(){this.array = [];this.update()},
    add: function(msg){
      this.array.push(msg)
      if(this.array.length > 5){
        this.array.shift()
      }
      this.update()
    },
    write: function(msg, from){
      this.add((from || username)+": "+msg)
      if(!from && multiplayer){
        send({type:"message", data:msg, username:username})
      }
    },
    showInput(){
      messageInput.classList.remove("hidden")
      messageInput.focus()
      messageInput.onkeypress = (e) => {
        if(e.key !== "Enter") return
        if(messageInput.value[0] === "/"){
          if(survival){
            Messages.add("<span style='color:red;'>Commands unavailable</span>")
          }else runCmd(messageInput.value)
        }else{
          Messages.write(messageInput.value)
        }
        messageInput.classList.add("hidden")
        messageInput.value = ""
        canvas.focus()
      }
    }
  }
  window.Messages = Messages
  let title = ""
  let subtitle = ""
  let titleOpacity = 0
  let titleColor = "black"
  function showTitle(aTitle, aSubtitle, color){
    title = aTitle
    subtitle = aSubtitle
    titleOpacity = 140
    titleColor = color || "white"
  }
  win.showTitle = showTitle
  function die(){
    playerDead = true
    changeScene("dead")
    releasePointer()
  }
	let Key = {}
	let modelView = win.modelView || new Float32Array(16)
	win.modelView = modelView
	let glCache
	let worlds, selectedWorld = 0
	let freezeFrame = 0
	let p
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector()
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	}
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	}
  let p3 = { //precise positions for multiplayer
    x: 0,
    y: 0,
    z: 0,
    survival: false,
    username: ""
  }
	let place
  let liquid = false
  let standingOn = 0 //block id you are standing on
  let lastLiquid = false
  let harmEffect = 0
  let healTime = 5000 // miliseconds between each heal
  let healEffect = 0 // health bar outline flash white
  let lastHeal = 0
  let lastBlockHarm = 0
  let lastLoseOxygen = 0
  let lastGetOxygen = 0
  let witherEffect = 0
  let witherDamage = 0
  let witherTime = 0
  let portalEffect = 0
  win.lastStepSound = 0
	let inventory = {
		hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
		main: [],
		hotbarSlot: 0,
		size: 40 * min(width, height) / 600,
		holding: 0,
    crafting: [0,0,0,0,0,0,0,0,0],
    craftingStr: "",
    craftingRes: 0, //block id
	}
  inventory.craftingStr = inventory.crafting.join(",")
  win.inventory = inventory
	//}
  for(var i=0; i<9; i++){
    inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
  }
  for(var i=0; i<9; i++){
    inventory.crafting[i] = {id:inventory.crafting[i],amount:64}
  }
  function setHotbar(arr){
    inventory.hotbar = arr
    for(var i=0; i<9; i++){
      inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
    }
  }

	function play() {
		canvas.onblur()
		p.lastBreak = Date.now()
		updateHUD = true
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		getPointer()
		fill(255, 255, 255)
		textSize(10)
		changeScene("play")
	}

	let gl
	let glExtensions
	function getPointer() {
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock()
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock()
		}
	}

	let Block = {
		top: 0x4,
		bottom: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	}
	let Sides = {
		top: 0,
		bottom: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	}

	// GLSL Shader code (written in script tags at the top of the file)
	let vertexShaderSrc3D = document.getElementById("blockVertexShader").text
	let fragmentShaderSrc3D = document.getElementById("blockFragmentShader").text
	let vertexShaderSrc2D = document.getElementById("2dVertexShader").text
	let fragmentShaderSrc2D = document.getElementById("2dFragmentShader").text
	let vertexShaderSrcEntity = document.getElementById("entityVertexShader").text
	let fragmentShaderSrcEntity = document.getElementById("entityFragmentShader").text
  let vertexShaderSrcParticle = document.getElementById("particleVertexShader").text
	let fragmentShaderSrcParticle = document.getElementById("particleFragmentShader").text

	function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
		curContext.shaderSource(vertexShaderObject, vetexShaderSource)
		curContext.compileShader(vertexShaderObject)
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject)
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
		curContext.compileShader(fragmentShaderObject)
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject)
		}

		let programObject = curContext.createProgram()
		curContext.attachShader(programObject, vertexShaderObject)
		curContext.attachShader(programObject, fragmentShaderObject)
		curContext.linkProgram(programObject)
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw "Error linking shaders."
		}

		return programObject
	}

	let program3D, program2D, programEntity, programParticle

	function objectify(x, y, z, width, height, textureX, textureY, texXFlip) {
		return {
			x: x,
			y: y,
			z: z,
			w: width,
			h: height,
			tx: textureX,
			ty: textureY,
      txf: texXFlip
		}
	}
  function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty){
	    return {
	        x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,
	        custom:true
	    }
	}
  function generateItemShape(){
    var arr = []
    var bottom = [],
        top = [],
        east = [],
        west = []
    var i
    for(i=0; i<16; i++){
      bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
      top.push(objectify(0,i,8.5,16,1,0,16-i))
      east.push(objectify(i,16,7.5,1,16,16-i,0))
      west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
    }
    return [bottom,top,
            [objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
           east,west]
  }
	let shapes = {
		/*
			[
				[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
				[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
				[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
				[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
				[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
				[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
			]
			*/
		cube: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    rotate: {
			verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
				[objectify(16, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      rotate: true
		},
    _1PixLower:{
      verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
				[objectify(16, 15, 16, 16, 15, 0, 0)], //north
				[objectify( 0, 15,  0, 16, 15, 0, 0)], //south
				[objectify(16, 15,  0, 16, 15, 0, 0)], //east
				[objectify( 0, 15, 16, 16, 15, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
		slab: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
				[objectify(16, 8, 16, 16, 8, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
				[objectify(16, 8,  0, 16, 8, 0, 0)], //east
				[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: false
		},
		stair: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
				[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
				[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 10,
			varients: [],
			flip: true,
			rotate: true
		},
    cross: {
			verts: [
				[objectify(8, 0, 8, 1, 1, 0, 0)], //bottom
				[objectify(8, 16, 8, 1, 1, 0, 0)], //top
				[customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 0,0)], //north
				[customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 0,0)], //south
				[customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 0,0)], //east
				[customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 0,0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube"
		},
    tallCross: {
      verts: [
				[objectify( 0,  0,  0, 0, 0, 0, 0)], //bottom
				[objectify( 0, 16, 16, 0, 0, 0, 0), objectify( 0, 32, 16, 0, 0, -16, 0)], //top
				[objectify(16, 16, 8, 16, 16, 16, 0), objectify(16, 32, 8, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  8, 16, 16, 16, 0), objectify( 0, 32,  8, 16, 16, 0, 0)], //south
				[objectify(8, 16,  0, 16, 16, 16, 0), objectify(8, 32,  0, 16, 16, 0, 0)], //east
				[objectify( 8, 16, 16, 16, 16, 16, 0), objectify( 8, 32, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    door: {
			verts: [
				[objectify( 0,  0,  0, 16, 3, 0, 0)], //bottom
				[objectify( 0, 16, 3, 16, 3, 0, 0),objectify( 0, 32, 3, 16, 3, -16, 0)], //top
				[objectify(16, 16, 3, 16, 16, 0, 0),objectify(16, 32, 3, 16, 16, -16, 0)], //north
				[objectify( 0, 16,  0, 16, 16, 0, 0),objectify( 0, 32,  0, 16, 16, -16, 0)], //south
				[objectify(16, 16,  0, 3, 16, 0, 0),objectify(16, 32,  0, 3, 16, -16, 0)], //east
				[objectify( 0, 16, 3, 3, 16, 0, 0),objectify( 0, 32, 3, 3, 16, -16, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    torch: {
			verts: [
				[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
				[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
				[objectify(9, 10, 9, 2, 10, 7, 6)], //north
				[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
				[objectify(9, 10,  7, 2, 10, 7, 6)], //east
				[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    lantern: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    lanternHang: {
			verts: [
				[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
				[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
				[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
				[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
				[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
				[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    beacon: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 16, -96),objectify( 2, 0.001, 2, 12, 12, -32, 0)], //bottom
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify( 2, 3, 14, 12, 12, -16, 3)], //top
				[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, -32, 0),objectify(14, 3, 14, 12, 3,  -16, 3)], //north
				[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, -32, 0),objectify(2,  3, 2,  12, 3,  -16, 3)], //south
				[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, -32, 0),objectify(14, 3, 2,  12, 3,  -16, 3)], //east
				[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify(2,  3, 14, 12, 3,  -16, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    cactus: {
			verts: [
				[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
				[objectify(16, 16, 15, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
				[objectify(15, 16,  0, 16, 16, 0, 0)], //east
				[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
      hitbox: "cube"
		},
    pane: {
			verts: [
				[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
				[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
				[objectify(16, 16, 9, 16, 16, 0, 0)], //north
				[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
				[objectify(16, 16, 7, 2, 16, 7, 0)], //east
				[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    portal: {
			verts: [
				[objectify(0, 0, 7, 16, 2, 0, 0)],
				[objectify(0, 16, 9, 16, 2, 0, 0)],
				[objectify(16, 16, 9, 16, 16, 0, 0)],
				[objectify(0, 16, 7, 16, 16, 0, 0)],
				[objectify(16, 16, 7, 2, 16, 0, 0)],
				[objectify(0, 16, 9, 2, 16, 0, 0)]
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    trapdoor: {
			verts: [
				[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
				[objectify(0, 3, 16, 16, 16, 0, 0)], //top
				[objectify(16, 3, 16, 16, 3, 0, 0)], //north
				[objectify(0, 3, 0, 16, 3, 0, 0)], //south
				[objectify(16, 3, 0, 16, 3, 0, 0)], //east
				[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true,
			flip: true
		},
		trapdoorOpen: {
			verts: [
				[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
				[objectify(0, 16, 16, 16, 3, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16, 13, 16, 16, 0, 0)], //south
				[objectify(16, 16, 13, 3, 16, 0, 0)], //east
				[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    wallFlat: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
				[objectify(0, 16, 16, 0, 0, 0, 0)], //top
				[objectify(16, 16, 16, 16, 16, 0, 0)], //north
				[objectify(0, 16,  15, 16, 16, 0, 0)], //south
				[objectify(0, 0,  0, 0, 0, 0, 0)], //east
				[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fence: {
			verts: [
				[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
		wallpost: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
		wall: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
		wallu: {
			verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
				[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
				[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
				[objectify(4, 16, 4, 8, 16, 4, 0)], //south
				[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
				[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
    fencq: {
			verts: [
				[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
				[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
				[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
				[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
				[objectify(10, 16, 6, 4, 16, 6, 0)], //east
				[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
			rotate: true
		},
		button: {
			verts: [
				[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
				[objectify(5, 10, 16, 6, 2, 5, 6)], //top
				[objectify(11, 10, 16, 6, 4, 5, 6)], //north
				[objectify(5, 10, 14, 6, 4, 5, 6)], //south
				[objectify(11, 10, 14, 2, 4, 5, 6)], //east
				[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
			flip: true,
			rotate: true
		},
    chain: {
			verts: [
				[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
				[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
				[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
				[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
				[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
				[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    pot: {
			verts: [
				[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
				[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
				[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
				[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
				[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
				[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    potCross: {
			verts: [
				[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
				[objectify(0, 16, 16, 0, 0, 0, 0)], //top
				[objectify(16, 4, 8, 16, 16, 0, 0)], //north
				[objectify(0, 4, 8, 16, 16, 0, 0)], //south
				[objectify(8, 4, 0, 16, 16, 0, 0)], //east
				[objectify(8, 4, 16, 16, 16, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6,
		},
    carpet: {
			verts: [
				[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
				[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
				[objectify(16, 1, 16, 16, 1, 0, 0)], //north
				[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
				[objectify(16, 1,  0, 16, 1, 0, 0)], //east
				[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 1,
				south: 1,
				east: 1,
				west: 1
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    bed: {
			verts: [
				[objectify( 0, 3,  0, 16, 16, -16, 0),objectify( 0, 3,  16, 16, 16, -16, 0),
				objectify(0, 0, 0, 3,3,  38,0),
				objectify(13, 0, 29, 3,3,38,0),
				objectify(0, 0, 29, 3,3, 38,0),
				objectify(13, 0, 0, 3,3, 38,0)], //bottom
				[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
				[objectify(16, 9, 32, 16, 6, 80, 6),
				objectify(3, 3, 3, 3,3,  38,3),
				objectify(16, 3, 32, 3,3,32,3),
				objectify(3, 3, 32, 3,3, 35,3),
				objectify(16, 3, 3, 3,3, 41,3)], //north
				[objectify( 0, 9,  0, 16, 6, 80, 0),
				objectify(0, 3, 0, 3,3,  32,3),
				objectify(13, 3, 29, 3,3,38,3),
				objectify(0, 3, 29, 3,3, 41,3),
				objectify(13, 3, 0, 3,3, 35,3)], //south
				[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
				objectify(3, 3, 0, 3,3,  41,3),
				objectify(16, 3, 29, 3,3,35,3),
				objectify(3, 3, 29, 3,3, 38,3),
				objectify(16, 3, 0, 3,3, 32,3)], //east
				[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
				objectify(0, 3, 3, 3,3,  35,3),
				objectify(13, 3, 32, 3,3,41,3),
				objectify(0, 3, 32, 3,3, 32,3),
				objectify(13, 3, 3, 3,3, 38,3)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: [],
      rotate: true
		},
    cactusPot: {
      verts: [
				[], //bottom
				[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
				[objectify(10, 1, 10, 4, 11, 6, 0)], //north
				[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
				[objectify(10, 1,  6, 4, 11, 6, 0)], //east
				[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    crop: {
			verts: [
        [objectify(0,0,0,0,0,0,0)],
        [objectify(0,0,0,0,0,0,0)],
        [objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
        [objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
        [objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
        [objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
      ],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 6,
			varients: []
		},
    anvil: {
			verts: [
        [objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
        [objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,-16,3)],
        [objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
        [objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
        [objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
        [objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
      ],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			buffer: null,
			size: 21,
			varients: [],
      rotate: true
		},
    liquidSurface: {
			verts: [
				[objectify( 0,    0,  0, 16,   16, 0, 0)], //bottom
				[objectify( 0, 14.5, 16, 16,   16, 0, 0)], //top
				[objectify(16, 14.5, 16, 16, 14.5, 0, 0)], //north
				[objectify( 0, 14.5,  0, 16, 14.5, 0, 0)], //south
				[objectify(16, 14.5,  0, 16, 14.5, 0, 0)], //east
				[objectify( 0, 14.5, 16, 16, 14.5, 0, 0)]  //west
			],
			cull: {
				top: 0,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
		},
    
    playerHand: {
      verts: [
				[objectify( 6,  6,  6, 4,  4, 0, 0)], //bottom
				[objectify( 6, 18, 10, 4,  4, 0, 0)], //top
				[objectify(10, 18, 10, 4, 12, 0, 0)], //north
				[objectify( 6, 18,  6, 4, 12, 0, 0)], //south
				[objectify(10, 18,  6, 4, 12, 0, 0)], //east
				[objectify( 6, 18, 10, 4, 12, 0, 0)]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 6
    },
    item: {
      verts: generateItemShape(),
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null
    },
    cow: {
      verts: [
				// x, y, z, width, height, textureX, textureY
				// 0, 0, 0 is the corner on the top left of the texture
				[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16,  8,  4,  8,  8,  0,  0)], //bottom
				[objectify( 0, 12, 16, 16, 16, 0, 0), objectify(16, 16, 12,  8,  8,  0,  0)], //top
				[objectify(16, 12, 16, 16, 12, 0, 4), objectify(24, 16, 12,  8,  8, 16,  0)], //north
				[objectify( 0, 12,  0, 16, 12, 0, 4), objectify(16, 16,  4,  8,  8, 16,  0)], //south
				[objectify(16, 12,  0, 16, 12, 0, 4), objectify(24, 16,  4,  8,  8, 16,  0)], //east
				[objectify( 0, 12, 16, 16, 12, 0, 4), objectify(16, 16, 12,  8,  8, 16,  0)]  //west
			],
			cull: {
				top: 0,
				bottom: 0,
				north: 0,
				south: 0,
				east: 0,
				west: 0
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 12,
    },
    blockParticle: {
      verts: [
				[], //bottom
				[], //top
				[objectify( 16, 16, 8, 16, 16, 0, 0)], //north
				[objectify(  0, 16, 8, 16, 16, 0, 0)], //south
				[], //east
				[]  //west
			],
			cull: {
				top: 3,
				bottom: 3,
				north: 3,
				south: 3,
				east: 3,
				west: 3
			},
			texVerts: [],
			varients: [],
			buffer: null,
			size: 2
    },
	}
	win.shapes = shapes
  
  //automatically set size
  for(var shape in shapes){
    shape = shapes[shape]
    let v = shape.verts
    let s = v[0].length + v[1].length + v[2].length + v[3].length + v[4].length + v[5].length
    shape.size = s
    shape.texVerts = []
    shape.varients = []
    shape.buffer = null
    if(typeof shape.hitbox === "string"){
      shape.hitbox = shapes[shape.hitbox]
    }
  }

	function compareArr(arr, out) {
		let minX = 1000
		let maxX = -1000
		let minY = 1000
		let maxY = -1000
		let minZ = 1000
		let maxZ = -1000
		let num = 0
		for (let i = 0; i < arr.length; i += 3) {
			num = arr[i]
			minX = minX > num ? num : minX
			maxX = maxX < num ? num : maxX
			num = arr[i + 1]
			minY = minY > num ? num : minY
			maxY = maxY < num ? num : maxY
			num = arr[i + 2]
			minZ = minZ > num ? num : minZ
			maxZ = maxZ < num ? num : maxZ
		}
		out[0] = minX
		out[1] = minY
		out[2] = minZ
		out[3] = maxX
		out[4] = maxY
		out[5] = maxZ
		return out
	}
  function arrayValues(a1,a2){
    if(a1.length !== a2.length) return false
    let minLen = a1.length
    for(var i=0; i<minLen; i++){
      if(a1[i] !== a2[i]){
        return false
      }
    }
    return true
  }

	function initShapes() {
		function mapCoords(rect, face) {
      if(rect.custom) return mapCustomCoords(rect)
			let x = rect.x
			let y = rect.y
			let z = rect.z
			let w = rect.w
			let h = rect.h
			let tx = rect.tx
			let ty = rect.ty
			let tex = [tx+w,ty, tx,ty, tx,ty+h, tx+w,ty+h]
      if(rect.txf){
        tex[0] = tx
        tex[2] = tx+w
        tex[4] = tx+w
        tex[6] = tx
      }
			let pos = null
			switch(face) {
				case 0: // Bottom
					pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
					break
				case 1: // Top
					pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
					break
				case 2: // North
					pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
					break
				case 3: // South
					pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
					break
				case 4: // East
					pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
					break
				case 5: // West
					pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
					break
			}
			pos = pos.map(c => c / 16 - 0.5)
			let minmax = compareArr(pos, [])
			pos.max = minmax.splice(3, 3)
			pos.min = minmax
			tex = tex.map(c => c / 16 / 16)
			
			return {
				pos: pos,
				tex: tex
			}
		}
    function mapCustomCoords(coords){
      let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty} = coords
      let tex = [tx+16,ty, tx,ty, tx,ty+16, tx+16,ty+16]
      let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
      pos = pos.map(c => c / 16 - 0.5)
			let minmax = compareArr(pos, [])
			pos.max = minmax.splice(3, 3)
			pos.min = minmax
			tex = tex.map(c => c / 16 / 16)
			
			return {pos,tex}
		}
		
		// 90 degree clockwise rotation; returns a new shape object
		function rotate(shape, bit) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = face[k + 1]
						c[k + 2] = -face[k]
					}
					
					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
					if (i === 0) {
						// Bottom
						c.push(...c.splice(0, 3))
						tex[i][j].push(...tex[i][j].splice(0, 2))
					}
					if (i === 1) {
						// Top
						c.unshift(...c.splice(-3, 3))
						tex[i][j].unshift(...tex[i][j].splice(-2, 2))
					}

					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax
				}
			}
			let temp = tex[2] // North
			tex[2] = tex[5] // North = West
			tex[5] = tex[3] // West = South
			tex[3] = tex[4] // South = East
			tex[4] = temp // East = North

			temp = pos[2] // North
			pos[2] = pos[5] // North = West
			pos[5] = pos[3] // West = South
			pos[3] = pos[4] // South = East
			pos[4] = temp // East = North

			let cull2 = {
				top: cull.top,
				bottom: cull.bottom,
				north: cull.west,
				west: cull.south,
				south: cull.east,
				east: cull.north
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: true,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients,
        bit: bit
			}
		}

		// Reflect over the y plane; returns a new shape object
		function flip(shape, bit) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j].slice().reverse()
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = -face[k + 1]
						c[k + 2] = face[k]
					}
					let minmax = compareArr(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax

					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
				}
			}
			let temp = pos[0] // Bottom
			pos[0] = pos[1] // Bottom = Top
			pos[1] = temp // Top = Bottom

			temp = tex[0] // Bottom
			tex[0] = tex[1] // Bottom = Top
			tex[1] = temp // Top = Bottom

			let cull2 = {
				top: cull.bottom,
				bottom: cull.top,
				north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
				west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
				south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
				east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: shape.rotate,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients,
        bit: bit
			}
		}

		for (let shape in shapes) {
			let obj = shapes[shape]
			let verts = obj.verts
			
			// Populate the vertex coordinates
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				let texArr = []
				obj.texVerts.push(texArr)
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let mapped = mapCoords(face, i)
					side[j] = mapped.pos
					texArr.push(mapped.tex)
				}
			}

			if (obj.rotate) {
				let v = obj.varients
				let east = rotate(obj, 4<<10)
				let south = rotate(east, 2<<10)
				let west = rotate(south, 6<<10)
				v[0] = obj
				v[2] = south
				v[4] = east
				v[6] = west
			}
			if (obj.flip) {
				let v = obj.varients
				v[1] = flip(obj,1<<10)
				if (obj.rotate) {
					v[3] = flip(v[2], 3<<10)
					v[5] = flip(v[4], 5<<10)
					v[7] = flip(v[6], 7<<10)
				}
			}

			obj.buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(2)), gl.STATIC_DRAW)
		}

    win.initBlockData = function(){
		for (let i = 0; i < BLOCK_COUNT; i++) {
			let baseBlock = blockData[i]
			let slabBlock = Object.create(baseBlock)
			let stairBlock = Object.create(baseBlock)
      let crossBlock = Object.create(baseBlock)
      let tallcrossBlock = Object.create(baseBlock)
      let doorBlock = Object.create(baseBlock)
      let torchBlock = Object.create(baseBlock)
      let lanternBlock = Object.create(baseBlock)
      let lanternHangBlock = Object.create(baseBlock)
      let beaconBlock = Object.create(baseBlock)
      let cactusBlock = Object.create(baseBlock)
      let paneBlock = Object.create(baseBlock)
      let portalBlock = Object.create(baseBlock)
      let trapdoorBlock = Object.create(baseBlock)
      let openTrapdoor = Object.create(baseBlock)
      let wallFlatBlock = Object.create(baseBlock)
      let fenceBlock = Object.create(baseBlock)
			let wallPostBlock = Object.create(baseBlock)
			let wallBlock = Object.create(baseBlock)
			let walluBlock = Object.create(baseBlock)
      let fencqBlock = Object.create(baseBlock)
			let buttonBlock = Object.create(baseBlock)
      let chainBlock = Object.create(baseBlock)
      let potBlock = Object.create(baseBlock)
      let potCrossBlock = Object.create(baseBlock)
      let carpetBlock = Object.create(baseBlock)
      baseBlock.shape = shapes.cube
			slabBlock.shape = shapes.slab
      slabBlock.transparent = true
			stairBlock.shape = shapes.stair
      stairBlock.transparent = true
      crossBlock.shape = shapes.cross
      tallcrossBlock.shape = shapes.tallCross
      doorBlock.shape = shapes.door
      doorBlock.solid = false
      torchBlock.shape = shapes.torch
      lanternBlock.shape = shapes.lantern
      lanternHangBlock.shape = shapes.lanternHang
      beaconBlock.shape = shapes.beacon
      cactusBlock.shape = shapes.cactus
      paneBlock.shape = shapes.pane
      portalBlock.shape = shapes.portal
      wallFlatBlock.shape = shapes.wallFlat
      trapdoorBlock.shape = shapes.trapdoor
      openTrapdoor.shape = shapes.trapdoorOpen
      fenceBlock.shape = shapes.fence
      fenceBlock.transparent = true
      wallPostBlock.shape = shapes.wallpost
      wallPostBlock.transparent = true
			wallBlock.shape = shapes.wall
			walluBlock.shape = shapes.wallu
      fencqBlock.shape = shapes.fencq
			buttonBlock.shape = shapes.button
      chainBlock.shape = shapes.chain
      potBlock.shape = shapes.pot
      potCrossBlock.shape = shapes.potCross
      carpetBlock.shape = shapes.carpet
      carpetBlock.shadow = false
      carpetBlock.transparent = true
      if(blockData[i].bed) baseBlock.shape = shapes.bed
      if(blockData[i].rotate) baseBlock.shape = shapes.rotate
      if(blockData[i].cactus) potCrossBlock.shape = shapes.cactusPot
      if(blockData[i].crop) baseBlock.shape = shapes.crop
      if(blockData[i].anvil) baseBlock.shape = shapes.anvil
      if(blockData[i].liquid) slabBlock.shape = shapes.liquidSurface
      if(blockData[i]._1PixLower){baseBlock.shape = shapes._1PixLower; baseBlock.transparent = true}
      if(blockData[i].item) baseBlock.shape = shapes.item
			blockData[i | SLAB] = slabBlock
			blockData[i | STAIR] = stairBlock
      blockData[i | CROSS] = crossBlock
      blockData[i | TALLCROSS] = tallcrossBlock
      blockData[i | DOOR] = doorBlock
      blockData[i | TORCH] = torchBlock
      blockData[i | LANTERN] = lanternBlock
      blockData[i | LANTERNHANG] = lanternHangBlock
      if(blockData[i].beacon) blockData[i | BEACON] = beaconBlock
      if(blockData[i].cactus) blockData[i | CACTUS] = cactusBlock
      blockData[i | PANE] = paneBlock
      blockData[i | PORTAL] = portalBlock
      blockData[i | WALLFLAT] = wallFlatBlock
      blockData[i | TRAPDOOR] = trapdoorBlock
      blockData[i | TRAPDOOROPEN] = openTrapdoor
      blockData[i | FENCE] = fenceBlock
			blockData[i | WALLPOST] = wallPostBlock
			blockData[i | WALL] = wallBlock
			blockData[i | WALLU] = walluBlock
      blockData[i | FENCQ] = fencqBlock
			if(blockData[i].button) blockData[i | BUTTON] = buttonBlock
      if(blockData[i].chain) blockData[i | CHAIN] = chainBlock
      if(blockData[i].pot) blockData[i | POT] = potBlock
      blockData[i | POTCROSS] = potCrossBlock
      if(blockData[i].carpet) blockData[i | CARPET] = carpetBlock
      let v
      if(baseBlock.shape.rotate){
        v = baseBlock.shape.varients
        for (let j = 0; j < v.length; j++) {
          if (v[j]) {
            let block = Object.create(baseBlock)
            block.shape = v[j]
            blockData[i | v[j].bit] = block
          }
        }
      }
			v = slabBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | SLAB | v[j].bit] = block
				}
			}
			v = stairBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | STAIR | v[j].bit] = block
				}
			}
      v = doorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.solid = false
					blockData[i | DOOR | v[j].bit] = block
				}
			}
      v = paneBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | PANE | v[j].bit] = block
				}
			}
      v = portalBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | PORTAL | v[j].bit] = block
				}
			}
      v = wallFlatBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | WALLFLAT | v[j].bit] = block
				}
			}
      v = trapdoorBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOR | v[j].bit] = block
				}
			}
      v = openTrapdoor.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | TRAPDOOROPEN | v[j].bit] = block
				}
			}
			v = wallBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | WALL | v[j].bit] = block
				}
			}
			v = walluBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | WALLU | v[j].bit] = block
				}
			}
      v = fencqBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
          block.transparent = true
					blockData[i | FENCQ | v[j].bit] = block
				}
			}
			v = buttonBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j] && blockData[i].button) {
					let block = Object.create(baseBlock)
					block.shape = v[j]
					blockData[i | BUTTON | v[j].bit] = block
				}
			}
		}
    }
	}
    
	let indexOrder;
	(function() {
		let arr = []
		for (let i = 0; i < 100000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4)
		}
		indexOrder = new Uint32Array(arr)
	})()

	let hexagonVerts
	let slabIconVerts
	let stairIconVerts
  let _2dIconVerts
  let fenceIconVerts
	let wallPostIconVerts
	let walluIconVerts
	let wallIconVerts
  let fencqIconVerts
	let buttonIconVerts
  let carpetIconVerts
	let blockIcons
	{
		let side = Math.sqrt(3) / 2
		let s = side
		let q = s / 2
    let p = s / 16
		hexagonVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		slabIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])

		stairIconVerts = [
			-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
			-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
			-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
			0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
			-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
			-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
		]
    _2dIconVerts = [
      //-1,-1,0,0,1,          1,-1,1,0,1,        1,1,1,1,1          -1,1,0,1,1 //x, y, tx, ty, useless
      1,1,1,0,1,         1,-1,1,1,1,         -1,-1,0,1,1,    -1,1,0,0,1
    ]
    fenceIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallPostIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		
		wallIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		walluIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
    fencqIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
		buttonIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])
    carpetIconVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])
	}
	function genIcons() {
		blockIcons = [null]
		blockIcons.lengths = []
		let texOrder = [ 1, 4, 3 ]
		let shadows = [ 1, 0.4, 0.7 ]
		let scale = 0.16 / height * inventory.size
    let prevTexture
		for (let i = 1; i < BLOCK_COUNT; i++) {
			let data = []
      let v, buffer
			let block = blockData[i]
      if(block.icon){
        block = blockData[blockIds[block.icon]]
      }
      if(block.iconTexture){
        prevTexture = block.textures
        block.textures = new Array(6).fill(block.iconTexture)
      }
      if(block.flatIcon){
        v = _2dIconVerts
        for (let j = 3; j >= 0; j--) {
          let num = 0
          let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
          let tx = tex[0]
          let ty = tex[1]
          data.push(-v[j * 5 + 0] * scale)
          data.push(v[j * 5 + 1] * scale)
          data.push(0.1666666)
          data.push(tx + v[j * 5 + 2] / 16)
          data.push(ty + v[j * 5 + 3] / 16)
          data.push(shadows[num])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6
        blockIcons[i | CROSS] = buffer
        blockIcons.lengths[i | CROSS] = 6
        blockIcons[i | TALLCROSS] = buffer
        blockIcons.lengths[i | TALLCROSS] = 6
        blockIcons[i | WALLFLAT] = buffer
        blockIcons.lengths[i | WALLFLAT] = 6
        blockIcons[i | TORCH] = buffer
        blockIcons.lengths[i | TORCH] = 6
      }else if(block.carpet){
        v = carpetIconVerts
        for (let j = 11; j >= 0; j--) {
          let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
          data.push(-v[j * 3 + 0] * scale)
          data.push(v[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(tex[(j * 2 + 0) % 8])
          data.push(tex[(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6
        blockIcons[i | CARPET] = buffer
        blockIcons.lengths[i | CARPET] = 6
      }else{
        for (let j = 11; j >= 0; j--) {
          data.push(-hexagonVerts[j * 3 + 0] * scale)
          data.push(hexagonVerts[j * 3 + 1] * scale)
          data.push(0.1666666)
          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
          data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
          data.push(shadows[floor(j / 4)])
        }
        buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
        blockIcons[i] = buffer
        blockIcons.lengths[i] = 6 * 3
      }

			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]

				data.push(-slabIconVerts[j * 3 + 0] * scale)
				data.push(slabIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | SLAB] = buffer
			blockIcons.lengths[i | SLAB] = 6 * 3

			data = []
			v = stairIconVerts
			for (let j = 23; j >= 0; j--) {
				let num = floor(j / 8)
				let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
				let tx = tex[0]
				let ty = tex[1]
				data.push(-v[j * 5 + 0] * scale)
				data.push(v[j * 5 + 1] * scale)
				data.push(0.1666666)
				data.push(tx + v[j * 5 + 2] / 16)
				data.push(ty + v[j * 5 + 3] / 16)
				data.push(shadows[num])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | STAIR] = buffer
			blockIcons.lengths[i | STAIR] = 6 * 6
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fenceIconVerts[j * 3 + 0] * scale)
				data.push(fenceIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCE] = buffer
			blockIcons.lengths[i | FENCE] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallPostIconVerts[j * 3 + 0] * scale)
				data.push(wallPostIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLPOST] = buffer
			blockIcons.lengths[i | WALLPOST] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-wallIconVerts[j * 3 + 0] * scale)
				data.push(wallIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALL] = buffer
			blockIcons.lengths[i | WALL] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-walluIconVerts[j * 3 + 0] * scale)
				data.push(walluIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | WALLU] = buffer
			blockIcons.lengths[i | WALLU] = 6 * 1
      
      data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-fencqIconVerts[j * 3 + 0] * scale)
				data.push(fencqIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | FENCQ] = buffer
			blockIcons.lengths[i | FENCQ] = 6 * 1
			
			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]

				data.push(-buttonIconVerts[j * 3 + 0] * scale)
				data.push(buttonIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[Math.floor(j / 16)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | BUTTON] = buffer
			blockIcons.lengths[i | BUTTON] = 6 * 1
      
      if(block.iconTexture){
        block.textures = prevTexture
      }
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix)
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache[cacheId]
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName)
			glCache[cacheId] = vrLocation
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation)
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)

		}
	}

	//Generate buffers for every block face and store them
	let sideEdgeBuffers
	let indexBuffer

	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z
		result.x = y * z2 - y2 * z
		result.y = z * x2 - z2 * x
		result.z = x * y2 - x2 * y
	}

	let matrix = new Float32Array(16); // A temperary matrix that may store random data.
	let projection = new Float32Array(16)
	let defaultModelView = new Float32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Matrix {
		constructor(arr) {
			this.elements = new Float32Array(arr || 16)
		}
		translate(x, y, z) {
			let a = this.elements
			a[3] += a[0] * x + a[1] * y + a[2] * z
			a[7] += a[4] * x + a[5] * y + a[6] * z
			a[11] += a[8] * x + a[9] * y + a[10] * z
			a[15] += a[12] * x + a[13] * y + a[14] * z
		}
		rotX(angle) {
			let elems = this.elements
			let c = cos(angle)
			let s = sin(angle)
			let t = elems[1]
			elems[1] = t * c + elems[2] * s
			elems[2] = t * -s + elems[2] * c
			t = elems[5]
			elems[5] = t * c + elems[6] * s
			elems[6] = t * -s + elems[6] * c
			t = elems[9]
			elems[9] = t * c + elems[10] * s
			elems[10] = t * -s + elems[10] * c
			t = elems[13]
			elems[13] = t * c + elems[14] * s
			elems[14] = t * -s + elems[14] * c
		}
		rotY(angle) {
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[2] * -s
			elems[2] = t * s + elems[2] * c
			t = elems[4]
			elems[4] = t * c + elems[6] * -s
			elems[6] = t * s + elems[6] * c
			t = elems[8]
			elems[8] = t * c + elems[10] * -s
			elems[10] = t * s + elems[10] * c
			t = elems[12]
			elems[12] = t * c + elems[14] * -s
			elems[14] = t * s + elems[14] * c
		}
    rotZ(angle) {//doesn't work
			let c = cos(angle)
			let s = sin(angle)
			let elems = this.elements
			let t = elems[0]
			elems[0] = t * c + elems[2] * s
			elems[1] = t * s + elems[2] * c
			t = elems[4]
			elems[4] = t * c + elems[6] * s
			elems[5] = t * s + elems[6] * c
			t = elems[8]
			elems[8] = t * c + elems[10] * s
			elems[9] = t * s + elems[10] * c
			t = elems[12]
			elems[12] = t * c + elems[14] * s
			elems[13] = t * s + elems[14] * c
		}
		scale(x, y, z) {
			let a = this.elements
			a[0] *= x;
			a[1] *= y;
			a[2] *= z;
			a[4] *= x;
			a[5] *= y;
			a[6] *= z;
			a[8] *= x;
			a[9] *= y;
			a[10] *= z;
			a[12] *= x;
			a[13] *= y;
			a[14] *= z;
		}
		identity() {
			let a = this.elements
			a[0] = 1
			a[1] = 0
			a[2] = 0
			a[3] = 0
			a[4] = 0
			a[5] = 1
			a[6] = 0
			a[7] = 0
			a[8] = 0
			a[9] = 0
			a[10] = 1
			a[11] = 0
			a[12] = 0
			a[13] = 0
			a[14] = 0
			a[15] = 1
		}
		// somebody optimize this
		// you just have to expand it
		mult(b) {
			const a = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		// same here
		postMult(a) {
			const b = this.elements.slice()
			const out = this.elements
			let e = 0
			for (let row = 0; row < 4; row++) {
				for (let col = 0; col < 4; col++) {
					out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
				}
			}
		}
		transpose() {
			let matrix = this.elements
			let temp = matrix[4]
			matrix[4] = matrix[1]
			matrix[1] = temp

			temp = matrix[8]
			matrix[8] = matrix[2]
			matrix[2] = temp

			temp = matrix[6]
			matrix[6] = matrix[9]
			matrix[9] = temp

			temp = matrix[3]
			matrix[3] = matrix[12]
			matrix[12] = temp

			temp = matrix[7]
			matrix[7] = matrix[13]
			matrix[13] = temp

			temp = matrix[11]
			matrix[11] = matrix[14]
			matrix[14] = temp
		}
		copyArray(from) {
			let to = this.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
		copyMatrix(from) {
			let to = this.elements
			from = from.elements
			for (let i = 0; i < from.length; i++) {
				to[i] = from[i]
			}
		}
	}

	class Plane {
		constructor(nx, ny, nz) {
			this.set(nx, ny, nz)
		}
		set(nx, ny, nz) {
			// Pre-computed chunk offsets to reduce branching during culling
			this.dx = nx > 0 ? 16 : 0
			this.dy = ny > 0
			this.dz = nz > 0 ? 16 : 0

			// Normal vector for the plane
			this.nx = nx
			this.ny = ny
			this.nz = nz
		}
	}

	let defaultTransformation = new Matrix([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
	class Camera {
		constructor() {
			this.x = 0
			this.y = 0
			this.z = 0
			this.rx = 0; // Pitch
			this.ry = 0; // Yaw
      this.rz = 0
			this.currentFov = 0
			this.defaultFov = settings.fov
			this.targetFov = settings.fov
			this.step = 0
			this.lastStep = 0
			this.projection = new Float32Array(5)
			this.transformation = new Matrix()
			this.direction = { x: 1, y: 0, z: 0 }; // Normalized direction vector
			this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
			for (let i = 0; i < 5; i++) {
				this.frustum.push(new Plane(1, 0, 0))
			}
		}
		FOV(fov, time) {
			if (fov === this.currentFov) return

			if (!fov) {
				let now = Date.now()
				fov = this.currentFov + this.step * (now - this.lastStep)
				this.lastStep = now
				if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
					fov = this.targetFov
				}
			}
			else if (time) {
				this.targetFov = fov
				this.step = (fov - this.currentFov) / time
				this.lastStep = Date.now()
				return
			} else {
				this.targetFov = fov
			}

			const tang = Math.tan(fov * Math.PI / 360)
			const scale = 1 / tang
			const near = 1
			const far = 1000000
			this.currentFov = fov; // Store the state of the projection matrix
			this.nearH = near * tang; // This is needed for frustum culling

			this.projection[0] = scale / width * height
			this.projection[1] = scale
			this.projection[2] = -far / (far - near)
			this.projection[3] = -1
			this.projection[4] = -far * near / (far - near)
		}
		transform() {
			this.transformation.copyMatrix(defaultTransformation)
			this.transformation.rotX(this.rx)
			this.transformation.rotY(this.ry)
      //this.transformation.rotZ(this.rz)
			this.transformation.translate(-this.x, -this.y, -this.z)
		}
    resetMatrix() {
      this.transformation.copyMatrix(defaultTransformation)
    }
		getMatrix() {
			let proj = this.projection
			let view = this.transformation.elements
			matrix[0]  = proj[0] * view[0]
			matrix[1]  = proj[1] * view[4]
			matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
			matrix[3]  = proj[4] * view[8]
			matrix[4]  = proj[0] * view[1]
			matrix[5]  = proj[1] * view[5]
			matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
			matrix[7]  = proj[4] * view[9]
			matrix[8]  = proj[0] * view[2]
			matrix[9]  = proj[1] * view[6]
			matrix[10] = proj[2] * view[10] + proj[3] * view[14]
			matrix[11] = proj[4] * view[10]
			matrix[12] = proj[0] * view[3]
			matrix[13] = proj[1] * view[7]
			matrix[14] = proj[2] * view[11] + proj[3] * view[15]
			matrix[15] = proj[4] * view[11]
			return matrix
		}
		setDirection() {
			if (this.targetFov !== this.currentFov) {
				this.FOV()
			}
			this.direction.x = -sin(this.ry) * cos(this.rx)
			this.direction.y = sin(this.rx)
			this.direction.z = cos(this.ry) * cos(this.rx)
			this.computeFrustum()
		}
		computeFrustum() {
			let X = vec1
			let dir = this.direction
			X.x = dir.z
			X.y = 0
			X.z = -dir.x
			X.normalize()

			let Y = vec2
			Y.set(dir)
			Y.mult(-1)
			cross(Y, X, Y)

			//Near plane
			this.frustum[0].set(dir.x, dir.y, dir.z)

			let aux = vec3
			aux.set(Y)
			aux.mult(this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(aux, X, aux)
			this.frustum[1].set(aux.x, aux.y, aux.z)

			aux.set(Y)
			aux.mult(-this.nearH)
			aux.add(dir)
			aux.normalize()
			cross(X, aux, aux)
			this.frustum[2].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(-this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(aux, Y, aux)
			this.frustum[3].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			cross(Y, aux, aux)
			this.frustum[4].set(aux.x, aux.y, aux.z)
		}
		canSee(x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx = p.x, cy = p.y, cz = p.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
		}
	}

	function trans(matrix, x, y, z) {
		let a = matrix
		a[3] += a[0] * x + a[1] * y + a[2] * z
		a[7] += a[4] * x + a[5] * y + a[6] * z
		a[11] += a[8] * x + a[9] * y + a[10] * z
		a[15] += a[12] * x + a[13] * y + a[14] * z
	}
	function rotX(matrix, angle) {
		// This function is basically multiplying 2 4x4 matrices together,
		// but 1 of them has a bunch of 0's and 1's in it,
		// so I removed all terms that multiplied by 0, and just left off the 1's.
		// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix
		let c = cos(angle)
		let s = sin(angle)
		let t = elems[1]
		elems[1] = t * c + elems[2] * s
		elems[2] = t * -s + elems[2] * c
		t = elems[5]
		elems[5] = t * c + elems[6] * s
		elems[6] = t * -s + elems[6] * c
		t = elems[9]
		elems[9] = t * c + elems[10] * s
		elems[10] = t * -s + elems[10] * c
		t = elems[13]
		elems[13] = t * c + elems[14] * s
		elems[14] = t * -s + elems[14] * c
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = cos(angle)
		let s = sin(angle)
		let elems = matrix
		let t = elems[0]
		elems[0] = t * c + elems[2] * -s
		elems[2] = t * s + elems[2] * c
		t = elems[4]
		elems[4] = t * c + elems[6] * -s
		elems[6] = t * s + elems[6] * c
		t = elems[8]
		elems[8] = t * c + elems[10] * -s
		elems[10] = t * s + elems[10] * c
		t = elems[12]
		elems[12] = t * c + elems[14] * -s
		elems[14] = t * s + elems[14] * c
	}
	function transpose(matrix) {
		let temp = matrix[4]
		matrix[4] = matrix[1]
		matrix[1] = temp

		temp = matrix[8]
		matrix[8] = matrix[2]
		matrix[2] = temp

		temp = matrix[6]
		matrix[6] = matrix[9]
		matrix[9] = temp

		temp = matrix[3]
		matrix[3] = matrix[12]
		matrix[12] = temp

		temp = matrix[7]
		matrix[7] = matrix[13]
		matrix[13] = temp

		temp = matrix[11]
		matrix[11] = matrix[14]
		matrix[14] = temp
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection
		let view = modelView
		matrix[0] = proj[0] * view[0]
		matrix[1] = proj[0] * view[1]
		matrix[2] = proj[0] * view[2]
		matrix[3] = proj[0] * view[3]
		matrix[4] = proj[5] * view[4]
		matrix[5] = proj[5] * view[5]
		matrix[6] = proj[5] * view[6]
		matrix[7] = proj[5] * view[7]
		matrix[8] = proj[10] * view[8] + proj[11] * view[12]
		matrix[9] = proj[10] * view[9] + proj[11] * view[13]
		matrix[10] = proj[10] * view[10] + proj[11] * view[14]
		matrix[11] = proj[10] * view[11] + proj[11] * view[15]
		matrix[12] = proj[14] * view[8]
		matrix[13] = proj[14] * view[9]
		matrix[14] = proj[14] * view[10]
		matrix[15] = proj[14] * view[11]
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i]
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180)
		let scale = 1 / tang
		let near = 1
		let far = 1000000
		currentFov = fov

		projection[0] = scale / width * height
		projection[5] = scale
		projection[10] = -far / (far - near)
		projection[11] = -1
		projection[14] = -far * near / (far - near)
	}
	function initModelView(camera, x, y, z, rx, ry) {
		if (camera) {
			camera.transform()
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			copyArr(defaultModelView, modelView)
			rotX(modelView, rx)
			rotY(modelView, ry)
			trans(modelView, -x, -y, -z)
			matMult()
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
	}

	function timeString(millis) {
		if (millis > 300000000000 || !millis) {
			return "never"
		}
		const SECOND = 1000
		const MINUTE = SECOND * 60
		const HOUR = MINUTE * 60
		const DAY = HOUR * 24
		const YEAR = DAY * 365

		if (millis < MINUTE) {
			return "just now"
		}

		let years = floor(millis / YEAR)
		millis -= years * YEAR

		let days = floor(millis / DAY)
		millis -= days * DAY

		let hours = floor(millis / HOUR)
		millis -= hours * HOUR

		let minutes = floor(millis / MINUTE)

		if (years) {
			return `${years} year${years > 1 ? "s" : ""} and ${days} day${day !== 1 ? "s" : ""} ago`
		}
		if (days) {
			return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
		}
		if (hours) {
			return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
		}
		return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
	}
	function roundBits(number) {
		return ((number * 1000000 + 0.5) | 0) / 1000000
	}
	function rayTrace(x, y, z, shape) {
		let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, min, max; //Bounds of face coordinates
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
		let verts = shape.verts
		let faces = verts[0]

		//Top and bottom faces

		if (top) {
			faces = verts[1]
		}
		if (p.direction.y) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				m = (y + face[1] - p.y) / p.direction.y
				ix = m * p.direction.x + p.x
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
					cd = m; //Ray crosses bottom face
					cf = top ? "top" : "bottom"
				}
			}
		}

		//West and East faces
		if (east) {
			faces = verts[4]
		} else {
			faces = verts[5]
		}
		if (p.direction.x) {
			for (let face of faces) {
				min = face.min
				minY = min[1]
				minZ = min[2]
				max = face.max
				maxY = max[1]
				maxZ = max[2]
				m = (x + face[0] - p.x) / p.direction.x
				iy = m * p.direction.y + p.y
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
					cd = m
					cf = east ? "east" : "west"
				}
			}
		}

		//South and North faces
		if (north) {
			faces = verts[2]
		} else {
			faces = verts[3]
		}
		if (p.direction.z) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				m = (z + face[2] - p.z) / p.direction.z
				ix = m * p.direction.x + p.x
				iy = m * p.direction.y + p.y
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
					cd = m
					cf = north ? "north" : "south"
				}
			}
		}
		return [ cd, cf ]
	}
	function runRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z)
		if (block && !blockData[block].noHitbox) {
			let shape = blockData[block].shape
			let rt = rayTrace(x, y, z, blockData[block].shape)

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0]
				hitBox.face = rt[1]
				hitBox.pos = [ x, y, z ]
				hitBox.shape = blockData[block].shape
        if(hitBox.shape.hitbox) hitBox.shape = hitBox.shape.hitbox
        
        crack.pos = [x, y, z]
        crack.shape = blockData[block].shape
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null
		hitBox.closest = 1e9

		if (p.spectator) {
			return
		}
		let blockState = world.getBlock(p2.x, p2.y, p2.z)
		if (blockState && !blockData[blockState].noHitbox) {
			hitBox.pos = [ p2.x, p2.y, p2.z ]
			hitBox.closest = 0
			hitBox.shape = blockData[blockState].shape
      if(hitBox.shape.hitbox) hitBox.shape = hitBox.shape.hitbox
      
      crack.pos = [p2.x, p2.y, p2.z]
      crack.shape = blockData[blockState].shape
			return
		}

		let pd = p.direction

		// Target block
		let tx = round(pd.x * reach + p.x)
		let ty = round(pd.y * reach + p.y)
		let tz = round(pd.z * reach + p.z)

		let minX = p2.x
		let maxX = 0
		let minY = p2.y
		let maxY = 0
		let minZ = p2.z
		let maxZ = 0

		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach
			}
			maxX = round(p.x + pd.x * i)
			maxY = round(p.y + pd.y * i)
			maxZ = round(p.z + pd.z * i)
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ)
					}
					runRayTrace(maxX, maxY, minZ)
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ)
				}
				runRayTrace(maxX, minY, minZ)
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ)
				}
				runRayTrace(minX, maxY, minZ)
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ)
			}
			if (hitBox.pos) {
				return; //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ
			minY = maxY
			minX = maxX
		}
	}
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH
		let ih = h + p.bottomH + p.topH
		let ix = x - w/2 - p.w
		let iw = w + p.w*2
		let iz = z - d/2 - p.w
		let id = d + p.w*2
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
	let onBox = function(x, y, z, w, h, d) {
		let iy = roundBits(y - h/2 - p.topH)
		let ih = roundBits(h + p.bottomH + p.topH)
		let ix = roundBits(x - w/2 - p.w)
		let iw = roundBits(w + p.w*2)
		let iz = roundBits(z - d/2 - p.w)
		let id = roundBits(d + p.w*2)
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
	}
  let takeDamage
	function collided(x, y, z, vx, vy, vz, block) {
		if(p.spectator) {
			return false
		}
    let shape = blockData[block].shape
    if(shape.hitbox) shape = shape.hitbox
		let verts = shape.verts
    let blockObj = blockData[block]
		let px = roundBits(p.x - p.w - x)
		let py = roundBits(p.y - p.bottomH - y)
		let pz = roundBits(p.z - p.w - z)
		let pxx = roundBits(p.x + p.w - x)
		let pyy = roundBits(p.y + p.topH - y)
		let pzz = roundBits(p.z + p.w - z)
		let minX, minY, minZ, maxX, maxY, maxZ, min, max

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (!vx && !vz) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					if (vy <= 0) {
						p.onGround = true
						p.y = round((face[1] + y + p.bottomH) * 10000) / 10000
						return false
					} else {
            //if(blockObj.damage > takeDamage){
              //takeDamage = blockObj.damage
            //}
						return true
					}
				}
			}
			return false
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		} else if (vx > 0) {
			faces = verts[5]
		}
		if (vx) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5) {
						p.canStepX = false
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		} else if (vz > 0) {
			faces = verts[3]
		}
		if (vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5) {
						p.canStepZ = false
					}
					col = true
          //if(blockObj.damage > takeDamage){
            //takeDamage = blockObj.damage
          //}
				}
			}
			return col
		}
	}
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		},
		clear: function() {
			this.size = 0
		},
	}
  let blocks = []
	let resolveContactsAndUpdatePosition = function(now) {
		let pminX = p2.x - 1
		let pmaxX = p2.x + 1
		let pminY = p2.y - 2
		let pmaxY = p2.y + 1
		let pminZ = p2.z - 1
		let pmaxZ = p2.z + 1
		let block = null
		let vel = p.velocity
    let blocksSize = 0
    
		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z)
					if (block && blockData[block].solid && !blockData[block].liquid) {
						contacts.add(x, y, z, block)
					}
          if (block) {
            if(blocks[blocksSize]){
              blocks[blocksSize][0] = x
              blocks[blocksSize][1] = y
              blocks[blocksSize][2] = z
              blocks[blocksSize][3] = block
            }else{
              blocks.push([x,y,z,block])
            }
            blocksSize ++
          }
				}
			}
		}

		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		p.previousX = p.x
		p.previousY = p.y
		p.previousZ = p.z

    var ontouch
    var x
    var y
    var z
    var damageBlock
    takeDamage = 0
    liquid = false
    //collisions for ontouch
    for (let i = 0; i < blocksSize; i++) {
			block = blocks[i]
      x = block[0]
      y = block[1]
      z = block[2]
      if(block[0] === p2.x && block[2] === p2.z && blockData[block[3]].ontouch){
        ontouch = blockData[block[3]].ontouch
      }
      if(blockData[block[3]].liquid) {
        liquid = true
      }
      let d = blockData[block[3]].damage
      if(d && d>takeDamage/* && collided(x,y,z,0,0,0,block[3])*/) {
        takeDamage = d
        damageBlock = blockData[block[3]]
      }
		}
    
		//Check collisions in the Y direction
		p.onGround = false
		p.canStepX = false
		p.canStepZ = false
		p.y += vel.y * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, vel.y, 0, block[3])) {
				p.y = p.previousY
				vel.y = 0
				break
			}
		}
		if (p.y === p.previousY && !p.flying) {
			p.canStepX = true
			p.canStepZ = true
		}

		var sneakLock = false, sneakSafe = false
		if (p.sneaking) {
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakLock = true
					break
				}
			}
		}

		//Check collisions in the X direction
		p.x += vel.x * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], vel.x, 0, 0, block[3])) {
				if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.x = p.previousX
				vel.x = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.x = p.previousX
			vel.x = 0
		}
		sneakSafe = false

		//Check collisions in the Z direction
		p.z += vel.z * dt
		for (let i = 0; i < contacts.size; i++) {
			block = contacts.array[i]
			if (collided(block[0], block[1], block[2], 0, 0, vel.z, block[3])) {
				if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				p.z = p.previousZ
				vel.z = 0
				break
			}
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true
			}
		}

		if (sneakLock && !sneakSafe) {
			p.z = p.previousZ
			vel.z = 0
		}

		if (!p.flying) {
      if (liquid){
        //p.jumpSpeed = 0.135;
        p.gravityStength = -0.01;
        if (Key[" "]){
          p.velocity.y += 0.025
        }
        if (Key.shift){
          p.velocity.y -= 0.025
        }
        p.velocity.y *= 0.9
      }else{
        p.gravityStength = -0.032
      }
			let drag = liquid ? 0.7 : (p.onGround ? 0.5 : 0.85)
      if(blockData[standingOn].slide) drag = blockData[standingOn].slide
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
		} else {
			let drag = 0.9
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt
			if (p.onGround && !p.spectator) {
				p.flying = false
			}
		}

		p.lastUpdate = performance.now()
		contacts.clear()
		lookingAt()
    
    if(takeDamage > 0 && now - lastBlockHarm > 500 && survival){
      lastBlockHarm = now
      p.health -= takeDamage
      harmEffect = 40
      hitSound()
      dieMessage = damageBlock.dieMessage ? damageBlock.dieMessage() : (username+" died because of "+damageBlock.name+". You should avoid it next time.")
      updateHUD = true;
    }
    
    if(ontouch){
      ontouch(x, y, z)
    }
	}
	let runGravity = function() {
		if (p.flying) {
			return
		}
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt
		if(p.onGround) {
      let fall = p.lastY - p.y
      p.lastY = p.y
      var block = standingOn
      if(fall > 3 && survival && !liquid) {
        p.health -= Math.floor(fall-3)//Math.floor( (p.velocity.y * p.velocity.y * 8));
        harmEffect = 40
        dieMessage = username+" fell from a high place. You fell "+Math.round(fall)+" blocks."
        updateHUD = true;
        if(fall > 6){
          playSound("damage.bigfall")
        }else playSound("damage.smallfall")
			}
      if(p.velocity.y < -0.1 && block){
        blockParticles(block, p.x,p.y-2,p.z,10)
        blockSound(block, "step")
      }
      if(blockData[block].bounciness && p.velocity.y < -0.2){
        p.velocity.y *= -blockData[block].bounciness
      }else{
        if(Key[" "]) {
          p.velocity.y = p.jumpSpeed
          p.onGround = false
        } else {
          p.velocity.y = 0
        }
      }
		} else {
			p.velocity.y += p.gravityStength * dt
			if(p.velocity.y < -p.maxYVelocity) {
				p.velocity.y = -p.maxYVelocity
			}
		}
    if(liquid !== lastLiquid){
      lastLiquid = liquid
      if(liquid){
        playSound("liquid.enter")
      }else{
        playSound("liquid.exit")
      }
    }
	}
  
  let defineWorld = function() {
		let tickStart = performance.now()
		world.tick()
		analytics.totalTickTime += performance.now() - tickStart
		let renderStart = performance.now()
    p2.x = round(p.x)
	  p2.y = round(p.y)
		p2.z = round(p.z)
    p3.x = p.x
    p3.y = p.y
    p3.z = p.z
    p3.ry = p.ry
    p3.survival = survival
    p3.username = username || ""
    let prevX
    let prevY
    let prevZ
    let prevRotX
    let prevRotY
    if(p.thirdPerson){
      prevX = p.x
      prevY = p.y
      prevZ = p.z
      prevRotX = p.rx
      prevRotY = p.ry
      /*p.rx += Math.PI
      p.ry += Math.PI*/ //third person back, not front
      p.x -= p.direction.x*4
      p.y -= p.direction.y*4
      p.z -= p.direction.z*4
    }
		world.render(prevX, prevY, prevZ, prevRotX, prevRotY)
    if(p.thirdPerson){
      p.x = prevX
      p.y = prevY
      p.z = prevZ
      p.rx = prevRotX
      p.ry = prevRotY
    }
		analytics.totalRenderTime += performance.now() - renderStart
	}
  
  let renderPlayer = function(){
    if(p.thirdPerson){
      p.character.render()
    }else{
      //p.hand.render()
    }
  }
  let updtPlayer = function(){
    p.character.x = p.x
    p.character.y = p.y-1
    p.character.z = p.z
    p.character.yaw = -p.ry
    
    p.character.update()
    
    //p.hand.update()
  }

	let controls = function() {
		move.x = 0
		move.z = 0
		let dt = (performance.now() - p.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		if(Key.w) move.z += p.speed
		if(Key.s) move.z -= p.speed
		if(Key.a) move.x += p.speed
		if(Key.d) move.x -= p.speed
		if (p.flying) {
			if(Key[" "]) p.velocity.y += 0.06 * dt
			if(Key.shift) p.velocity.y -= 0.06 * dt
		}
		if(Key.arrowleft) p.ry -= 0.1 * dt
		if(Key.arrowright) p.ry += 0.1 * dt
		if(Key.arrowup) p.rx += 0.1 * dt
		if(Key.arrowdown) p.rx -= 0.1 * dt

		if (!p.sprinting && Key.q && !p.sneaking && Key.w) {
			p.FOV(settings.fov + 10, 250)
			p.sprinting = true
		}

		if(p.sprinting) {
			move.x *= p.sprintSpeed
			move.z *= p.sprintSpeed
		}
		if(p.flying) {
			move.x *= p.flySpeed
			move.z *= p.flySpeed
		}
		if (!move.x && !move.z) {
			if (p.sprinting) {
				p.FOV(settings.fov, 100)
			}
			p.sprinting = false
		} else if(abs(move.x) > 0 && abs(move.z) > 0) {
			move.x *= move.ang
			move.z *= move.ang
		}

		//Update the velocity, rather than the position.
		let co = cos(p.ry)
		let si = sin(p.ry)
    let speedFactor = blockData[standingOn].speedFactor
		let friction = liquid ? 0.4 : (p.onGround ? 1 : 0.3)
    if(speedFactor){
      friction *= speedFactor
    }
		p.velocity.x += (co * move.x - si * move.z) * friction * dt
		p.velocity.z += (si * move.x + co * move.z) * friction * dt

		const TAU = Math.PI * 2
		const PI1_2 = Math.PI / 2
		while(p.ry > TAU) p.ry -= TAU
		while(p.ry < 0)   p.ry += TAU
		if(p.rx > PI1_2)  p.rx = PI1_2
		if(p.rx < -PI1_2) p.rx = -PI1_2

		p.setDirection()
	}

	function box2(sides, tex, shape) {
		if (blockFill && !shape) {
			let i = 0
			for (let side in Block) {
				if (sides & Block[side]) {
					vertexAttribPointer("aVertex", program3D, "aVertex", 3, sideEdgeBuffers[Sides[side]])
					vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
				}
				i++
			}
		}else if(shape){
			for (let i = 0; i < shape.size; i++) {
        vertexAttribPointer("aVertex", program3D, "aVertex", 3, shape.buffer)
	 		  vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
				gl.drawArrays(gl.TRIANGLES, i * 4, 4) //doesn't work
			}
    }
		if (blockOutlines) {
			vertexAttribPointer("aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
			vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox])
			for (let i = 0; i < hitBox.shape.size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
			}
    }
	}
	function block2(x, y, z, t, camera) {
		if (camera) {
			camera.transformation.translate(x, y, z)
			uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
		} else {
			//copyArr(modelView, matrix)
			trans(modelView, x, y, z)
			matMult()
			trans(modelView, -x, -y, -z)
			transpose(matrix)
			uniformMatrix("view3d", program3D, "uView", false, matrix)
		}
    box2(0xff, blockData[t].textures)
	}

	function changeWorldBlock(t, drop) {
		let pos = hitBox.pos
		if(pos && pos[1] > 0 && pos[1] < maxHeight) {
			let shape = t && blockData[t].shape
			if (t && shape.rotate) {
				let pi = Math.PI / 4
				if (p.ry <= pi) {} // North; default
				else if (p.ry < 3 * pi) {
					t |= WEST
				} else if (p.ry < 5 * pi) {
					t |= SOUTH
				} else if (p.ry < 7 * pi) {
					t |= EAST
				}
			}

			if (t && shape.flip && hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y) % 1 < 0.5)) {
				t |= FLIP
			}

      var prevBlock = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t)
      if(drop){
        let block = prevBlock
        let theDrop = blockData[prevBlock].drop
        let amount = blockData[prevBlock].dropAmount
        if(amount.length === 2){
          amount = round(rand(amount[0], amount[1]))
        }
        if(typeof theDrop === "function"){
          block = blockIds[theDrop()]
        }else if(theDrop) block = blockIds[theDrop]
        if(block && pos){
          for(var i=0; i<amount; i++){
            world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, block, true))
          }
        }
      }
			if (t) {
				p.lastPlace = Date.now()
			} else {
				p.lastBreak = Date.now()
        if(!prevBlock) return
        blockParticles(prevBlock,hitBox.pos[0],hitBox.pos[1],hitBox.pos[2],30)
        blockSound(prevBlock, "dig", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
			}
		}
	}
	function newWorldBlock() {
    if(hitBox.pos){
      let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2]
      let block = world.getBlock(x, y, z)
      if(block){
        let onclick = blockData[block].onclick
        if(onclick){
          if(!onclick(x, y, z)){p.lastPlace = Date.now(); return} //if it doesn't return true
        }
        let onuse = blockData[holding] ? blockData[holding].onuse : null
        if(onuse){ //items like flint and steel can't be placed but lights stuff
          if(!onuse(x,y,z, block)){p.lastPlace = Date.now(); return}
        }
      }
    }
		if(!hitBox.pos || !holding || blockData[holding].item) {
			return
		}
    let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2]
    let side = false
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
        side = true
				break
			case "north":
				z += 1
        side = true
				break
			case "west":
				x -= 1
        side = true
				break
			case "east":
				x += 1
        side = true
				break
		}
    var hitboxBlock = world.getBlock(x, y, z)
    var blocking = blockData[holding].solid && inBox(x, y, z, 1, 1, 1)
    var canPlace = (!hitboxBlock) || (blockData[hitboxBlock].liquid)
		if (!blocking && canPlace) {
      var block = holding
      
			pos[0] = x
			pos[1] = y
			pos[2] = z
			var prevBlockMode = blockMode;
      var onPot = !side && blockData[world.getBlock(x,y-1,z)] && blockData[world.getBlock(x,y-1,z)].pot
      if(blockData[holding].potCross && onPot){
        blockMode = POTCROSS
      }else if(blockData[holding].crossShape){
        if(onPot && blockIds[blockData[holding].name+"Pot"]){
          block = blockIds[blockData[holding].name+"Pot"]
          blockMode = POTCROSS
        }else{
          blockMode = CROSS
        }
      }
      if(blockData[holding].tallcrossShape){
        blockMode = TALLCROSS
      }
      if(blockData[holding].door){
        blockMode = DOOR
      }
      if(blockData[holding].torch){
        blockMode = TORCH
      }
      if(blockData[holding].lantern){
        if(world.getBlock(hitBox.pos[0],hitBox.pos[1]+1,hitBox.pos[2])){
          blockMode = LANTERNHANG
        }else{
          blockMode = LANTERN
        }
      }
      if(blockData[holding].beacon){
        blockMode = BEACON
      }
      if(blockData[holding].cactus && blockMode !== POTCROSS){
        blockMode = CACTUS
      }
      if(blockData[holding].pane){
        blockMode = PANE
      }
      if(blockData[holding].portal){
        blockMode = PORTAL
      }
      if(blockData[holding].wallFlat){
        blockMode = WALLFLAT
      }
      if(blockData[holding].trapdoor){
        if(side){
          blockMode = TRAPDOOROPEN
        }else{
          blockMode = TRAPDOOR
        }
      }
      if(blockData[holding].chain){
        blockMode = CHAIN
      }
      if(blockData[holding].button){
        blockMode = BUTTON
      }
      if(blockData[holding].pot){
        blockMode = POT
      }
      if(blockData[holding].carpet){
        blockMode = CARPET
      }
      
      if(side && blockIds[blockData[block].name+"SW"]){
        block = blockIds[blockData[block].name+"SW"]
      }
			changeWorldBlock(block < isCube ? (block | blockMode) : block)
      blockMode = prevBlockMode;
      
      if(survival && inventory.hotbar[inventory.hotbarSlot]){
        inventory.hotbar[inventory.hotbarSlot].amount --;
        updateHUD = true
      }
      
      //play sound
      blockSound(block, "place", x,y,z)
		}
	}

  function cracks(){
    var now = Date.now()
    var block = hitBox.pos ? world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) : 0
    var breaking = Key.leftMouse && block && (crack.delayDone >= crack.delayBetween)
    if(!arrayValues(crack.prevPos, crack.pos)){
      crack.prevPos = crack.pos
      crack.soundTimer = 0
      crack.delayDone = 0
      crack.breakStart = now
    }
    if(breaking){
      crack.idx = map(now, crack.breakStart,crack.breakStart+blockData[block].breakTime, 0,crack.length)
      crack.idx = floor(crack.idx)
      crack.tex = crack[crack.idx]
      crack.soundTimer ++
      if(crack.soundTimer > 15){
        crack.soundTimer -= 15
        blockSound(block, "breaking", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
      }
      if(crack.idx >= crack.length) changeWorldBlock(0, true)
    }else{
      crack.idx = -1
      crack.delayDone ++
      crack.breakStart = now
    }
    if(!Key.leftMouse){
      crack.delayDone = 0
    }
  }

	// Save the coords for a small sphere used to carve out caves
	let sphere;
	{
		let blocks = []
		let radius = 3.5
		let radsq = radius * radius
		for (let i = -radius; i <= radius; i++) {
			for (let j = -radius; j <= radius; j++) {
				for (let k = -radius; k <= radius; k++) {
					if (i*i + j*j + k*k < radsq) {
						blocks.push(i|0, j|0, k|0)
					}
				}
			}
		}
		sphere = new Int8Array(blocks)
	}

	function isCave(x, y, z) {
		// Generate a 3D rigid multifractal noise shell.
		// Then generate another one with different coordinates.
		// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
		// This is extremely slow, and requires generating 2 noise values for every single block in the world.
		// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
		let smooth = 0.02
		let caveSize = 0.0055
		let cave1 = abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
		let cave2 = abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
		return (cave1 && cave2)
	}
	function carveSphere(x, y, z) {
		if (y > 3) {
			for (let i = 0; i < sphere.length; i += 3) {
				world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true)
			}
		}
	}

	let renderedChunks = 0
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
	}
	/**
	 * Returns a 1 if the face is exposed and should be drawn, or a 0 if the face is hidden
	 * 
	 * @param {number} x - The X coordinate of the block that may be covering a face
	 * @param {number} y - The Y coordinate of the block that may be covering a face
	 * @param {number} z - The Z coordinate of the block that may be covering a face
	 * @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
	 * @param {number} type - The blockstate of the block that's being considered for face culling
	 * @param {function} func - The function that can be called to return a block from the blocks collection
	*/
	function hideFace(x, y, z, blocks, type, func, sourceDir, dir) {
		let block = func.call(world, x, y, z, blocks)
		if (!block) {
			return 1
		}

		let data = blockData[block]
		let sourceData = blockData[type]

		let sourceRange = 3
		let hiderRange = 3
		if (func !== getBlock || screen === "loading") {
			// getBlock is only used during the optimize phase of worldGen
			sourceRange = sourceData.shape.cull[sourceDir]
			hiderRange = data.shape.cull[dir]
		}

		if ((sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent || data.transparent && data.shadow) {
			return 1
		}
		return 0
	}
	let getShadows = {
		shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
		ret: [],
		blocks: [],
		top: function(x, y, z, block) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y-1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y-1, z+1, block)].shadow

			ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.75
			ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.75
			ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.75
			ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.75
			return ret
		},
		bottom: function(x, y, z, block) { // Actually the top
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[4] = blockData[getBlock(x, y+1, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
			ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
			return ret
		},
		north: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[1] = blockData[getBlock(x, y-1, z+1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z+1, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			return ret
		},
		south: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x, y-1, z-1, block)].shadow
			blocks[4] = blockData[getBlock(x, y, z-1, block)].shadow
			blocks[5] = blockData[getBlock(x, y+1, z-1, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z-1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
			return ret
		},
		east: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x+1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x+1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x+1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x+1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
			ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
			return ret
		},
		west: function(x, y, z, block) {
			let blocks = this.blocks
			let ret = this.ret
			blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
			blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
			blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
			blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
			blocks[4] = blockData[getBlock(x-1, y, z, block)].shadow
			blocks[5] = blockData[getBlock(x-1, y+1, z, block)].shadow
			blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
			blocks[7] = blockData[getBlock(x-1, y, z+1, block)].shadow
			blocks[8] = blockData[getBlock(x-1, y+1, z+1, block)].shadow

			ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8
			ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8
			ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8
			ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
			return ret
		},
	}
	
	function average(l, a, b, c, d) {
		a = l[a]
		b = l[b]
		c = l[c]
		d = l[d]
		let count = 1
		let zero = 0
		let total = a
		if (b && abs(a-b) <= 2) {
			total += b
			count++
		} else zero++
		if (c && abs(a-c) <= 2) {
			total += c
			count++
		} else zero++
		if (d && abs(a-d) <= 2) {
			total += d
			count++
		} else zero++

		let mx = max(a, b, c, d)
		if (mx > 2) {
			return total / (count * 15)
		}
		if (mx > 1) {
			return zero ? total / (count * 15 + 15) : total / (count * 15)
		}
		return (total) / 60
	}
	let getLight = {
		blocks: [],
		top: function(x, y, z, block, ret, blockLight = 0) { // Actually the bottom... How did these get flipped?
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 0, 1, 3)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 5, 7, 8)
			ret[3] = average(blocks, 4, 3, 6, 7)
			// debugger
			return ret
		},
		bottom: function(x, y, z, block, ret, blockLight = 0) { // Actually the top
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 3, 6, 7)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 1, 2, 5)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		north: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 3, 6, 7)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 1, 2, 5)
			return ret
		},
		south: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		east: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x+1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 1, 2, 5)
			ret[1] = average(blocks, 4, 5, 7, 8)
			ret[2] = average(blocks, 4, 3, 6, 7)
			ret[3] = average(blocks, 4, 0, 1, 3)
			return ret
		},
		west: function(x, y, z, block, ret, blockLight = 0) {
			let blocks = this.blocks
			blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[4] = (getBlock(x-1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[5] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[7] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
			blocks[8] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4

			ret[0] = average(blocks, 4, 5, 7, 8)
			ret[1] = average(blocks, 4, 1, 2, 5)
			ret[2] = average(blocks, 4, 0, 1, 3)
			ret[3] = average(blocks, 4, 3, 6, 7)
			return ret
		},
	}

	/*
	function interpolateShadows(shadows, x, y) {
		let sx = (shadows[1] - shadows[0]) * x + shadows[0]
		let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
		return (sx2 - sx) * y + sx
	}
	*/
  
class Generator {
    constructor() {
        this.seedSet = false;
        this.seed = 0;
        this.size = 600;
        this.diagonalNeighbors = true; //true if the corners are also adjacent
        
        this.grid = [];
        this.vertex = [];
        this.river = [];
        this.precip = [];
        this.biome = [];
        this.biomeBlend = [];
        
        this.highestPoint = [0,0];
        
        this.updates = [];
        this.stage = 0;
        this.changes = 0;
        this.rivers = 0;
        this.h = 0;
        this.X = 0;
    }
    GetVertex(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
        return this.vertex[x+y*this.size];
    }
    GetHeight(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
        return Math.round(
        (this.GetVertex(Math.floor(x), Math.floor(y))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
        this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
        this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
    };
    GetWater(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
        return Math.sqrt(this.river[x+y*this.size]);
    }
    GetWaterDepth(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        var w = 0;
        for (let x2 = 0; x2 < 1; x2+=0.5) {
            for (let y2 = 0; y2 < 1; y2+=0.5) {
                w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
            }
        }
        w = w/4.0;
        if (w > 0.25) {
            return 1;
        }   else {
            return 0;
        }
    }
    GetBiome(x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
        return this.biome[x+y*this.size];
    }
    GetBiomeType(x, y) {
        x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
        return this.GetBiome(Math.floor(x),Math.floor(y));
    }
    GetNeighbors(x, y) {
        var n = [];
        if (x > 0) {
            n.push({x:x-1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x-1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x-1, y:y+1});
            }}
        }
        if (x < this.size-1) {
            n.push({x:x+1, y:y});
            if (this.diagonalNeighbors) {
            if (y > 0) {
                n.push({x:x+1, y:y-1});
            }
            if (y < this.size-1) {
                n.push({x:x+1, y:y+1});
            }
            }
        }
        if (y > 0) {
            n.push({x:x, y:y-1});
        }
        if (y < this.size-1) {
            n.push({x:x, y:y+1});
        }
        return n;
    }
    GetDown(x, y) {
        var n = this.GetNeighbors(x, y);
        var l = this.size;
        var ld = [];
        for (var i in n) {
            if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
                if (this.vertex[n[i].x + n[i].y*this.size] === l) {
                    ld.push(n[i]);
                }
                l = this.vertex[n[i].x + n[i].y*this.size];
                ld = [n[i]];
            }
        }
        if (l <= this.vertex[x + y*this.size]) {
            return ld[Math.floor(random(ld.length))];
        }
        return undefined;
    }
    SetSeed(seed) {
        this.seed = seed;
        this.seedSet = true;
        randomSeed(hash(seed, 2123155232) * 210000000)
    }
    Generate(start) {
        var end = start+16;
        var nS = 0.021;
        function sq(n) {return n*n}
        function color(r, g, b, a) {
            a = (a === undefined ? 255 : a);
            g = (g === undefined ? r : g);
            b = (b === undefined ? g : b);
            if (a > 127) {a = -256+a;}
            return b+g*256+r*65536+a*16777216;
        }
        if (this.stage === 0) { //landmass
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.grid[x +y*this.size] = 0;
                    this.vertex[x + y*this.size] = -1;
                    this.precip[x + y*this.size] = -1;
                    this.river[x + y*this.size] = 0;
                    var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
                    var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
                    var v = noise(x*nS, y*nS, this.seed);
                    if (v*islandMask > 0.3) {
                        this.grid[x+y*this.size] = 1;
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.updates.push({type:"ocean", x:0, y:0});
            }
        }   else if (this.stage === 1) {    //Oceans
            while (this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates.shift();
                if (this.grid[u.x+u.y*this.size] === 0) {
                    this.grid[u.x+u.y*this.size] = 2;
                    var n = this.GetNeighbors(u.x, u.y);
                    for (var i = 0; i < n.length; i++) {
                        if (this.grid[n[i].x+n[i].y*this.size] === 0) {
                            this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
                        }
                    }
                }
            }
            if (this.updates.length === 0) {
                this.X = this.size;
            }
        }   else if (this.stage === 2) {    //altitude
            if (this.h === -1) {this.h = 0;}
            var doingLake = false;
            var I = 0;
            while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
                if (this.updates[I].type === "lake") {
                    var u = this.updates.splice(I, 1)[0];
                    if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
                        this.vertex[u.x + u.y*this.size] = u.a;
                        var n = this.GetNeighbors(u.x, u.y);
                        for (var i in n) {
                            if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
                                this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
                            }
                        }
                    }
                    I--;
                }
                I++;
            }
            while (this.X < this.size && win.performance.now() < end && !doingLake) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x+y*this.size] === -1) {
                        if (this.grid[x+y*this.size] === 2) {
                            this.vertex[x+y*this.size] = this.h;
                            this.changes++;
                        }   else if (this.h > 0) {
                            var n = this.GetNeighbors(x, y);
                            var l = this.size;
                            var ld;
                            for (var i in n) {
                                var v = this.vertex[n[i].x + n[i].y*this.size];
                                if (v < l && v !== -1) {
                                    l = v;
                                    ld = n[i];
                                }
                            }
                            if (l !== this.size && l <= this.h) {
                                if (this.grid[x+y*this.size] === 0) {
                                    this.updates.push({type:"river",x:ld.x,y:ld.y});
                                    this.updates.push({type:"lake",x:x,y:y,a:l});
                                }   else {
                                    this.vertex[x+y*this.size] = l+1+(random() > 0.5 ? 1 : 0);
                                }
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size && this.h < this.size/3) {
                if (this.changes === 0) {
                    this.h++;
                }
                this.X = 0;
                this.changes = 0;
            }
        }   else if (this.stage === 3) {    //altitude readjustment
            
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
                    if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
                        this.highestPoint[0] = x;
                        this.highestPoint[1] = y;
                    }
                }
                this.X++;
            }
            
        }   else if (this.stage === 4) {    //rivers
            if (this.rivers === 0) {
                var x, y;
                for (var i = 0; i < 200 && this.rivers < 100; i++) {
                    x = Math.floor(random(this.size));
                    y = Math.floor(random(this.size));
                    if (this.grid[x+y*this.size] === 1) {
                        this.updates.push({type:"river",x:x,y:y});
                        this.rivers++;
                    }
                }
            }   else {
                if (this.updates.length === 0) {
                    this.X = this.size;
                }
            }
            while(this.updates.length > 0 && win.performance.now() < end) {
                var u = this.updates[0];
                if (this.grid[u.x+u.y*this.size] === 1) {
                    this.river[u.x+u.y*this.size]++;
                    var d = this.GetDown(u.x, u.y);
                    if (d === undefined) {
                        this.updates.shift();
                    }   else {
                        this.updates[0].x = d.x; this.updates[0].y = d.y;
                    }
                }   else {
                    this.updates.shift();
                }
            }
        }   else if (this.stage === 5) {    //precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.precip[x + y*this.size] === -1) {
                        if (this.h === -1) {
                            if (this.grid[x + y*this.size] === 2) {
                                this.precip[x + y*this.size] = 5;
                                this.changes++;
                            }
                        }   else {
                            if (this.h <= 8) {
                                if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
                                    this.precip[x + y*this.size] = 8;
                                    this.changes++;
                                }
                            }
                            var n = this.GetNeighbors(x, y);
                            var h = -1;
                            for (var i in n) {
                                if (this.precip[n[i].x + n[i].y*this.size] > h) {
                                    h = this.precip[n[i].x + n[i].y*this.size];
                                }
                            }
                            if (h > -1 && h >= this.h) {
                                this.precip[x+y*this.size] = Math.max(h - (random() < 0.5 ? 0.66 : 0.33), 0);
                                this.changes++;
                            }
                        }
                    }
                }
                this.X++;
            }
            if (this.X === this.size) {
                this.X = 0;
                if (this.h === -1) {
                    this.h = 10;
                }   else {
                    if (this.changes === 0) {
                        this.h--;
                    }
                    this.changes = 0;
                    if (this.h < 0) {
                        this.X = this.size;
                    }
                }
            }
        }   else if (this.stage === 6) {    //readjust precipitation
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
                }
                this.X++;
            }
        }   else if (this.stage === 7) {    //temperature
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                }
                this.X++;
            }
        }   else if (this.stage === 8) {    //biomes
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    var c;
                    var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
                    switch (this.grid[x+y*this.size]) {
                        case 0: if (h > 2) {
                                c = color(157, 194, 201);
                            }   else {
                                c = color(25, 153, 227);
                            }   break;
                        case 1: if (this.river[x+y*this.size] > 0) {
                                    if (h > 2) {
                                    c = color(157, 194, 201);
                                }   else {
                                    c = color(25, 153, 227);
                                }
                            }   else {
                                switch (h) {
                                    case 0: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(10, 133, 72); break;
                                        case 3: case 2: c = color(10, 133, 23); break;
                                        case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(209, 166, 58); break;
                                    } break;
                                    case 1: switch (this.precip[x+y*this.size]) {
                                        case 5: c = color(14, 156, 85); break;
                                        case 4: case 3: c = color(72, 133, 10); break;
                                        case 2: case 1: c = color(179, 232, 35); break;
                                        case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 2: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: c = color(121, 191, 95); break;
                                        case 3: case 2: c = color(155, 161, 135); break;
                                        case 1: case 0: c = color(207, 195, 58); break;
                                    } break;
                                    case 3: case 4: switch (this.precip[x+y*this.size]) {
                                        case 5: case 4: case 3: c = color(255); break;
                                        case 2: c = color(149, 189, 94); break;
                                        case 1: c = color(180); break;
                                        case 0: c = color(128);
                                    } break;
                                }
                            }
                            break;
                        case 2: c = color(4, 137, 209); break;
                    }
                    this.biome[x+y*this.size] = c;
                }
                this.X++;
            }
        }   else if (this.stage === 9) {    //add lava
            let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
            while (this.X < this.size && win.performance.now() < end) {
                var x = this.X;
                for (var y = 0; y < this.size; y++) {
                    if (this.vertex[x + y*this.size] > ph) {
                        this.vertex[x + y*this.size] = ph-2;
                        this.biome[x + y*this.size] = -65536;
                    }
                }
                this.X++;
            }
        }
        if (this.X === this.size) {
            console.log(this.stage)
            this.X = 0;
            this.h = -1;
            this.stage++;
        }
    }
}

	class Section {
		constructor(x, y, z, size, chunk) {
			this.x = x
			this.y = y
			this.z = z
			this.size = size
			this.arraySize = size * size * size
			this.blocks = new Int32Array(this.arraySize)
			this.light = new Uint8Array(this.arraySize)
			this.renderData = []
			this.renderLength = 0
			this.faces = 0
			this.hasVisibleBlocks = false
			this.chunk = chunk
			this.edited = false
			this.caves = !caves
			this.pallete = [0]
			this.palleteMap = {"0": 0}
			this.palleteSize = 0
		}
		getBlock(x, y, z) {
			let s = this.size
			return this.blocks[x * s * s + y * s + z]
		}
		setBlock(x, y, z, blockId) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = blockId
		}
		deleteBlock(x, y, z) {
			let s = this.size
			this.blocks[x * s * s + y * s + z] = 0
		}
		optimize() {
			let visible = false
			let pos = 0
			let xx = this.x
			let yy = this.y
			let zz = this.z
			let blockState = 0
			let palleteIndex = 0
			let index = 0
			let s = this.size
			let blocks = this.blocks
			this.hasVisibleBlocks = false
			this.renderLength = 0
			let localBlocks = world.getAdjacentSubchunks(xx, yy, zz)

			//Check all the blocks in the subchunk to see if they're visible.
			for (let i = 0; i < s; i++) {
				for (let j = 0; j < s; j++) {
					for (let k = 0; k < s; k++, index++) {
						blockState = blocks[index]

						if (this.palleteMap[blockState] === undefined) {
							this.palleteMap[blockState] = this.pallete.length
							palleteIndex = this.pallete.length
							this.pallete.push(blockState)
						} else {
							palleteIndex = this.palleteMap[blockState]
						}

						visible = blockState && (hideFace(i-1, j, k, localBlocks, blockState, getBlock, "west", "east")
						| hideFace(i+1, j, k, localBlocks, blockState, getBlock, "east", "west") << 1
						| hideFace(i, j-1, k, localBlocks, blockState, getBlock, "bottom", "top") << 2
						| hideFace(i, j+1, k, localBlocks, blockState, getBlock, "top", "bottom") << 3
						| hideFace(i, j, k-1, localBlocks, blockState, getBlock, "south", "north") << 4
						| hideFace(i, j, k+1, localBlocks, blockState, getBlock, "north", "south") << 5)
						if (visible) {
							pos = (i | j << 4 | k << 8) << 19
							this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
							this.hasVisibleBlocks = true
						}
					}
				}
			}
		}
		updateBlock(x, y, z, world, leaveMe) {
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk)
			}
			let i = x
			let j = y
			let k = z
			let s = this.size
			x += this.x
			y += this.y
			z += this.z
			let blockState = this.blocks[i * s * s + j * s + k]
			let visible = blockState && (hideFace(x-1, y, z, 0, blockState, world.getBlock, "west", "east")
			| hideFace(x+1, y, z, 0, blockState, world.getBlock, "east", "west") << 1
			| hideFace(x, y-1, z, 0, blockState, world.getBlock, "bottom", "top") << 2
			| hideFace(x, y+1, z, 0, blockState, world.getBlock, "top", "bottom") << 3
			| hideFace(x, y, z-1, 0, blockState, world.getBlock, "south", "north") << 4
			| hideFace(x, y, z+1, 0, blockState, world.getBlock, "north", "south") << 5)
			let pos = (i | j << 4 | k << 8) << 19
			let index = -1

			// Find index of current block in this.renderData
			for (let i = 0; i < this.renderLength; i++) {
				if ((this.renderData[i] & 0x7ff80000) === pos) {
					index = i
					break
				}
			}

			// Update pallete
			if (this.palleteMap[blockState] === undefined) {
				this.palleteMap[blockState] = this.pallete.length
				this.pallete.push(blockState)
			}

			if (index < 0 && !visible) {
				// Wasn't visible before, isn't visible after.
				return
			}
			if (!visible) {
				// Was visible before, isn't visible after.
				this.renderData.splice(index, 1)
				this.renderLength--
				this.hasVisibleBlocks = !!this.renderLength
				return
			}
			if (visible && index < 0) {
				// Wasn't visible before, is visible after.
				index = this.renderLength++
				this.hasVisibleBlocks = true
			}
			this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
      
      var block = world.getBlock(x,y,z)
      if(!leaveMe && blockData[block]) blockData[block].onupdate(x,y,z,block);
		}
		genMesh(barray, index) {
			if (!this.renderLength) {
				return index
			}
			let length = this.renderLength
			let rData = this.renderData
			let x = 0, y = 0, z = 0, loc = 0, data = 0,
				sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
				verts = null, texVerts = null, texShapeVerts = null,
				tx = 0, ty = 0
			let wx = this.x, wy = this.y, wz = this.z
			let blocks = world.getAdjacentSubchunks(wx, wy, wz)
			let lightChunks = world.getAdjacentSubchunks(wx, wy, wz, true)
			let block = null

			let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0]
			let blockSides = Object.keys(Block)
			let side = ""
			let shapeVerts = null
			let shapeTexVerts = null
			let pallete = this.pallete
			// let intShad = interpolateShadows
			
			for (let i = 0; i < length; i++) {
				data = rData[i]
				block = blockData[pallete[data & 0x1fff]]
				tex = block.textures
				sides = data >> 13 & 0x3f
				loc = data >> 19 & 0xfff
				x = loc & 15
				y = loc >> 4 & 15
				z = loc >> 8 & 15

				x2 = x + this.x
				y2 = y + this.y
				z2 = z + this.z

				shapeVerts = block.shape.verts
				shapeTexVerts = block.shape.texVerts

				let texNum = 0
				for (let n = 0; n < 6; n++) {
					side = blockSides[n]
					if (sides & Block[side]) {
						shadows = getShadows[side](x, y, z, blocks)
						slights = getLight[side](x, y, z, lightChunks, slights, 0)
						blights = getLight[side](x, y, z, lightChunks, blights, 1)
						let directionalFaces = shapeVerts[Sides[side]]
						for (let facei = 0; facei < directionalFaces.length; facei++) {
							verts = directionalFaces[facei]
							texVerts = textureCoords[textureMap[tex[texNum]]]
							tx = texVerts[0]
							ty = texVerts[1]
							texShapeVerts = shapeTexVerts[n][facei]

							barray[index] = verts[0] + x2
							barray[index+1] = verts[1] + y2
							barray[index+2] = verts[2] + z2
							barray[index+3] = tx + texShapeVerts[0]
							barray[index+4] = ty + texShapeVerts[1]
							barray[index+5] = shadows[0]
							barray[index+6] = slights[0]
							barray[index+7] = blights[0]

							barray[index+8] = verts[3] + x2
							barray[index+9] = verts[4] + y2
							barray[index+10] = verts[5] + z2
							barray[index+11] = tx + texShapeVerts[2]
							barray[index+12] = ty + texShapeVerts[3]
							barray[index+13] = shadows[1]
							barray[index+14] = slights[1]
							barray[index+15] = blights[1]

							barray[index+16] = verts[6] + x2
							barray[index+17] = verts[7] + y2
							barray[index+18] = verts[8] + z2
							barray[index+19] = tx + texShapeVerts[4]
							barray[index+20] = ty + texShapeVerts[5]
							barray[index+21] = shadows[2]
							barray[index+22] = slights[2]
							barray[index+23] = blights[2]

							barray[index+24] = verts[9] + x2
							barray[index+25] = verts[10] + y2
							barray[index+26] = verts[11] + z2
							barray[index+27] = tx + texShapeVerts[6]
							barray[index+28] = ty + texShapeVerts[7]
							barray[index+29] = shadows[3]
							barray[index+30] = slights[3]
							barray[index+31] = blights[3]
							index += 32
						}
					}
					texNum++
				}
			}
			return index
		}
		carveCaves() {
			let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
			for (let x = this.x, xx = 0; x < wx; x++, xx++) {
				for (let z = this.z, zz = 0; z < wz; z++, zz++) {
					wy = this.chunk.tops[zz * 16 + xx]
					for (let y = this.y; y < wy; y++) {
						if (isCave(x, y, z)) {
							carveSphere(x, y, z)
						}
					}
				}
			}
			this.caves = true
		}
		tick() {
			for (let i = 0; i < 3; i++) {
				let rnd = Math.random() * this.blocks.length | 0
				if ((this.blocks[rnd]) === blockIds.grass) {
					// Spread grass

					let x = (rnd >> 8) + this.x
					let y = (rnd >> 4 & 15) + this.y
					let z = (rnd & 15) + this.z
					if (!blockData[world.getBlock(x, y + 1, z)].transparent) {
						world.setBlock(x, y, z, blockIds.dirt, false)
						return
					}

					let rnd2 = Math.random() * 27 | 0
					let x2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - x2 - 1) / 3
					let y2 = rnd2 % 3 - 1
					rnd2 = (rnd2 - y2 - 1) / 3
					z += rnd2 - 1
					x += x2
					y += y2

					if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
						world.setBlock(x, y, z, blockIds.grass, false)
					}
				} else if (this.blocks[rnd] === (blockIds.oakSapling | CROSS)){
          let i = (rnd >> 8) + this.x;      let wx = i
					let j = (rnd >> 4 & 15) + this.y; let wy = j
					let k = (rnd & 15) + this.z;      let wz = k
          var ground = j//this.chunk.tops[i * 16 + k]
          var top = ground + floor(4.5 + (Math.random()*2.5) )
          var rand = floor(Math.random()*4096)
          let tree = blockIds.oakLog
          let leaf = blockIds.leaves
          let groundBlock = blockIds.dirt

          //Center
          for (let j = ground + 1; j <= top; j++) {
            world.setBlock(i, j, k, tree)
          }
          world.setBlock(i, top + 1, k, leaf)
          world.setBlock(i, ground, k, groundBlock)

          //Bottom leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 2, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              }
            }
          }

          //2nd layer leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 1, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
          }

          //3rd layer leaves
          for (let x = -1; x <= 1; x++) {
            for (let z = -1; z <= 1; z++) {
              if (x || z) {
                if (x & z) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
          }

          //Top leaves
          world.setBlock(wx + 1, top + 1, wz, leaf)
          world.setBlock(wx, top + 1, wz - 1, leaf)
          world.setBlock(wx, top + 1, wz + 1, leaf)
          world.setBlock(wx - 1, top + 1, wz, leaf)
        }else if (this.blocks[rnd] === (blockIds.birchSapling | CROSS)){
          let i = (rnd >> 8) + this.x;      let wx = i
					let j = (rnd >> 4 & 15) + this.y; let wy = j
					let k = (rnd & 15) + this.z;      let wz = k
          var ground = j//this.chunk.tops[i * 16 + k]
          var top = ground + floor(4.5 + (Math.random()*2.5) )
          var rand = floor(Math.random()*4096)
          let tree = blockIds.birchLog
          let leaf = blockIds.leaves
          let groundBlock = blockIds.dirt

          //Center
          for (let j = ground + 1; j <= top; j++) {
            world.setBlock(i, j, k, tree)
          }
          world.setBlock(i, top + 1, k, leaf)
          world.setBlock(i, ground, k, groundBlock)

          //Bottom leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 2, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 2, wz + z, leaf)
                }
              }
            }
          }

          //2nd layer leaves
          for (let x = -2; x <= 2; x++) {
            for (let z = -2; z <= 2; z++) {
              if (x || z) {
                if ((x * z & 7) === 4) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top - 1, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
          }

          //3rd layer leaves
          for (let x = -1; x <= 1; x++) {
            for (let z = -1; z <= 1; z++) {
              if (x || z) {
                if (x & z) {
                  place = rand & 1
                  rand >>>= 1
                  if (place) {
                    world.setBlock(wx + x, top, wz + z, leaf)
                  }
                } else {
                  world.setBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
          }

          //Top leaves
          world.setBlock(wx + 1, top + 1, wz, leaf)
          world.setBlock(wx, top + 1, wz - 1, leaf)
          world.setBlock(wx, top + 1, wz + 1, leaf)
          world.setBlock(wx - 1, top + 1, wz, leaf)
        }
			}
		}
		getLight(x, y, z, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			return (this.light[i] & 15 << (block * 4)) >> (block * 4)
		}
		setLight(x, y, z, level, block = 0) {
			let s = this.size
			let i = x * s * s + y * s + z
			this.light[i] = level << (block * 4) | (this.light[i] & 15 << (!block * 4))
		}
	}
	let emptySection = new Section(0, 0, 0, 16)
	let fullSection = new Section(0, 0, 0, 16)
	fullSection.blocks.fill(blockIds.bedrock)
	emptySection.light.fill(15)

	class Chunk {
		constructor(x, z, type) {
			this.x = x
			this.z = z
			this.maxY = 0
			this.minY = 255
			this.sections = []
			this.cleanSections = []
			this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
      this.ceils = new Uint8Array(16 * 16) //for nether
			this.optimized = false
			this.generated = false; // Terrain
			this.populated = superflat === true // Trees and ores
			this.lit = false
			this.lazy = false
			this.edited = false
			this.loaded = false
      this.type = type || world.type
			// vao for this chunk
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			this.caves = !caves
		}
		getBlock(x, y, z) {
			let s = y >> 4
			return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0
		}
		setBlock(x, y, z, blockID, user) {
			if (!this.sections[y >> 4]) {
				do {
					this.sections.push(new Section(this.x, this.sections.length * 16, this.z, 16, this))
				} while (!this.sections[y >> 4])
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
			this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
		}
		fillLight() {
			let max = this.sections.length * 16 - 1
			let blockSpread = []

			// Set virtical columns of light to level 15
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					let stop = false
					for (let y = max; y >= 0; y--) {
						let data = blockData[this.getBlock(x, y, z)]
						if (data.lightLevel) {
							if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
							blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
							this.setLight(x, y, z, data.lightLevel, 1)
						}
						if (!stop && !data.transparent) {
							this.tops[z * 16 + x] = y
							stop = true
						} else if (!stop) {
							this.setLight(x, y, z, 15, 0)
						}
					}
				}
			}

			// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
			let spread = []
			for (let x = 0; x < 16; x++) {
				for (let z = 0; z < 16; z++) {
					for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
						if (x === 15 || this.tops[z * 16 + x + 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (x === 0 || this.tops[z * 16 + x - 1] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 15 || this.tops[(z + 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						if (z === 0 || this.tops[(z - 1) * 16 + x] > y) {
							spread.push(x + this.x, y, z + this.z)
							continue
						}
						break
					}
				}
			}
			this.spreadLight(spread, 14)

			for (let i = blockSpread.length - 1; i > 0; i--) {
				let blocks = blockSpread[i]
				if (blocks && blocks.length) {
					this.spreadLight(blocks, i - 1, false, 1)
				}
			}

			this.lit = true
		}
		setLight(x, y, z, level, blockLight) {
			this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
		}
		getLight(x, y, z, blockLight = 0) {
			if (y >= this.sections.length * 16) return 15
      if(!this.sections[y >> 4]) return 0
			return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
		}
		trySpread(x, y, z, level, spread, blockLight, update = false) {
			if (world.getLight(x, y, z, blockLight) < level) {
				if (blockData[world.getBlock(x, y, z)].transparent) {
					world.setLight(x, y, z, level, blockLight)
					spread.push(x, y, z)
				}
			}
			if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		spreadLight(blocks, level, update = false, blockLight = 0) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
				this.trySpread(x - 1, y, z, level, spread, blockLight, update)
				this.trySpread(x + 1, y, z, level, spread, blockLight, update)
				this.trySpread(x, y - 1, z, level, spread, blockLight, update)
				this.trySpread(x, y + 1, z, level, spread, blockLight, update)
				this.trySpread(x, y, z - 1, level, spread, blockLight, update)
				this.trySpread(x, y, z + 1, level, spread, blockLight, update)
			}
			if (level > 1 && spread.length) {
				this.spreadLight(spread, level - 1, update, blockLight)
			}
		}
		tryUnSpread(x, y, z, level, spread, respread, blockLight) {
			let light = world.getLight(x, y, z, blockLight)
			let trans = blockData[world.getBlock(x, y, z)].transparent
			if (light === level) {
				if (trans) {
					world.setLight(x, y, z, 0, blockLight)
					spread.push(x, y, z)
				}
			} else if (light > level) {
				respread[light].push(x, y, z)
			}
			if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
				let chunk = world.getChunk(x, z)
				if (chunk.buffer && !world.meshQueue.includes(chunk)) {
					world.meshQueue.push(chunk)
				}
			}
		}
		unSpreadLight(blocks, level, respread, blockLight) {
			let spread = []
			let x = 0, y = 0, z = 0
			for (let i = 0; i < blocks.length; i += 3) {
				x = blocks[i]
				y = blocks[i+1]
				z = blocks[i+2]
				this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
				this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
			}
			if (level > 1 && spread.length) {
				this.unSpreadLight(spread, level - 1, respread, blockLight)
			}
		}
		reSpreadLight(respread, blockLight) {
			for (let i = respread.length - 1; i > 1; i--) {
				let blocks = respread[i]
				let level = i - 1
				let spread = respread[level]
				for (let j = 0; j < blocks.length; j += 3) {
					let x = blocks[j]
					let y = blocks[j+1]
					let z = blocks[j+2]
					this.trySpread(x - 1, y, z, level, spread, blockLight)
					this.trySpread(x + 1, y, z, level, spread, blockLight)
					this.trySpread(x, y - 1, z, level, spread, blockLight)
					this.trySpread(x, y + 1, z, level, spread, blockLight)
					this.trySpread(x, y, z - 1, level, spread, blockLight)
					this.trySpread(x, y, z + 1, level, spread, blockLight)
				}
			}
		}
		optimize() {
			for (let i = 0; i < this.sections.length; i++) {
				this.sections[i].optimize()
			}
			if (!world.meshQueue.includes(this)) {
				world.meshQueue.push(this)
			}
			this.optimized = true
		}
		render() {
			if (!this.buffer) {
				return
			}
			if (p.canSee(this.x, this.minY, this.z, this.maxY)) {
				renderedChunks++
				glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
				gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
				glExtensions.vertex_array_object.bindVertexArrayOES(null)
			}
		}
		updateBlock(x, y, z, world, lazy, leaveMe) {
			if (this.buffer) {
				this.lazy = lazy
				if (this.sections.length > y >> 4) {
					this.sections[y >> 4].updateBlock(x, y & 15, z, world, leaveMe)
				}
			}
		}
		deleteBlock(x, y, z, user) {
			if (!this.sections[y >> 4]) {
				return
			}
			if (user && !this.sections[y >> 4].edited) {
				this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
				this.sections[y >> 4].edited = true
				this.edited = true
			}
			this.sections[y >> 4].deleteBlock(x, y & 15, z)
			this.minY = y < this.minY ? y : this.minY
			this.maxY = y > this.maxY ? y : this.maxY
		}
		carveCaves() {
			for (let i = 0; i < this.sections.length; i++) {
				if (!this.sections[i].caves) {
					this.sections[i].carveCaves()
					if (i + 1 >= this.sections.length) {
						this.caves = true
					}
					return
				}
			}
		}
		populate() {
      var flowers = [blockIds.flowerOftheValley, blockIds.poppy, blockIds.dandelion, 
                     blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
                     blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
                     blockIds.allium, blockIds.oxeyeDaisy,
                     blockIds.lilac, blockIds.roseBush, blockIds.peony,
                     blockIds.TallGrass]
      
			randomSeed(hash(this.x, this.z) * 210000000)
			let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false, topsi = 0, tall = 0
      let trueX = this.x, trueY = this.y, trueZ = this.z
      let smoothness = generator.smooth, hilliness = generator.height
      let biomeSmooth = generator.biomeSmooth;
			let biome = 0
      let type = world.type

			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					wx = this.x + i
					wz = this.z + k

					ground = this.tops[k * 16 + i]
          biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
          var b
          if(superflat){b = "field"}else b = getBiome(biome)

          let nb = getNetherBiome(biome)
					if (trees && random() < 0.07 && type === "" && b === "field" && world.getBlock(i, ground, k) === blockIds.grass) {
            top = ground + floor(4.5 + random(2.5))
						rand = floor(random(4096))
						let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
            let leaf = blockIds.leaves
            let groundBlock = blockIds.dirt

						//Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)

						//Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
									}
								}
							}
						}

						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
									}
								}
							}
						}

						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
					}
          
          // Cactus
          if (random() < 0.01 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
            top = ground + Math.floor(2.5 + random(1.5));
            rand = Math.floor(random(4096));
            let tree = blockIds.cactus | CACTUS;

            //Center
            for (let j = ground + 1; j <= top; j++) {
              this.setBlock(i, j, k, tree);
            }
            this.setBlock(i, ground, k, blockIds.sand);
          }
          if (random() < 0.006 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
            let tree = blockIds.deadBush | CROSS;
            this.setBlock(i,ground+1,k, tree);
            this.setBlock(i, ground, k, blockIds.sand);
          }
          
          // Jungle trees
          if(trees && random() < 0.01 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
            tall = floor(5 + random(5)) //5 to 10
            top = ground + tall
            let tree = blockIds.jungleLog
            let leaf = blockIds.leaves
            
            //Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, blockIds.dirt)
            
            //Bottom leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 2, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 2, wz + z, leaf)
									}
								}
							}
						}

						//2nd layer leaves
						for (let x = -2; x <= 2; x++) {
							for (let z = -2; z <= 2; z++) {
								if (x || z) {
									if ((x * z & 7) === 4) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top - 1, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top - 1, wz + z, leaf)
									}
								}
							}
						}

						//3rd layer leaves
						for (let x = -1; x <= 1; x++) {
							for (let z = -1; z <= 1; z++) {
								if (x || z) {
									if (x & z) {
										place = rand & 1
										rand >>>= 1
										if (place) {
											world.spawnBlock(wx + x, top, wz + z, leaf)
										}
									} else {
										world.spawnBlock(wx + x, top, wz + z, leaf)
									}
								}
							}
						}

						//Top leaves
						world.spawnBlock(wx + 1, top + 1, wz, leaf)
						world.spawnBlock(wx, top + 1, wz - 1, leaf)
						world.spawnBlock(wx, top + 1, wz + 1, leaf)
						world.spawnBlock(wx - 1, top + 1, wz, leaf)
          }//end jungle trees
          //Giant jungle trees
          if(trees && random() < 0.01 && type === "" && b === "giantJungle" && world.getBlock(i, ground, k)){
            tall = floor(10 + random(20)) //10 to 30
            top = ground + tall
            let tree = blockIds.jungleLog
            let leaf = blockIds.leaves
                  
            //Center
            for (let j = ground + 1; j < top; j++) {
              this.setBlock(i, j, k, tree)
              world.spawnBlock(wx + 1, j, wz, tree)
              world.spawnBlock(wx, j, wz + 1, tree)
              world.spawnBlock(wx+1, j, wz+1, tree)
            }
            this.setBlock(i, ground, k, blockIds.dirt)
            world.setBlock(wx + 1, ground, wz, blockIds.dirt)
            world.setBlock(wx, ground, wz + 1, blockIds.dirt)
            world.setBlock(wx+1, ground, wz+1, blockIds.dirt)

            //Messy part
            //leaves
            let w2 = 5 * 5
            let d2 = 5 * 5
            let h2 = 5 * 5
            for(var x=-4.5; x<4.5; x++){
              for(var y=2; y<4.5; y++){
                for(var z=-4.5; z<4.5; z++){
                  let n = x * x / w2 + y * y / h2 + z * z / d2
                  if (n < 1) {
                    world.spawnBlock(wx + x+1, top-4+y, wz + z+1, leaf)
                  }
                }
              }
            }

            //the diagonal branches
            w2 = 3 * 3
            d2 = 3 * 3
            h2 = 3 * 3
            for(y=ground+5; y<top; y += Math.floor(random(10))){
              let side = Math.floor(random(4))
              let mx=0,mz=0
              switch(side){
                case 0:
                  mx=1
                  break
                case 1:
                  mx=-1
                  break
                case 2:
                  mz=1
                  break
                case 3:
                  mz=-1
                  break
              }
              let x = mx === 1?2:mx, z = mz === 1?2:mz
              var rnd = Math.floor(random(4))+2
              //branch
              for(var by=0; by<rnd; by++){
                world.setBlock(wx+x, y+by, wz+z, tree)
                x += mx
                z += mz
              }
              x -= mx
              z -= mz
              by -= 1

              //leaves
              for(var lx=-3; lx<3; lx++){
                for(var ly=1; ly<3; ly++){
                  for(var lz=-3; lz<3; lz++){
                    let n = lx * lx / w2 + ly * ly / h2 + lz * lz / d2
                    if (n < 1) {
                      world.spawnBlock(wx+x + lx, y+by+ly, wz+z + lz, leaf)
                    }
                  }
                }
              }
              // m = move; l = leaf
            }
          }//end giant jungle trees; jungle bushes
          if(trees && random() < 0.007 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
            let w2 = 3 * 3
            let d2 = 3 * 3
            let h2 = 3 * 3
            for(var x=-3; x<3; x++){
              for(var y=1; y<3; y++){
                for(var z=-3; z<3; z++){
                  let n = x * x / w2 + y * y / h2 + z * z / d2
                  if (n < 1) {
                    world.spawnBlock(wx+x, ground+y, wz+z, blockIds.leaves)
                  }
                }
              }
            }
            this.setBlock(i, ground+1, k, blockIds.jungleLog)
          }
          
          if (random() < 0.005 && type === "nether" && ground > 79 && nb !== 0){
            tall = floor(4.5 + random(2.5))
            if(floor(random(12)) === 1) tall *= 2
						top = ground + tall
						rand = floor(random(4096))
            let tree
            let leaf
            let groundBlock = blockIds.netherrack
            if(this.type === "nether"){
              if(nb === 1){
                tree = blockIds.warpedStem
                leaf = blockIds.warpedWartBlock
              }else if(nb === 2){
                tree = blockIds.crimsonStem
                leaf = blockIds.netherWartBlock
              }
            }
            
            //Center
						for (let j = ground + 1; j <= top; j++) {
							this.setBlock(i, j, k, tree)
						}
						this.setBlock(i, top + 1, k, leaf)
						this.setBlock(i, ground, k, groundBlock)
            
            //Shroomlight
            for(var l=0; l<3; l++) world.spawnBlock(wx + random(-2, 2), top + random(-1,1), wz + random(-2,2), blockIds.shroomlight)
            
            //Top leaves
            for(var x=-1; x<2; x++){
              for(var z=-1; z<2; z++){
                place = (x&1) && (z&1) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top + 1, wz + z, leaf)
                }
              }
            }
            
            //layer 2 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(4096))
            //layer 1 leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
                rand >>>= 1
                if(place){
                  world.spawnBlock(wx + x, top - 1, wz + z, leaf)
                }
              }
            }
            
            rand = floor(random(40964096))
            //drooping leaves
            for(var x=-2; x<3; x++){
              for(var z=-2; z<3; z++){
                place = x===2 || x===-2 || z===2 || z==-2
                rand >>>= 1
                if(place){
                  var h = rand & 4 && rand & 8 ? rand & 3 : 0
                  if(h){
                    world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                    for(var y=0; y<h; y++){
                      world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf)
                    }
                  }
                }
              }
            }
            
            if(nb === 2){
              rand = floor(random(40964096))
              //vines
              for(var x=-2; x<3; x++){
                for(var z=-2; z<3; z++){
                  place = x===2 || x===-2 || z===2 || z==-2
                  rand >>>= 1
                  if(place){
                    var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
                    if(h){
                      world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
                      for(var y=0; y<h; y++){
                        world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant)
                      }
                      world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines)
                    }
                  }
                }
              }
            }
            
          }
          //cows
          if (random() < 0.001 && this.getBlock(i, ground, k) === blockIds.grass) {
          world.entities.push(new Cow(wx, ground+1, wz))
          }
          //flowers and vines
          if (random() < 0.05 && this.getBlock(i, ground, k) === blockIds.grass) {
            var flower = flowers[Math.round(random(flowers.length-1))]
            world.spawnBlock(wx, ground+1, wz, flower);
          }
          var block = this.getBlock(i, ground, k)
          if(random() < 0.05){
            if(block === blockIds.crimsonNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots);
            }else if(block === blockIds.warpedNylium){
              world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots);
            }
          }
          
          //lava rivers
          if(random() < 0.005 && world.getBlock(i,ground,k) && this.type==="nether"){
            let it = 0
            let x=wx, y=ground, z=wz
            let dir=floor(random(0,8))
            for(; it<100; it++){
              let xp,zp
              switch(dir){
                case 0:
                  x+=1
                  zp=true
                  break
                case 1:
                  x+=1
                  z+=1
                  break
                case 2:
                  z+=1
                  xp=true
                  break
                case 3:
                  x-=1
                  z+=1
                  break
                case 4:
                  x-=1
                  zp=true
                  break
                case 5:
                  x-=1
                  z-=1
                  break
                case 6:
                  z-=1
                  xp=true
                  break
                case 7:
                  x+=1
                  z-=1
                  break
              }
              if(random() < 0.08){
                dir += round(random(-1,1))
              }
              let prev = world.getBlock(x,y,z)
              world.setBlock(x,y,z,blockIds.Lava)
              if(xp){
                world.setBlock(x+1,y,z,blockIds.Lava)
              }
              if(zp){
                world.setBlock(x,y,z+1,blockIds.Lava)
              }
              if(!prev && y>1){
                y--
                prev = world.getBlock(x,y,z)
                world.setBlock(x,y,z,blockIds.Lava)
                while(!prev && y>1){
                  y--
                  prev = world.getBlock(x,y,z)
                  world.setBlock(x,y,z,blockIds.Lava)
                }
              }
              if(world.getBlock(x,y-1,z) === blockIds.Lava) break
            }
          }

          if(this.type === "nether"){
            let l
            if(random() < 0.005){
              let r = random(12345123451234512345)*3
              let x=wx, y=this.ceils[k * 16 + i], z=wz
              let ri=floor(random(5,15))
              for(l=0; l<ri; l++){
                x += r&1 - 1; r >>>= 1
                y += r&3 - 2; r >>>= 1
                z += r&1 - 1; r >>>= 1
                world.spawnBlock(x,y,z, blockIds.glowstone)
              }
            }
            
            for(l=0; l<16; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre)
              }
            }
            
            for(l=0; l<10; l++){
              let x = random(0, 16)
              let y = random(10, 177)
              let z = random(0, 16)
              if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
                world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre)
              }
            }
          }else{
            // Blocks of each per chunk in Minecraft
            // Coal: 185.5
            // Iron: 111.5
            // Gold: 10.4
            // Redstone: 29.1
            // Diamond: 3.7
            // Lapis: 4.1
            ground -= 4

            if (random() < 3.7 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
              }
            }

            if (random() < 111.5 / 256) {
              let y = random() * 64 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
              }
            }

            if (random() < 185.5 / 256) {
              let y = random() * ground | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
              }
            }

            if (random() < 10.4 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
              }
            }

            if (random() < 29.1 / 256) {
              let y = random() * 16 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
              }
            }

            if (random() < 4.1 / 256) {
              let y = random() * 32 | 0 + 1
              y = y < ground ? y : ground
              if (this.getBlock(i, y, k)) {
                this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
              }
            }
				  }
          
        }
			}

			this.populated = true
		}
		genMesh() {
			let start = performance.now()
			let barray = bigArray
			let index = 0
			for (let i = 0; i < this.sections.length; i++) {
				index = this.sections[i].genMesh(barray, index)
			}
			let arrayDone = performance.now()

			if (!this.buffer) {
				this.buffer = gl.createBuffer()
			}
			let data = barray.slice(0, index)

			let maxY = 0
			let minY = 255
			let y = 0
			for (let i = 1; i < data.length; i += 6) {
				y = data[i]
				maxY = max(maxY, y)
				minY = min(minY, y)
			}
			this.maxY = maxY
			this.minY = minY
			this.faces = data.length / 32
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
			gl.enableVertexAttribArray(glCache.aVertex)
			gl.enableVertexAttribArray(glCache.aTexture)
			gl.enableVertexAttribArray(glCache.aShadow)
			gl.enableVertexAttribArray(glCache.aSkylight)
			gl.enableVertexAttribArray(glCache.aBlocklight)
			gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 32, 0)
			gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 32, 12)
			gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 32, 20)
			gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 32, 24)
			gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 32, 28)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
			this.lazy = false
		}
		tick() {
			if (this.edited) {
				for (let i = 0; i < this.sections.length; i++) {
					if (this.sections[i].edited) {
						this.sections[i].tick()
					}
				}
			}
		}
		load() {
			let chunkX = this.x >> 4
			let chunkZ = this.z >> 4
			let load = null
			
			for (let i = 0; i < world.loadFrom.length; i++) {
				load = world.loadFrom[i]
				if (load.x === chunkX && load.z === chunkZ) {
					let y = load.y * 16
					for (let j in load.blocks) {
            if(blockData[load.blocks[j]]){ // if a block doesn't exsist, they won't be generated
						  world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
            }
					}
					world.loadFrom.splice(i--, 1)
				}
			}
			this.loaded = true
		}
	}

	class Contacts {
		constructor() {
			this.array = []
			this.size = 0
		}
		add(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([ x, y, z, block ])
			} else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		}
		clear() {
			this.size = 0
		}
	}

	class Entity {
		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns) {
			this.x = x
			this.y = y
			this.z = z
			this.previousX = x
			this.previousY = y
			this.previousZ = z
			this.canStepX = true
			this.canStepY = true
			this.pitch = pitch
			this.yaw = yaw
			this.velx = velx
			this.vely = vely
			this.velz = velz
			this.width = width
			this.height = height
			this.depth = depth
      this.offsetY = 0
			this.contacts = new Contacts()
			this.lastUpdate = performance.now()
			this.onGround = false
      this.gravityStength = -0.032
      this.standingOn = 0
			this.despawns = despawns
			this.spawn = this.lastUpdate
			this.canDespawn = false
			this.faces = faces
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
		updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

      this.standingOn = world.getBlock(this.x, round(this.y-this.height-1), this.z)
      if (this.liquid){
        this.gravityStength = -0.01
        this.vely *= 0.9
      }else{
        this.gravityStength = -0.02
      }
      this.vely += this.gravityStength * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}
			let drag = this.liquid ? 0.7 : (this.onGround ? 0.5 : 0.85)
      if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
			this.velz += (this.velz * 0.9 - this.velz) * dt
			this.velx += (this.velx * 0.9 - this.velx) * dt
			// this.vely += (this.vely * 0.9 - this.vely) * dt
		}
		collided(x, y, z, vx, vy, vz, block) {
    
			let verts = blockData[block].shape.verts
			let px = roundBits(this.x - this.width / 2 - x)
			let py = roundBits(this.y - this.height / 2 - y)
			let pz = roundBits(this.z - this.depth / 2 - z)
			let pxx = roundBits(this.x + this.width / 2 - x)
			let pyy = roundBits(this.y + this.height / 2 - y)
			let pzz = roundBits(this.z + this.depth / 2 - z)
			let minX, minY, minZ, maxX, maxY, maxZ, min, max

			//Top and bottom faces
			let faces = verts[0]
			if (vy <= 0) {
				faces = verts[1]
			}
			if (!vx && !vz) {
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minZ = min[2]
					max = face.max
					maxX = max[0]
					maxZ = max[2]
					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
						if (vy <= 0) {
							this.onGround = true
							this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
							this.vely = 0
              console.log("aa")
							return false
						} else {
							return true
						}
					}
				}
				return false
			}

			//West and East faces
			if (vx < 0) {
				faces = verts[4]
			} else if (vx > 0) {
				faces = verts[5]
			}
			if (vx) {
				let col = false
				for (let face of faces) {
					min = face.min
					minZ = min[2]
					minY = min[1]
					max = face.max
					maxZ = max[2]
					maxY = max[1]
					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
						if (maxY - py > 0.5) {
            console.log("bb")
							this.canStepX = false
						}
            console.log("bb")
						col = true
					}
				}
				return col
        if(col == true){
        console.log("col")
        }
			}

			//South and North faces
			if (vz < 0) {
				faces = verts[2]
			} else if (vz > 0) {
				faces = verts[3]
			}
			if (vz) {
				let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minY = min[1]
					max = face.max
					maxX = max[0]
					maxY = max[1]
					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
          console.log("bb")
						if (maxY - py > 0.5) {
							this.canStepZ = false
						}
						col = true
					}
				}
				return col
			}
		}
		move(now) {
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

      this.liquid = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = world.getBlock(x, y, z)
						if (block && blockData[block].solid && !blockData[block].liquid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
            }
					}
				}
			}
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

			this.canStepX = false
			this.canStepY = false
			this.onGround = false
			//Check collisions in the Y direction
			this.y += this.vely * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
					this.y = this.previousY
					this.vely = 0
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
					if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.x = this.previousX
					this.velx = 0
					break
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
					if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.z = this.previousZ
					this.velz = 0
					break
				}
			}

			this.lastUpdate = now
			this.contacts.clear()
		}
		update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
		render() {
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y + offsetY, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}

	class Item extends Entity {
		constructor(x, y, z, velx, vely, velz, blockID, autoSetVel) {
			const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "Item"
      
      if(autoSetVel){
        this.velx = (Math.random()-0.5) * 0.2
        this.vely = Math.random() * 0.2
        this.velz = (Math.random()-0.5) * 0.2
      }
		}
    update() {
      let now = performance.now()
      this.yaw += 0.01;
      if(this.yaw > Math.PI*2){
        this.yaw -= Math.PI*2
      }
      
			this.updateVelocity(now)
		  this.move(now)
      
      let xDist = this.x - p.x
      let yDist = this.y - p.y
      let zDist = this.z - p.z
      let pickup = xDist > -1 && xDist < 1 && yDist > -1.5 && yDist < 1 && zDist > -1 && zDist < 1
      if(pickup){
        var dist = dist2(this.x, this.z, p.x, p.z)
        pickup = (1 >= dist) && (dist >= -1)
      }
      
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
        
			}
      if(pickup && newInvItem(this.block)){
        this.canDespawn = true
        updateHUD = true
        playSound("entity.item.pickup")
      }
      
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
    }
	}
  win.Item = Item
  class BlockEntity extends Entity{
    constructor(blockID, x,y,z, solidOnGround, cacheBlocks){
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      super(x, y, z, 0, 0, 0, 0, 0, 0.996, 0.996, 0.996, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      this.block = blockID
      this.type = "BlockEntity"
      this.solidOnGround = solidOnGround
      this.cacheBlocks = cacheBlocks
      
      if(cacheBlocks){
        this.cached = {}
        this.cached[blockID] = this.vao
      }
    }
    changeBlock(blockID){
      if(this.cached[blockID]){
        this.vao = this.cached[blockID]
        return
      }
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      if(this.cacheBlocks){
        this.cached[blockID] = this.vao
      }
    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      if(this.onGround && this.solidOnGround){
        var x = round(this.x), y = round(this.y), z = round(this.z)
        var b = world.getBlock(x, y-1, z)
        if(blockData[b] && blockData[b].shape === shapes.cube){
          world.setBlock(x,y,z, this.block)
          blockSound(this.block, "land", x,y,z)
        }else{
          // non cube block breaks falling blocks
          world.addEntity(new Item(x,y,z, 0,0,0, this.block))
        }
        this.canDespawn = true
      }
		}
  }
  win.BlockEntity = BlockEntity
  class crackEntity extends Entity{
    constructor(tex, x,y,z){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
			}
      super(x, y, z, 0, 0, 0, 0, 0, 1.1, 1.1, 1.1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
      
      this.cached = {}
    }
    cacheTexture(tex){
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture)
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      
      this.cached[tex] = this.vao
    }
    changeTexture(tex){
      this.vao = this.cached[tex]
    }
    render(){
      const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const skysLight = world.getLight(x, y+1, z, 0) * (skyLight / 15)
			const lightLevel = min(skysLight * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  
  //character is seen in 3rd person mode
  class Character extends Entity{
    constructor(blockID){
      const block = blockData[blockID & 255]
			const tex = block.textures
			const shape = shapes.cube
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(0, 0, 0, 0, 0, 0, 0, 0, 0.6, 1.7, 0.6, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
    }
    update(){
      this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
    }
    changeBlock(blockID){
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
    }
  }
  window.Player = Character
  
  class PlayerHand extends Entity{
    constructor(blockID){
			const tex = "orangeConcrete"
			const shape = shapes.playerHand
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
			super(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
      
      this.cached = {}
      this.cached.hand = this.vao
    }
    changeBlock(blockID){
      if(this.cached[blockID]){
        this.vao = this.cached[blockID]
        return
      }
      const block = blockData[blockID]
			const tex = block.textures
			const shape = block.shape
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < 6; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      var vertices = new Float32Array(shapeVerts.flat(Infinity)),
          faces = size
      texture = new Float32Array(texture),
      
      this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexEntity)
			gl.enableVertexAttribArray(glCache.aTextureEntity)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
      this.cached[blockID] = this.vao
    }
    update(){
      this.pitch = (-p.rx)-(Math.PI * 0.8)
      this.yaw = -p.ry
      var d = getRotation(p.rx, p.ry+Math.PI2)
      this.x = p.x + d.x
      this.y = p.y + d.y
      this.z = p.z + d.z
    }
    render() {
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y, this.z)
      modelMatrix.rotX(this.pitch)
      modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = p2.x
			const y = p2.y
			const z = p2.z
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerEntity, 0)
			gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
  }
  function dist(x1, y1, x2, y2){
    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
};
  //world.entities.push(new Cow(p2.x, p2.y, p2.z))
  class Cow extends Entity{
    constructor(x, y, z){
			const tex = ["blackConcrete","blackConcrete","blackConcrete","blackConcrete","blackConcrete","blackConcrete"]
			const shape = shapes.cow
			const shapeVerts = shape.verts
			const shapeTexVerts = shape.texVerts
			const size = shape.size
			let blockSides = Object.keys(Block)
			let texNum = 0
			let texture = []
			let index = 0
			for (let n = 0; n < blockSides.length; n++) {
				let side = blockSides[n]
				let directionalFaces = shapeVerts[Sides[side]]
				for (let facei = 0; facei < directionalFaces.length; facei++) {
					let texVerts = textureCoords[textureMap[tex[texNum]]]
					let tx = texVerts[0]
					let ty = texVerts[1]
					let texShapeVerts = shapeTexVerts[n][facei]
					texture[index    ] = tx + texShapeVerts[0]
					texture[index + 1] = ty + texShapeVerts[1]
					texture[index + 2] = tx + texShapeVerts[2]
					texture[index + 3] = ty + texShapeVerts[3]
					texture[index + 4] = tx + texShapeVerts[4]
					texture[index + 5] = ty + texShapeVerts[5]
					texture[index + 6] = tx + texShapeVerts[6]
					texture[index + 7] = ty + texShapeVerts[7]
					index += 8
				}
				texNum++
			}
      
      super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
      
      this.moveTime = 0
      this.dirx = 0
      this.dirz = 0
    }
    AI(now){
    
    let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
      var d = dist(this.x, this.z, p.x, p.z);
            var diff = Math.min(0.1/2, d);//the number value is the speed

            if(diff > 0){
                this.yaw = -Math.atan2(p.z - this.z, p.x - this.x);
                
                this.x += Math.cos(-this.yaw) * diff;
                this.z += Math.sin(-this.yaw) * diff;
            }
      	let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null
      if (this.col == true){
      alert("aaaaaa")
      }
      this.liquid = false
			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = world.getBlock(x, y, z)
						if (block && blockData[block].solid && !blockData[block].liquid) {
							this.contacts.add(x, y, z, block)
						}
            if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
              this.liquid = true
            }
					}
				}
			}
			let dat = (now - this.lastUpdate) / 33
			dat = dat > 2 ? 2 : dat

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

			this.canStepX = false
			this.canStepY = false
			this.onGround = false
			//Check collisions in the Y direction
			this.y += this.vely * dat
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
					this.y = this.previousY
					this.vely = 0
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx * dat
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
        alert("AAAAA")
					if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						alert("AAAAA")
					}
					this.x = this.previousX
					this.velx = 0
					break
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz * dat
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
        alert("AAAAA")
					if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						alert("AAAAA")
					}
					this.z = this.previousZ
					this.velz = 0
					break
				}
			}

			this.lastUpdate = now
			this.contacts.clear()

    }
    update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
      this.AI(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
		}
  }
  win.Cow = Cow
  
  class Particle {
		constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns) {
			this.x = x
			this.y = y
			this.z = z
			this.previousX = x
			this.previousY = y
			this.previousZ = z
			this.canStepX = true
			this.canStepY = true
			this.pitch = pitch
			this.yaw = yaw
			this.velx = velx
			this.vely = vely
			this.velz = velz
			this.width = width
			this.height = height
			this.depth = depth
      this.offsetY = 0
			this.contacts = new Contacts()
			this.lastUpdate = performance.now()
			this.onGround = false
			this.despawns = despawns
			this.spawn = this.lastUpdate
			this.canDespawn = false
			this.faces = faces
			this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
			const verticesBuffer = gl.createBuffer()
			const textureBuffer = gl.createBuffer()
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

			gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)

			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
			gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)
			
			gl.enableVertexAttribArray(glCache.aVertexParticle)
			gl.enableVertexAttribArray(glCache.aTextureParticle)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
		updateVelocity(now) {
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt
			this.vely += -0.02 * dt
			if (this.vely < -1.5) {
				this.vely = -1.5
			}

      let drag = this.onGround ? 0 : 0.9
			this.velz += (this.velz * drag - this.velz) * dt
			this.velx += (this.velx * drag - this.velx) * dt
			// this.vely += (this.vely * 0.9 - this.vely) * dt
		}
		collided(x, y, z, vx, vy, vz, block) {
			let verts = blockData[block].shape.verts
			let px = roundBits(this.x - this.width / 2 - x)
			let py = roundBits(this.y - this.height / 2 - y)
			let pz = roundBits(this.z - this.depth / 2 - z)
			let pxx = roundBits(this.x + this.width / 2 - x)
			let pyy = roundBits(this.y + this.height / 2 - y)
			let pzz = roundBits(this.z + this.depth / 2 - z)
			let minX, minY, minZ, maxX, maxY, maxZ, min, max

			//Top and bottom faces
			let faces = verts[0]
			if (vy <= 0) {
				faces = verts[1]
			}
			if (!vx && !vz) {
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minZ = min[2]
					max = face.max
					maxX = max[0]
					maxZ = max[2]
					if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
						if (vy <= 0) {
							this.onGround = true
							this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
							this.vely = 0
							return false
						} else {
							return true
						}
					}
				}
				return false
			}

			//West and East faces
			if (vx < 0) {
				faces = verts[4]
			} else if (vx > 0) {
				faces = verts[5]
			}
			if (vx) {
				let col = false
				for (let face of faces) {
					min = face.min
					minZ = min[2]
					minY = min[1]
					max = face.max
					maxZ = max[2]
					maxY = max[1]
					if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
						if (maxY - py > 0.5) {
							this.canStepX = false
						}
						col = true
            
					}
				}
				return col
			}

			//South and North faces
			if (vz < 0) {
				faces = verts[2]
			} else if (vz > 0) {
				faces = verts[3]
			}
			if (vz) {
				let col = false
				for (let face of faces) {
					min = face.min
					minX = min[0]
					minY = min[1]
					max = face.max
					maxX = max[0]
					maxY = max[1]
					if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
						if (maxY - py > 0.5) {
							this.canStepZ = false
						}
						col = true
            
					}
				}
				return col
			}
		}
		move(now) {
			let pminX = floor(this.x - this.width / 2)
			let pmaxX = ceil(this.x + this.width / 2)
			let pminY = floor(this.y - this.height / 2)
			let pmaxY = ceil(this.y + this.height / 2)
			let pminZ = floor(this.z - this.depth / 2)
			let pmaxZ = ceil(this.z + this.depth / 2)
			let block = null

			for (let x = pminX; x <= pmaxX; x++) {
				for (let y = pminY; y <= pmaxY; y++) {
					for (let z = pminZ; z <= pmaxZ; z++) {
						let block = world.getBlock(x, y, z)
						if (block && blockData[block].solid) {
							this.contacts.add(x, y, z, block)
						}
					}
				}
			}
			let dt = (now - this.lastUpdate) / 33
			dt = dt > 2 ? 2 : dt

			this.previousX = this.x
			this.previousY = this.y
			this.previousZ = this.z

			this.canStepX = false
			this.canStepY = false
			this.onGround = false
			//Check collisions in the Y direction
			this.y += this.vely * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
					this.y = this.previousY
					this.vely = 0
					break
				}
			}

			if (this.y === this.previousY) {
				this.canStepX = true
				this.canStepZ = true
			}

			//Check collisions in the X direction
			this.x += this.velx * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
					if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.x = this.previousX
					this.velx = 0
					break
          alert("aaa")
				}
			}

			//Check collisions in the Z direction
			this.z += this.velz * dt
			for (let i = 0; i < this.contacts.size; i++) {
				block = this.contacts.array[i]
				if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
					if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					this.z = this.previousZ
					this.velz = 0
					break
          alert("aaa")
				}
			}

			this.lastUpdate = now
			this.contacts.clear()
		}
		update() {
			let now = performance.now()
			this.updateVelocity(now)
			this.move(now)
			if (now - this.spawn > this.despawns) {
				this.canDespawn = true
			}
      
      this.yaw = atan2(p.z - this.z,p.x-this.x)
      this.pitch = atan(p.y - this.y)
		}
		render() {
			const offsetY = this.offsetY
			const modelMatrix = new Matrix();
			modelMatrix.identity()
			modelMatrix.translate(this.x, this.y + offsetY, this.z)
			modelMatrix.rotX(this.pitch)
			modelMatrix.rotY(this.yaw)
			modelMatrix.scale(this.width, this.height, this.depth)
			const viewMatrix = p.transformation.elements
			const proj = p.projection
			const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
			const modelViewProjectionMatrix = new Matrix()
			modelViewProjectionMatrix.identity()
			modelViewProjectionMatrix.mult(projectionMatrix)
			modelViewProjectionMatrix.mult(viewMatrix)
			modelViewProjectionMatrix.mult(modelMatrix.elements)
			// row major to column major
			modelViewProjectionMatrix.transpose()
			const x = round(this.x)
			const y = round(this.y)
			const z = round(this.z)
			const blockLight = world.getLight(x, y, z, 1)
			const skysLight = world.getLight(x, y, z, 0) * (skyLight / 15)
			const lightLevel = min(max(skysLight, blockLight) * 0.9 + 0.1, 1.0)
			gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
			gl.uniform1i(glCache.uSamplerParticle, 0)
			gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
			gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}
  
  class BlockParticle extends Particle{
    constructor(tex, x,y,z){
      let s=4/16
      let bs = 3/16 //particle size
      let p=1/(16+4)
      let offX = random(p), offY = random(p)
      let velx = (Math.random()-0.5) * 0.3,
          vely = Math.random() * 0.2,
          velz = (Math.random()-0.5) * 0.3
      const shape = shapes.blockParticle
      const shapeVerts = shape.verts
      const shapeTexVerts = shape.texVerts
      const size = shape.size
      let blockSides = Object.keys(Block)
      let texture = []
      let index = 0
      for (let n = 0; n < 6; n++) {
        let side = blockSides[n]
        let directionalFaces = shapeVerts[Sides[side]]
        for (let facei = 0; facei < directionalFaces.length; facei++) {
          let texVerts = textureCoords[textureMap[tex]]
          let tx = texVerts[0] + offX
          let ty = texVerts[1] + offY
          let texShapeVerts = shapeTexVerts[n][facei]
          texture[index    ] = tx + (texShapeVerts[0]*s)
          texture[index + 1] = ty + (texShapeVerts[1]*s)
          texture[index + 2] = tx + (texShapeVerts[2]*s)
          texture[index + 3] = ty + (texShapeVerts[3]*s)
          texture[index + 4] = tx + (texShapeVerts[4]*s)
          texture[index + 5] = ty + (texShapeVerts[5]*s)
          texture[index + 6] = tx + (texShapeVerts[6]*s)
          texture[index + 7] = ty + (texShapeVerts[7]*s)
          index += 8
        }
      }
      super(x, y, z, 0, 0, velx, vely, velz, bs, bs, bs, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Math.random()*3000)
    }
  }
  win.BlockParticle = BlockParticle

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	}
	function chunkDist(c) {
		let dx = p.x - c.x
		let dz = p.z - c.z
		if (dx > 16) {
			dx -= 16
		} else if (dx > 0) {
			dx = 0
		}
		if (dz > 16) {
			dz -= 16
		} else if (dz > 0) {
			dz = 0
		}
		return Math.sqrt(dx * dx + dz * dz)
	}
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8
		let dy1 = p.z - c1.z - 8
		let dx2 = p.x - c2.x - 8
		let dy2 = p.z - c2.z - 8
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
	}
	function fillReqs(x, z) {
		// Chunks must all be loaded first.
		var done = true
		for (let i = x - 3; i <= x + 3; i++) {
			for (let j = z - 3; j <= z + 3; j++) {
				let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk.generated) {
					world.generateQueue.push(chunk)
					done = false
				}
				if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2) {
					world.populateQueue.push(chunk)
					done = false
				}
				if (world.loadFrom.length && !chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.loadQueue.push(chunk)
					done = false
				} else if (!world.loadFrom.length && !chunk.loaded) {
					chunk.loaded = true
				}
				if (!chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.lightingQueue.push(chunk)
					done = false
				}
			}
		}
		return done
	}
	function maxDist(x, z, x2, z2) {
		let ax = abs(x2 - x)
		let az = abs(z2 - z)
		return max(ax, az)
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds")
		}
	}
  
  function login(){
    return new Promise((resolve, reject) => {
      var w = open("https://www.thingmaker.repl.co/website/login.html", "_blank","width=100")
      function onmsg(event){
        if (event.source !== w) return;
        if (event.data.startsWith("logged:")){
          w.close()
          window.removeEventListener("message", onmsg);
          resolve(event.data.replace("logged:",''))
        }else if(event.data === "canceled"){
          w.close()
          window.removeEventListener("message", onmsg);
          reject()
        }
      }
      window.addEventListener("message", onmsg);
    })
  }

  var achexUsername = "player"+Date.now()
  win.username = ""
  async function loggedIn(){
    var logged = false;
    await fetch("https://server.thingmaker.repl.co/getuser", {credentials:"include"}).then(r => r.text()).then(r => logged=r)
    if(logged){
      username = logged
      return logged
    }else{
      if(confirm("Your not logged in. Head over to www.thingmaker.repl.co/login.html to login.")){
        var logged
        await login().then(r => logged=r).catch(r => logged=r)
        if(logged){
          username = logged
          return logged
        }
      }
      return false
      changeScene("main menu")
    }
  }
  async function getWorlds(){
    var logged = await loggedIn()
    if(!logged){
      return []
    }
    var worlds
    await fetch("https://server.thingmaker.repl.co/worlds").then(r => r.json()).then(r => worlds=r)
    return worlds
  }
  var multiplayer = null
  var players = {}
  function hasPlayer(username){
    for(var i in players){
      if(players[i].username === username) return true
    }
  }
  /*const hub = "Minekhan"
  function sendHub(obj){
    let str = JSON.stringify({
      "toH": hub,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }
  function sendUser(user, obj){
    let str = JSON.stringify({
      "to": user,
      "msg": JSON.stringify(obj)
    })
    multiplayer.send(str)
    return str
  }*/
  function send(msg, to){
    msg.FROM = achexUsername
    msg.USER = username
    if(to) msg.TO = to
    multiplayer.send(JSON.stringify(msg))
  }
  var host
  function initMultiplayer(target){
    if(multiplayer) return
    var ban = []
    host = false
    if(!target){
      target = world.id || 0
      host = true
    }
    players = {} //empty
    multiplayer = new WebSocket("wss://server.thingmaker.repl.co/ws?target="+target)
    multiplayer.onopen = e => {
			/*multiplayer.send(JSON.stringify({
        "auth": achexUsername,
        "passwd":"none"
      }))
      multiplayer.send(JSON.stringify({
        "joinHub":hub,
        "passwd":"none"
      }))*/
      send({
        "type":"connect",
        username: username,
        id: achexUsername
      })
      if(host){
        send({
          "type":"init",
          name: world.name
        })
      }
      send({
        "type":"getSave"
      })

      multiplayer.pos = setInterval(() => {
        if(world){
          send({type:"pos", data:p3, dimension: world.type})
          //if(host)send({type:"entityPos", data: world.getEntities(), dimension: world.type})
        }
      }, 500)
		}
		multiplayer.onmessage = msg => {
			let packet = JSON.parse(msg.data)
			var author = packet.FROM //should be the id
      var data = packet//.msg ? JSON.parse(packet.msg) : {}
      
      if(data.type === "getSave" && host){
        if(ban.includes(data.USER)){
          send({
            type: "ban",
            data: data.USER
          }, author)
        }else{
          send({
            type:"loadSave",
            data:world.getSaveString(),
            nether:world.getNetherSaveString(),
            mod: world.mod,
            id: world.id || Date.now(),
            dimension: world.type || "overworld"
          }, author)
        }
      }else if(data.type === "loadSave"){
        dimensions = {
          overworld: new World(),
          nether: new World("nether")
        }
        world = dimensions.overworld

        world.id = data.id

        if (data.data) {
          try {
            world.loadSave(data.data)
          }catch(e) {
            alert("Unable to load save code")
            return
          }
        }
        if (data.nether) {
          let world = dimensions.nether
          try {
            world.loadSave(data.nether)
          }catch(e) {
            alert("Unable to load nether save code")
            return
          }
        }
        try{
          world.mod = data.mod
          mod = Object.constructor("return "+data.mod)()
        }catch(e){console.log("error loading mod: "+e)}
        if(survival){
          setHotbar([0,0,0,0,0,0,0,0,0])
        }
        world = dimensions[data.dimension || "overworld"]
        changeScene("loading")
      }else if(data.type === "pos"){
        var pos = data.data
        if(!players[author]){
          players[author] = new Player(abs( (pos.username || "").hashCode()) % 80 + 1)
        }
        let thisplayer = players[author]
        thisplayer.x = pos.x
        thisplayer.y = pos.y - 1
        thisplayer.z = pos.z
        thisplayer.yaw = pos.ry
        thisplayer.dimension = data.dimension
        if(thisplayer.username !== pos.username){
          thisplayer.username = pos.username
          thisplayer.changeBlock(abs( (pos.username || "").hashCode()) % 80 + 1)
        }
      }else if(data.type === "dc"){
        delete players[data.data]
      }else if(data.type === "setBlock"){
        let pos = data.data
        let world = dimensions[pos.dimension]
        let prevBlock = world.getBlock(pos.x, pos.y, pos.z)
        world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true)
        if(pos.block){
          if(!prevBlock){
            blockSound(pos.block, "place", pos.x, pos.y, pos.z)
          }
        }else{
          blockSound(prevBlock, "dig", pos.x, pos.y, pos.z)
        }
      }/*else if(data.type === "entityPos"){
        if(data.data){
          for(var i=0; i<data.data.length; i++){
            world.posEntity(data.data[i])
          }
        }else{
          world.posEntity(data)
        }
        //still needs to position it in the right dimension, not the current one
        //server needs to pass these to other players
      }else if(data.type === "entityDelete"){
        world.deleteEntity(data.id, true)
      }*/else if(data.type === "kill"){
        die()
      }else if(data.type === "message"){
        Messages.write(data.data, data.username)
      }else if(data.type === "error"){
        alert(data.data)
      }
		}

		multiplayer.onclose = () => {
			alert("Connection lost!")
      clearInterval(multiplayer.pos)
      multiplayer = null
		}
		multiplayer.onerror = () => {
      multiplayer.close()
    }
    
    win.ban = username => {
      if(!host) return alert("Only the host can ban")
      send({
        type: "ban",
        data: username
      })
      if(!ban.includes(username)) ban.push(username)
    }
  }
  
  function getNetherBiome(biome) {
    if(biome > 0.4 && biome < 0.5){
      return 1
    }else if(biome > 0.4){
      return 2
    }
    return 0
  }
  function getBiome(biome){
    if(biome > 0.5){
      return "desert"
    }else if(biome > 0.4){
      return "field"
    }else if(biome > 0.36){
      return "jungle"
    }else{
      return "giantJungle"
    }
  }
  function getDimension(){
    if(world.type === ""){
      return "overworld"
    }else return world.type
  }

  let skyLight = 0
	let fogDist = 16
	class World {
		constructor(type) {
			generatedChunks = 0
			fogDist = 16
			p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)

      this.type = type || ""
      this.spawnPoint = {
        x: 0,
        y: p.y,
        z: 0
      }

			//Initialize the world's arrays
			this.chunks = []
			this.loaded = []
			this.sortedChunks = []
			this.offsetX = 0
			this.offsetZ = 0
			this.lwidth = 0
			this.chunkGenQueue = []
			this.populateQueue = []
			this.generateQueue = []
			this.lightingQueue = []
			this.loadQueue = []
			this.meshQueue = []
			this.loadFrom = []
			this.entities = []
      this.particles = []
			this.lastChunk = ","
      
      this.edited = false
      this.saveStr = null
		}
		genChunk(chunk) {
			let x = chunk.x >> 4
			let z = chunk.z >> 4
			let trueX = chunk.x
			let trueZ = chunk.z

			if (chunk.generated) {
				return false
			}
			let hide = !loadString
			let smoothness = generator.smooth
			let hilliness = generator.height
      let biomeSmooth = generator.biomeSmooth
      //{ for the nether terrain
      const biomeSize = 1//0.001 // smaller = bigger
			const flatness = 40 // bigger = flatter
			const overhang = 3 // bigger = more overhang; flatter = less overhang
			const bottom = 4 // Minimum height of the ground
			const hillSize = 0.006 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
      //}
			let gen = 0
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					gen = superflat === "island" && this.type === "" ? win.islandGenerator.GetHeight(x*16+i, z*16+k) : (superflat ? 4 : Math.round(noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra)
          if(this.type === "nether" && superflat){
            gen = Math.round(noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra
          }
					chunk.tops[k * 16 + i] = gen
          if(this.type === "nether"){
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
            let b = getNetherBiome(biome)
            let block = blockIds.netherrack
            if(b === 1){
              block = blockIds.warpedNylium
            }else if(b === 2){
              block = blockIds.crimsonNylium
            }
            const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
            let top = 0
            let solid = true
            for (let j = 1; j < 128; j++) {
              if (noise((trueX + i)/smo, overhang*j/smo, (trueZ + k)/smo) - (j - bottom) * hillSize > 0) {
                chunk.setBlock(i, j, k, blockIds.netherrack)
                top = j
                solid = true
              } else if (solid) {
                chunk.setBlock(i, j - 1, k, block)
                /*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
                if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
                if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
                solid = false
              } else if(j < 80){
                chunk.setBlock(i, j-1, k, blockIds.Lava)
                if(chunk.getBlock(i, j - 2, k) === block) chunk.setBlock(i, j-2, k, blockIds.netherrack)
              }
            }

            chunk.tops[k * 16 + i] = top
            chunk.setBlock(i, 0, k, blockIds.bedrock)
            
            block = blockIds.netherrack
            for(let j=1; j<gen; j++){
              chunk.setBlock(i, maxHeight - 50 - j, k, block)
            }
            chunk.setBlock(i,maxHeight-50,k, blockIds.bedrock)
            chunk.ceils[k * 16 + i] = maxHeight - 50 - gen
          }else if (superflat === "island") {
            if (win.islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
              chunk.setBlock(i, gen, k, blockIds.Water);
              chunk.setBlock(i, gen - 1, k, blockIds.Water)
              chunk.setBlock(i, gen - 2, k, blockIds.dirt)
              chunk.setBlock(i, gen - 3, k, blockIds.dirt)
            }   else {
              let biomeHere =win.islandGenerator.GetBiomeType(x*16+i, z*16+k);
              if (biomeHere === -3161286) {
                chunk.setBlock(i, gen, k, blockIds.sand)
                chunk.setBlock(i, gen - 1, k, blockIds.sand)
                chunk.setBlock(i, gen - 2, k, blockIds.sand)
                chunk.setBlock(i, gen - 3, k, blockIds.sand)
              }   else if (biomeHere === -1) {
                chunk.setBlock(i, gen, k, blockIds.whiteConcrete)
                chunk.setBlock(i, gen - 1, k, blockIds.whiteConcrete)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              }   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
                chunk.setBlock(i, gen, k, blockIds.stone)
                chunk.setBlock(i, gen - 1, k, blockIds.stone)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              } else if (biomeHere === -65536) {
                chunk.setBlock(i, gen, k, blockIds.Lava)
                chunk.setBlock(i, gen - 1, k, blockIds.stone)
                chunk.setBlock(i, gen - 2, k, blockIds.stone)
                chunk.setBlock(i, gen - 3, k, blockIds.stone)
              } else {
                chunk.setBlock(i, gen, k, blockIds.grass)
                chunk.setBlock(i, gen - 1, k, blockIds.dirt)
                chunk.setBlock(i, gen - 2, k, blockIds.dirt)
                chunk.setBlock(i, gen - 3, k, blockIds.dirt)
              }
            }
          } else if(superflat){
            chunk.tops[k * 16 + i] = gen;

            chunk.setBlock(i, gen, k, blockIds.grass);
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);
          }else{
            let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
            var b = getBiome(biome)
            if(b === "desert"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.sand);
              chunk.setBlock(i, gen - 1, k, blockIds.sand);
              chunk.setBlock(i, gen - 2, k, blockIds.sand);
              chunk.setBlock(i, gen - 3, k, blockIds.sand);
              if(gen<60) {
                    gen = 59;
                    chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
                    chunk.setBlock(i, gen, k, blockIds.Water);
                    chunk.setBlock(i, gen - 1, k, blockIds.Water);
                    chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                    chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
              if(gen>120){
                  chunk.setBlock(i, gen, k, blockIds.stone);
              }
              if(gen>140){
                  chunk.setBlock(i, gen, k, blockIds.sand);
              }
            }

            if(b === "field"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.grass);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              if(gen<60) {
                  gen = 59;
                  chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
                  chunk.setBlock(i, gen, k, blockIds.Water);
                  chunk.setBlock(i, gen - 1, k, blockIds.Water);
                  chunk.setBlock(i, gen - 2, k, blockIds.gravel);
                  chunk.setBlock(i, gen - 3, k, blockIds.gravel);
              }
            }
            
            if(b === "jungle" || b === "giantJungle"){
              chunk.tops[k * 16 + i] = gen;

              chunk.setBlock(i, gen, k, blockIds.greenWool);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
              
              if(gen<60) {
                chunk.setBlock(i, 60, k, blockIds.Water | SLAB);
                for(var y=59; y>=gen; y--){
                  chunk.setBlock(i, y, k, blockIds.Water);
                }
                chunk.setBlock(i, gen, k, blockIds.gravel);
                chunk.setBlock(i, gen - 1, k, blockIds.gravel);
              }
            }
          }
          if(this.type !== "nether"){
            for (let j = 1; j < gen - 3; j++) {
              chunk.setBlock(i, j, k, blockIds.stone)
            }
            chunk.setBlock(i, 0, k, blockIds.bedrock)
          }
				}
			}
			chunk.generated = true
		}
		getAdjacentSubchunks(x, y, z, lights) {
			let minChunkX = x - 16 >> 4
			let maxChunkX = x + 16 >> 4
			let minChunkY = y - 16 >> 4
			let maxChunkY = y + 16 >> 4
			let minChunkZ = z - 16 >> 4
			let maxChunkZ = z + 16 >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (let y = minChunkY; y <= maxChunkY; y++) {
					for (z = minChunkZ; z <= maxChunkZ; z++) {
						if (y < 0) {
							ret.push(lights ? fullSection.light : fullSection.blocks)
						} else if (this.chunks[x] && this.chunks[x][z]) {
							section = this.chunks[x][z].sections[y] || emptySection
							ret.push(lights ? section.light : section.blocks)
						} else {
							ret.push(lights ? emptySection.light : emptySection.blocks)
						}
					}
				}
			}
			return ret
		}
		updateBlock(x, y, z, lazy, leaveMe) {
			let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
			if (chunk && chunk.buffer) {
				chunk.updateBlock(x & 15, y, z & 15, this, lazy, leaveMe)
			}
		}
		getChunk(x, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z]
		}
		getWorldBlock(x, y, z) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return blockIds.air
			}
			return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
		}
		getBlock(x, y, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return blockIds.air
			} else if (y < 0) {
				return blockIds.bedrock
			} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.getWorldBlock(x, y, z)
			}
			return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15)
		}
		setBlock(x, y, z, blockID, lazy, leaveSelf, remote) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return
			}
      if(y < 1) return
			let chunk = this.chunks[x >> 4][z >> 4]

			let xm = x & 15
			let zm = z & 15
			if (blockID) {
				chunk.setBlock(xm, y, zm, blockID, !lazy)
				let data = blockData[blockID]
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, true, data.lightLevel)
				}
			} else {
				let data = blockData[chunk.getBlock(xm, y, zm)]
				chunk.deleteBlock(xm, y, zm, !lazy)
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, false, data.lightLevel)
				}
			}

			if (lazy) {
				return
			}
      if(multiplayer && !remote){
        send({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:getDimension()}})
      }

			//Update the 6 adjacent blocks and 1 changed block
			if (xm && xm !== 15 && zm && zm !== 15) {
				chunk.updateBlock(xm - 1, y, zm, this, lazy)
				chunk.updateBlock(xm + 1, y, zm, this, lazy)
				chunk.updateBlock(xm, y - 1, zm, this, lazy)
				chunk.updateBlock(xm, y + 1, zm, this, lazy)
				chunk.updateBlock(xm, y, zm - 1, this, lazy)
				chunk.updateBlock(xm, y, zm + 1, this, lazy)
			}
			else {
				this.updateBlock(x - 1, y, z, lazy)
				this.updateBlock(x + 1, y, z, lazy)
				this.updateBlock(x, y - 1, z, lazy)
				this.updateBlock(x, y + 1, z, lazy)
				this.updateBlock(x, y, z - 1, lazy)
				this.updateBlock(x, y, z + 1, lazy)
			}

			chunk.updateBlock(xm, y, zm, this, lazy, leaveSelf)

			// Update the corner chunks so shadows in adjacent chunks update correctly
			if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
			if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
			if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
			if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
      
      this.edited = true
		}
		getLight(x, y, z, blockLight = 0) {
      if(y < 1) return 0
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
        return this.chunks[x >> 4][z >> 4].getLight(x & 15, y, z & 15, blockLight)
			}
			return this.loaded[X * this.lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
		}
		setLight(x, y, z, level, block) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z].setLight(x & 15, y, z & 15, level, block)
		}
		updateLight(x, y, z, place, blockLight = 0) {
			let chunk = this.getChunk(x, z)
			let cx = x & 15
			let cz = z & 15
			let center = chunk.getLight(cx, y, cz, 0)
			let blight = chunk.getLight(cx, y, cz, 1)
			let up = this.getLight(x, y+1, z)
			let down = this.getLight(x, y-1, z)
			let north = this.getLight(x, y, z+1)
			let south = this.getLight(x, y, z-1)
			let east = this.getLight(x+1, y, z)
			let west = this.getLight(x-1, y, z)

			let spread = []
			if (!place) { // Block was removed; increase light levels
				if ((up & 15) === 15) {
					for (let i = y; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 15)
							spread.push(x, i, z)
						} else {
							break
						}
					}
					chunk.spreadLight(spread, 14, true)
				} else {
					center = max(up, down, north, south, east, west)
					if (center > 0) center -= 1
					this.setLight(x, y, z, center)
					if (center > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, center - 1, true)
					}
				}

				// Block light levels
				if (!blockLight || blockLight < blight) {
					spread.length = 0
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(up, down, north, south, east, west)
					if (blight > 0) blight -= 1
					this.setLight(x, y, z, blight, 1)
					if (blight > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, blight - 1, true, 1)
					}
				}
			}
			else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
				let respread = []
				for (let i = 0; i <= center + 1; i++) respread[i] = []
				chunk.setLight(cx, y, cz, 0, 0)
				chunk.setLight(cx, y, cz, 0, 1)
				spread.push(x, y, z)

				// Sky light
				if (center === 15) {
					for (let i = y-1; i > 0; i--) {
						if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 0)
							spread.push(x, i, z)
						} else {
							break
						}
					}
				}
				chunk.unSpreadLight(spread, center - 1, respread)
				chunk.reSpreadLight(respread)

				// Block light
				if (blight) {
					respread.length = 0
					for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
					spread.length = 0
					spread.push(x, y, z)
					chunk.unSpreadLight(spread, blight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
			}
			if (place && blockLight) { // Light block was placed
				this.setLight(x, y, z, blockLight, 1)
				spread.length = 0
				spread.push(x, y, z)
				chunk.spreadLight(spread, blockLight - 1, true, 1)

			} else if (!place && blockLight) { // Light block was removed
				this.setLight(x, y, z, 0, 1)
				spread.push(x, y, z)
				let respread = []
				for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
				chunk.unSpreadLight(spread, blockLight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
		}
		spawnBlock(x, y, z, blockID) {
			//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
      
      if(blockData[blockID].crossShape) blockID |= CROSS
      if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
      if(blockData[blockID].cactus) blockID |= CACTUS
      
			let chunkX = x >> 4
			let chunkZ = z >> 4
			if (!this.chunks[chunkX]) {
				this.chunks[chunkX] = []
			}
			let chunk = this.chunks[chunkX][chunkZ]
			if (!chunk) {
				chunk = new Chunk(chunkX * 16, chunkZ * 16)
				this.chunks[chunkX][chunkZ] = chunk
			}
			if (chunk.buffer) {
				//Only used if spawning a block post-gen
				this.setBlock(x, y, z, blockID, true)
			} else if (!chunk.getBlock(x & 15, y, z & 15)) {
				chunk.setBlock(x & 15, y, z & 15, blockID)
			}
		}
    getEntity(id){
      for(var i=0; i<this.entities.length; i++){
        if(this.entities[i].id === id){
          return i
        }
      }
    }
    addEntity(ent, remote){
      ent.id = Date.now()
      if(multiplayer && !remote){
        //host controls entities
        send({type:"entityPos", id:ent.id, entType:ent.type, pos:{x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block}})
        this.entities.push(ent)
      }else{
        this.entities.push(ent)
      }
    }
    deleteEntity(id, remote, i){
      i = (i || i===0) ? i : this.getEntity(id)
      if(!(i || i===0)) return
      var ent = this.entities[i]
      if(multiplayer && !remote){
        send({type:"entityDelete", id:ent.id})
      }
      this.entities.splice(i, 1)
    }
    posEntity(d){ //for multiplayer.onmessage only
      let p = d.pos
      var i = this.getEntity(d.id)
      var ent
      if(i || i===0){
        ent = this.entities[i]
      }else{
        switch(d.entType){
          case "Item":
            ent = new Item(0, 0, 0, 0, 0, 0, p.block)
            break
          case "BlockEntity":
            ent = new BlockEntity(p.block)
            break
          default:
            break
        }
        if(ent)this.addEntity(ent, true)
      }
      if(!ent) return
      ent.x = p.x
      ent.y = p.y
      ent.z = p.z
      ent.yaw = p.yaw
      ent.pitch = p.pitch
    }
    getEntities(){
      var arr = []
      this.entities.forEach(ent => {
        arr.push({
          id:ent.id,
          entType:ent.type,
          pos: {x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block}
        })
      })
      return arr
    }
		tick() {
			let tickStart = performance.now()
			let maxChunkX = (p.x >> 4) + settings.renderDistance
			let maxChunkZ = (p.z >> 4) + settings.renderDistance
			let chunk = maxChunkX + "," + maxChunkZ
			if (chunk !== this.lastChunk) {
				this.lastChunk = chunk
				this.loadChunks()
				this.chunkGenQueue.sort(sortChunks)
			}

			if (Key.leftMouse && !Key.control && p.lastBreak < Date.now() - 250 && screen === "play" && !survival) { // if survival breaking isn't instant
				changeWorldBlock(0)
			}
			if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250 && !p.autoBuild) {
				newWorldBlock()
			}
			if (Key.leftMouse && p.autoBreak && !Key.control) {
				changeWorldBlock(0)
			}
      if ((Key.rightMouse || Key.leftMouse && Key.control) && p.autoBuild) {
				newWorldBlock()
			}

			for (let i = 0; i < this.sortedChunks.length; i++) {
				this.sortedChunks[i].tick()
			}

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.update()
				if (entity.canDespawn) {
					this.deleteEntity(0, false, i)
				}
			}
      for (let i = this.particles.length - 1; i >= 0; i--) {
				const particle = this.particles[i]
				particle.update()
				if (particle.canDespawn) {
					this.particles.splice(i,1)
				}
			}
      updtPlayer()
      if(multiplayer){
        for(let i in players){
          players[i].update()
        }
      }

			do {
				let doneWork = false
				debug.start = performance.now()
				if (this.meshQueue.length) {
					// Update all chunk meshes.
					let len = this.meshQueue.length - 1
					do {
						this.meshQueue.pop().genMesh()
					} while(this.meshQueue.length)
					doneWork = true
					debug("Meshes")
				}

				if (this.generateQueue.length && !doneWork) {
					let chunk = this.generateQueue.pop()
					this.genChunk(chunk)
					doneWork = true
				}
				if (this.populateQueue.length && !doneWork) {
					let chunk = this.populateQueue[this.populateQueue.length - 1]
					if (!chunk.caves) {
						chunk.carveCaves()
						debug("Carve caves")
					} else if (!chunk.populated) {
						chunk.populate()
						this.populateQueue.pop()
					}
					doneWork = true
				}

				if (this.loadQueue.length && !doneWork) {
					this.loadQueue.pop().load()
					doneWork = true
					if (!this.loadQueue.length) {
						return
					}
				}
				if (this.lightingQueue.length && !doneWork) {
					this.lightingQueue.pop().fillLight()
					doneWork = true
				}

				if (this.chunkGenQueue.length && !doneWork) {
					let chunk = this.chunkGenQueue[0]
					if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
					else if (!chunk.optimized) {
						chunk.optimize(this)
						debug("Optimize")
					} else if (!chunk.buffer) {
						chunk.genMesh()
						debug("Initial mesh")
					} else {
						this.chunkGenQueue.shift()
						generatedChunks++
					}
					doneWork = true
				}
				if (!doneWork) {
					break
				}
			} while(performance.now() - tickStart < 5)
		}
		render() {
			initModelView(p)
      if(this.type === "nether"){
        skyLight = 0
        gl.clearColor(0, 0, 0, 1)
      }else{
			  skyLight = min(max(abs(Date.now() % 1200000 - 600000) / 60000 - 5, 0.1), 1)
        gl.clearColor(sky[0] * skyLight, sky[1] * skyLight, sky[2] * skyLight, 1)
      }
			gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)

			renderedChunks = 0

			let dist = (settings.renderDistance) * 16
			if (this.chunkGenQueue.length) {
				this.chunkGenQueue.sort(sortChunks)
				let chunk = this.chunkGenQueue[0]
				dist = min(dist, chunkDist(chunk))
			}
			if (dist !== fogDist) {
				if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120
				else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30
				else fogDist = dist
			}
			gl.uniform3f(glCache.uPos, p.x, p.y, p.z)
			gl.uniform1f(glCache.uDist, fogDist)
			// this is interesting because uTime is not actually based on time
			// if you are going to change this to use actual time change line 4487 as well
			// since it depends on it
			gl.uniform1f(glCache.uTime, skyLight)
      gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])

			let c = this.sortedChunks
			for (let chunk of c) {
				chunk.render()
			}

			gl.uniform3f(glCache.uPos, 0, 0, 0)

			gl.useProgram(programEntity)

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.render()
			}
      if(multiplayer){
        for(let i in players){
          if(players[i].dimension === world.type) players[i].render()
        }
      }
      renderPlayer()

      if(crack.idx > -1 && survival){
        crack.entity.x = crack.pos[0]
        crack.entity.y = crack.pos[1]
        crack.entity.z = crack.pos[2]
        crack.entity.changeTexture(crack.tex)
        crack.entity.render()
      }
      
      gl.useProgram(programParticle)
      for (let i = this.particles.length - 1; i >= 0; i--) {
				const particle = this.particles[i]
				particle.render()
			}
      
      gl.useProgram(program3D)
			if(hitBox.pos) {
				blockOutlines = true
				blockFill = false
				block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p)
				blockOutlines = false
				blockFill = true
			}
      
		}
		loadChunks() {
			let renderDistance = settings.renderDistance + 3
			let cx = p.x >> 4
			let cz = p.z >> 4
			p.cx = cx
			p.cz = cz
			let minChunkX = cx - renderDistance
			let maxChunkX = cx + renderDistance
			let minChunkZ = cz - renderDistance
			let maxChunkZ = cz + renderDistance

			this.offsetX = -minChunkX
			this.offsetZ = -minChunkZ
			this.lwidth = renderDistance * 2 + 1
			this.chunkGenQueue.length = 0
			this.lightingQueue.length = 0
			this.populateQueue.length = 0
			this.generateQueue.length = 0

			if (this.loaded.length > this.lwidth * this.lwidth) {
				this.loaded.length = this.lwidth * this.lwidth
			}

			let i = 0
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk
					if (!this.chunks[x]) {
						this.chunks[x] = []
					}
					if (!this.chunks[x][z]) {
						chunk = new Chunk(x * 16, z * 16)
						if (maxDist(cx, cz, x, z) <= settings.renderDistance) {
							this.chunkGenQueue.push(chunk)
						}
						this.chunks[x][z] = chunk
					}
					chunk = this.chunks[x][z]
					if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= settings.renderDistance) {
						this.chunkGenQueue.push(chunk)
					}
					this.loaded[i++] = chunk
				}
			}
			this.sortedChunks = this.loaded.filter(renderFilter)
			this.sortedChunks.sort(sortChunks)
		}
    getThisSaveString(){
      let world = this
      
      let edited = []
			for (let x in this.chunks) {
				for (let z in this.chunks[x]) {
					let chunk = this.chunks[x][z]
					if (chunk.edited) {
						for (let y = 0; y < chunk.sections.length; y++) {
							if (chunk.sections[y].edited) {
								edited.push([ chunk.sections[y], chunk.cleanSections[y] ])
							}
						}
					}
				}
			}

			let pallete = {}
			for (let chunks of edited) {
				let changes = false
				chunks[0].blocks.forEach((id, i) => {
					if (id !== chunks[1][i]) {
						pallete[id] = true
						changes = true
					}
				})
				if (!changes) {
					chunks[0].edited = false
				}
			}

			let blocks = Object.keys(pallete).map(n => Number(n))
			pallete = {}
			blocks.forEach((block, index) => pallete[block] = index)

			let rnd = round
			let options = p.flying | (superflat==="island" ? 2 : superflat) << 1 | p.spectator << 3 | caves << 4 | trees << 5 | survival << 6

			let str = world.name + ";" + worldSeed.toString(36) + ";"
				+ rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
				+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
				+ (this.version || version) + ";"
				+ blocks.map(b => b.toString(36)).join(",") + ";"

			for (let i = 0; i < edited.length; i++) {
				if (!edited[i][0].edited) {
					continue
				}
				let real = edited[i][0]
				let blocks = real.blocks
				let original = edited[i][1]
				str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
				for (let j = 0; j < original.length; j++) {
					if (blocks[j] !== original[j]) {
						str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
					}
				}
				str = str.substr(0, str.length - 1); //Remove trailing comma
				str += ";"
			}
			if (str.match(/;$/)) str = str.substr(0, str.length - 1)
      
			return str
    }
		getSaveString() {
      let world = this
      if(this.type !== "") world = dimensions.overworld //save overworld
      
      if(!world.edited && world.saveStr) return world.saveStr
			return world.getThisSaveString()
		}
    getNetherSaveString(){
      let world = this
      if(this.type !== "nether") world = dimensions.nether //save nether
      
      if(!world.edited && world.saveStr) return world.saveStr
			return world.getThisSaveString()
    }
    getInv(){
      let str = ""
      let arr = []
      for(let i=0; i<inventory.hotbar.length; i++){
        if(inventory.hotbar[i]){
          arr.push(inventory.hotbar[i].id)
          arr.push(inventory.hotbar[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",") + "|"
      arr = []
      for(i=0; i<invItems.length; i++){
        if(invItems[i]){
          arr.push(invItems[i].id)
          arr.push(invItems[i].amount)
        }else{
          arr.push(0)
          arr.push(0)
        }
      }
      str += arr.join(",")
      return str
    }
    getSurvivStr(){
      //survival stuff like player health
      let str = ""
      str += p.health + ","
      str += witherEffect + ","
      str += witherTime + ","
      str += witherDamage + ","
      str += world.spawnPoint.x + "," + world.spawnPoint.y + "," + world.spawnPoint.z
      return str
    }
		loadSave(str) {
      this.saveStr = str
      
			let data = str.split(";")
			if (!str.includes("Alpha")) {
				return this.loadOldSave(str)
			}

			this.name = data.shift()
			setSeed(parseInt(data.shift(), 36))

			let playerData = data.shift().split(",")
			p.x = parseInt(playerData[0], 36)
			p.y = parseInt(playerData[1], 36)
			p.z = parseInt(playerData[2], 36)
			p.rx = parseInt(playerData[3], 36) / 100
			p.ry = parseInt(playerData[4], 36) / 100
			let options = parseInt(playerData[5], 36)
      let v = data[0].replace("Alpha ","")
      let extra = verMoreThan(v, "1.0.3") || v === "1.0.3"
			p.flying = options & 1
			p.spectator = options >> 2 & 1
			superflat = options >> 1 & 3
      if(superflat === 0){superflat = false}
      if(superflat === 1){superflat = true}
      if(superflat === 2){superflat = "island"}
			caves = options >> (3+extra) & 1
			trees = options >> (4+extra) & 1
      survival = (options >> (5+extra) & 1) ? true : false

			let version = data.shift()
			this.version = version

			// if (version.split(" ")[1].split(".").join("") < 70) {
			// 	alert("This save code is for an older version. 0.7.0 or later is needed")
			// }

			let pallete = data.shift().split(",").map(n => parseInt(n, 36))
			this.loadFrom = []

			for (let i = 0; data.length; i++) {
				let blocks = data.shift().split(",")
				this.loadFrom.push({
					x: parseInt(blocks.shift(), 36),
					y: parseInt(blocks.shift(), 36),
					z: parseInt(blocks.shift(), 36),
					blocks: [],
				})
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36)
					let index = block & 0xffffff
					let pid = block >> 12
					this.loadFrom[i].blocks[index] = pallete[pid]
				}
			}
		}
    loadInv(str){
      let arr = str.split("|")
      let inv = arr[1].split(",")
      let hotb = arr[0].split(",")
      
      let len = inventory.hotbar.length
      inventory.hotbar = []
      for(let i=0; i<len*2; i+=2){
        if(hotb[i]){
          inventory.hotbar.push({
            id: parseInt(hotb[i]),
            amount: parseInt(hotb[i+1])
          })
        }else inventory.hotbar.push(0)
      }
      invItems = []
      for(let i=0; i<inv.length; i+=2){
        invItems.push({
          id: parseInt(inv[i]),
          amount: parseInt(inv[i+1])
        })
      }
    }
    loadSurvivStr(str){
      let arr = str.split(",")
      p.health = parseInt(arr[0])
      witherEffect = parseInt(arr[1])
      witherTime = parseInt(arr[2])
      witherDamage = parseInt(arr[3])
      world.spawnPoint.x = parseInt(arr[4]) || 0
      world.spawnPoint.y = parseInt(arr[5]) || 0
      world.spawnPoint.z = parseInt(arr[6]) || 0
    }
		loadOldSave(str) {
			let data = str.split(";");
			setSeed(parseInt(data.shift(), 36))
			this.id = Date.now()
			this.name = "Old World " + (Math.random() * 1000 | 0)
			let playerData = data.shift().split(",");
			p.x = parseInt(playerData[0], 36);
			p.y = parseInt(playerData[1], 36);
			p.z = parseInt(playerData[2], 36);
			p.rx = parseInt(playerData[3], 36) / 100;
			p.ry = parseInt(playerData[4], 36) / 100;
			let editCount = parseInt(data.shift(), 36);

			this.loadFrom = [];

			let coords = data.shift().split(",").map(function(n) {
				return parseInt(n, 36);
			});
			for (let j = 0; j < coords.length; j += 3) {
				this.loadFrom.push({
					x: coords[j],
					y: coords[j + 1],
					z: coords[j + 2],
					blocks: [],
				})
			}

			for (let i = 0; data.length > 0; i++) {
				let blocks = data.shift().split(",");
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36);
					let index = block >> 8;
					let id = block & 0x7f | (block & 0x80) << 1;
					this.loadFrom[i].blocks[index] = id;
				}
			}
		}
	}
  win.World = World

	// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
	let mouseS = 300

	class Slider {
		constructor(x, y, w, h, scenes, label, min, max, settingName, callback) {
			this.x = x
			this.y = y
			this.h = h
			this.w = Math.max(w, 350)
			this.name = settingName
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.label = label
			this.min = min
			this.max = max
			this.sliding = false
			this.callback = callback
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let current = (settings[this.name] - this.min) / (this.max - this.min)

			// Outline
			ctx.beginPath()
			strokeWeight(2)
			stroke(0)
			fill(85)
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			// Slider bar
			let value = round(settings[this.name])
			ctx.beginPath()
			fill(130)
			let x = this.x - (this.w - 10) / 2 + (this.w - 10) * current - 5
			ctx.fillRect(x, this.y - this.h / 2, 10, this.h)

			//Label
			fill(255, 255, 255)
			textSize(16)
			ctx.textAlign = 'center'
			text(`${this.label}: ${value}`, this.x, this.y + this.h / 8)
		}
		click() {
			if (!mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2) {
				let current = (mouseX - this.x + this.w / 2) / this.w
				if (current < 0) current = 0
				if (current > 1) current = 1
				this.sliding = true
				settings[this.name] = current * (this.max - this.min) + this.min
				this.callback(current * (this.max - this.min) + this.min)
				this.draw()
			}
		}
		drag() {
			if (!this.sliding || !this.scenes.includes(screen)) {
				return false
			}

			let current = (mouseX - this.x + this.w / 2) / this.w
			if (current < 0) current = 0
			if (current > 1) current = 1
			settings[this.name] = current * (this.max - this.min) + this.min
			this.callback(current * (this.max - this.min) + this.min)
		}
		release() {
			this.sliding = false
		}

		static draw() {
			for (let slider of Slider.all) {
				slider.draw()
			}
		}
		static click() {
			for (let slider of Slider.all) {
				slider.click()
			}
		}
		static release() {
			for (let slider of Slider.all) {
				slider.release()
			}
		}
		static drag() {
			if (mouseDown) {
				for (let slider of Slider.all) {
					slider.drag()
				}
			}
		}
		static add(x, y, w, h, scenes, label, min, max, defaut, callback) {
			Slider.all.push(new Slider(x, y, w, h, scenes, label, min, max, defaut, callback))
		}
	}
	Slider.all = []
	class Button {
		constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			this.x = x
			this.y = y
			this.h = h
			this.w = w
			this.index = 0
			this.disabled = disabled || (() => false)
			this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.labels = Array.isArray(labels) ? labels : [labels]
			this.callback = callback
		}

		mouseIsOver() {
			return mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let hovering = this.mouseIsOver()
			let disabled = this.disabled()
			let hoverText = this.hoverText()

			// Outline
			ctx.beginPath()
			
			strokeWeight(6)
      stroke(80)
			if (disabled) {
				fill(60)
				stroke(20)
			} else {
				if (hovering) {
    				cursor(HAND)
    				fill(100, 120, 200)
    				stroke(100,80,160)
    		}else{
    		    fill(120)
    		}
			}
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			
			ctx.stroke()
			ctx.fill()
			
			ctx.beginPath()
			stroke(200)
			if (hovering && !disabled)stroke(200, 200, 255);
			if(disabled)stroke(130);
			strokeWeight(3.5)
			if(disabled){
			    ctx.moveTo(this.x + (this.w / 2) + 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2) + 2, this.y + (this.h / 2)+1)
    			ctx.lineTo(this.x - this.w / 2 - 1, this.y + (this.h / 2)+1)
			}else{
    			ctx.moveTo(this.x - this.w / 2 - 2, this.y + (this.h / 2)-2)
    			ctx.lineTo(this.x - this.w / 2 - 2, this.y - this.h / 2-2)
    			ctx.lineTo(this.x + (this.w / 2)+1, this.y - this.h / 2-2)
			}
			ctx.stroke()

            stroke(0)
            strokeWeight(1)
            ctx.strokeRect(this.x-this.w/2-4, this.y-this.h/2-4, this.w+8, this.h+8)

			//Label
			textSize(16)
			ctx.textAlign = 'center'
			fill(0)
			text(this.labels[this.index], this.x +2, this.y + this.h / 8 +2)
			disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
			text(this.labels[this.index], this.x, this.y + this.h / 8)
			
			if (hovering && hoverText) {
				hoverbox.innerText = hoverText
				hoverbox.classList.remove("hidden")
				if (mouseY < height / 2) {
					hoverbox.style.bottom = ""
					hoverbox.style.top = mouseY + 10 + "px"
				} else {
					hoverbox.style.top = ""
					hoverbox.style.bottom = height - mouseY + 10 + "px"
				}
				if (mouseX < width / 2) {
					hoverbox.style.right = ""
					hoverbox.style.left = mouseX + 10 + "px"
				} else {
					hoverbox.style.left = ""
					hoverbox.style.right = width - mouseX + 10 + "px"
				}
			}
		}
		click() {
			if (this.disabled() || !mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (this.mouseIsOver()) {
				this.index = (this.index + 1) % this.labels.length
				this.callback(this.labels[this.index])
				return true
			}
		}

		static draw() {
			hoverbox.classList.add("hidden")
			for (let button of Button.all) {
				button.draw()
			}
		}
		static click() {
			for (let button of Button.all) {
				if (button.click()) {
					Button.draw()
          playSound("click")
					break
				}
			}
		}
		static add(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			Button.all.push(new Button(x, y, w, h, labels, scenes, callback, disabled, hoverText))
		}
	}
	Button.all = []

	var initEverything
	function initButtons() {
		Button.all = []
		Slider.all = []
		const nothing = () => false
		const always = () => true

		// Main menu buttons
		Button.add(width / 2, height / 2 - 20, 400, 40, "Singleplayer", "main menu", r => changeScene("loadsave menu"))
		Button.add(width / 2, height / 2 + 35, 400, 40, "Multiplayer", "main menu", r => {
      changeScene("multiplayer menu")
    }, null, "If you want multiplayer, why don't you head over to willard.fun/minekhan?")
		Button.add(width / 2, height / 2 + 90, 400, 40, "Options", "main menu", r => changeScene("options"))
    Button.add(width / 2, height / 2 + 145, 400, 40, "Marketplace", "main menu", r => changeScene("marketplace"))

		// Creation menu buttons
		Button.add(width / 2, 135, 300, 40, ["World Type: Normal", "World Type: Superflat", "World Type: Island"], "creation menu", r => {superflat = r === "World Type: Superflat"; if(r==="World Type: Island")superflat="island"})
		Button.add(width / 2, 185, 300, 40, ["Trees: On", "Trees: Off"], "creation menu", r => trees = r === "Trees: On", function() {
			if (superflat === true) {
				this.index = 1
				trees = false
			}
			return superflat === true
		})
		Button.add(width / 2, 235, 300, 40, ["Caves: On", "Caves: Off"], "creation menu", r => caves = r === "Caves: On", function() {
			if (superflat === true) {
				this.index = 1
				caves = false
			}
			return superflat === true
		})
		Button.add(width / 2, 285, 300, 40, ["Game Mode: Creative", "Game Mode: Survival"], "creation menu", r => survival = r === "Game Mode: Survival")
		Button.add(width / 2, 335, 300, 40, "Difficulty: Peaceful", "creation menu", nothing, always, "Coming soon\n\nPlease stop asking for mobs. Adding them will take a very long time. I know a lot of people want them, so just be patient.")
		Button.add(width / 2, height - 90, 300, 40, "Create New World", "creation menu", r => {
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
			changeScene("loading")
		})
		Button.add(width / 2, height - 40, 300, 40, "Cancel", "creation menu", r => changeScene(previousScreen))

		// Loadsave menu buttons
		const selected = () => !selectedWorld || !worlds[selectedWorld]
		let w4 = min(width / 4 - 10, 220)
		let x4 = w4 / 2 + 5
		let w2 = min(width / 2 - 10, 450)
		let x2 = w2 / 2 + 5
		let mid = width / 2
		Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", r => changeScene("editworld"), () => (selected() || !worlds[selectedWorld].edited))
		Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", r => {
			if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}?`)) {
				deleteFromDB(selectedWorld)
				window.worlds.removeChild(document.getElementById(selectedWorld))
				delete worlds[selectedWorld]
				selectedWorld = 0
			}
		}, () => (selected() || !worlds[selectedWorld].edited), "Delete the world forever.")
		Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", r => {
			boxCenterTop.value = worlds[selectedWorld].code
		}, selected, "Export the save code into the text box above for copy/paste.")
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "loadsave menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "loadsave menu", r => {
			dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld

			let code
      let inv
      let surviv
      let mod
      let nether
			if (!selectedWorld) {
				code = boxCenterTop.value
			} else {
				let data = worlds[selectedWorld]
				if (data) {
					code = data.code
					world.id = data.id
					world.edited = data.edited
          inv = data.inv
          surviv = data.surviv
          nether = data.nether
          try{
            world.mod = data.mod
            mod = Object.constructor("return "+data.mod)()
          }catch(e){console.log("error loading mod: "+e)}
				}
			}
			
			if (code) {
				try {
					world.loadSave(code)
					world.id = world.id || Date.now()
				}
				catch(e) {
					alert("Unable to load save")
					return
				}
			}
      if (nether) {
        let world = dimensions.nether
				try {
					world.loadSave(nether)
					world.id = world.id || Date.now()
				}
				catch(e) {
					alert("Unable to load save")
					return
				}
			}
      if(inv){
        world.loadInv(inv)
      }else if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
      if(surviv) world.loadSurvivStr(surviv)
      if(mod){
        try{mod()}catch(e){console.log(e)}
      }
      changeScene("loading")
		}, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
		Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", r => changeScene("creation menu"))

    // Edit world menu
		Button.add(mid, height / 2, w2, 40, "Save", "editworld", r => {
			let w = worlds[selectedWorld]
			w.name = boxCenterTop.value.replace(/;/g, "\u037e")
			let split = w.code.split(";")
			split[0] = w.name
			w.code = split.join(";")
      saveToDB(w.id, w).then(success => {
				initWorldsMenu()
				changeScene("loadsave menu")
			}).catch(e => console.error(e))
		})
		Button.add(mid, height / 2 + 50, w2, 40, "Back", "editworld", r => changeScene(previousScreen))
    
    // Multiplayer buttons
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "multiplayer menu", r => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "multiplayer menu", async() => {
      initMultiplayer(servers[selectedWorld].id)
    }, () => !servers[selectedWorld])

    //play buttons
    if(touchScreen){
      Button.add(mid-14, 14, 20,20, "/", "play", Messages.showInput)
      Button.add(mid+14, 14, 20,20, "❚❚", "play", r => changeScene("pause"))
    }

		// Pause buttons
		Button.add(width / 2, 225, 300, 40, "Resume", "pause", play)
		Button.add(width / 2, 275, 300, 40, "Options", "pause", r => changeScene("options"))
		Button.add(width / 2, 325, 300, 40, "Save", "pause", save, nothing, () => `Save the world to your computer/browser. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - world.edited)}.`)
		Button.add(width / 2, 375, 300, 40, "Get Save Code", "pause", r => {
			savebox.classList.remove("hidden")
			saveDirections.classList.remove("hidden")
			savebox.value = world.getSaveString()
		})
		Button.add(width / 2, 425, 300, 40, "Exit Without Saving", "pause", r => {
			savebox.value = world.getSaveString()
			initWorldsMenu()
      if(multiplayer) multiplayer.close()
			changeScene("main menu")
		})
    Button.add(width / 2, 475, 300, 40, "Enable multiplayer", "pause", async r => {
      var logged
      await loggedIn().then(r => logged = r)
      if(logged){
			  initMultiplayer()
      }
		}, () => multiplayer)
    
    // You Died buttons
    Button.add(width / 2, 225, 300, 40, "Respawn", "dead", r => {
      let spawn = world.spawnPoint
      
      p.x = spawn.x
      p.z = spawn.z
      /*p.y = 0
      while(world.getBlock(0, p.y, 0)){
        p.y ++;
        if(p.y > maxHeight) break;
      }*/
      p.y = spawn.y
      
      p.health = 18
      p.oxygen = 18
      witherEffect = 0
      harmEffect = 0
      healEffect = 0
      dieMessage = "¯\\_(ツ)_/¯"
      updateHUD = true
      play()
    })
		
		// Options buttons
		Button.add(width / 2, 430, width / 3, 40, ["Reach distance: "+normReach, "Reach distance: "+bigReach], "options", r => {
      if(r === "Reach distance: "+normReach){
        reach = normReach
      }else reach = bigReach
    })

    //Button.add(width / 2, 570, width / 3, 40, "Controls", "options", r => changeScene("controls"));
    Button.add(width / 2, 570/*640*/, width / 3, 40, "Back", "options", r => changeScene(previousScreen))
    
    // Marketplace buttons
    Button.add(60, 40, 80, 30, "Back", "marketplace", r => changeScene(previousScreen))
		Button.add(mid - x2, height - 75, w2, 40, "Download", "marketplace", saveFromMarketplace, () => !marketplace[selectedWorld])
    
		// Comingsoon menu buttons
		Button.add(width / 2, 395, width / 3, 40, "Back", "comingsoon menu", r => changeScene(previousScreen))

		// Settings Sliders
		Slider.add(width/2, 245, width / 3, 40, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val))
		Slider.add(width/2, 305, width / 3, 40, "options", "FOV", 30, 110, "fov", val => {
			p.FOV(val)
			if (world) {
				p.setDirection()
				world.render()
			}
		})
		Slider.add(width/2, 365, width / 3, 40, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val)
    Slider.add(width/2, 500, width / 3, 40, "options", "Volume", 0, 100, "soundVolume", val => settings.soundVolume = val)
	}
	function initTextures() {
		let textureSize = 256
    let textureH = 512
		let scale = 1 / (textureSize/16)
    let scaleH = 1 / (textureSize/16)
		let texturePixels = new Uint8Array(textureSize * textureH * 4)
		textureMap = {}
		textureCoords = []

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let texX = textureNum & 15
			let texY = textureNum >> 4
			let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
			texturePixels[offset] = r
			texturePixels[offset + 1] = g
			texturePixels[offset + 2] = b
			texturePixels[offset + 3] = a !== undefined ? a : 255
		}
		getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36)
			// var h = parseInt(str.substr(2, 2), 36)
			var colors = []
			var pixels = []
			var dCount = 0
			for (;str[4 + dCount] === "0"; dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36)
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36)
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ])
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36)
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3])
			}
			return pixels
		};

		{
      //get amount of textures
      var t = 0
      for(var i in textures) t++
      t = Math.ceil(t / 16) * 16
      
			// Specify the texture coords for each index
			const s = scale, sh = scaleH
			for (let i = 0; i < t; i++) {
				let texX = i & 15
				let texY = i >> 4
				let offsetX = texX * s
				let offsetY = texY * sh
				textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + sh, offsetX, offsetY + sh ]))
			}

			// Set all of the textures into 1 big tiled texture
			let n = 0
			for (let i in textures) {
				if (typeof textures[i] === "function") {
					textures[i](n)
				} else if (typeof textures[i] === "string") {
					let pix = getPixels(textures[i])
					for (let j = 0; j < pix.length; j += 4) {
						setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3])
					}
				}
				textureMap[i] = n
				n++
			}

			//Set the hitbox texture to 1 pixel
			let arr = new Float32Array(192)
			for (let i = 0; i < 192; i += 2) {
				arr[i] = textureCoords[textureMap.hitbox][0] + 0.01
				arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01
			}
			textureCoords[textureMap.hitbox] = arr
		}

		// Big texture with everything in it
		textureAtlas = gl.createTexture()
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.uniform1i(glCache.uSampler, 0)

		// Dirt texture for the background
		let dirtPixels = new Uint8Array(getPixels(textures.dirt))
		dirtTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE1)
		gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    // Netherrack texture for the background
		let netherPixels = new Uint8Array(getPixels(textures.netherrack))
		netherTexture = gl.createTexture()
		gl.activeTexture(gl.TEXTURE2)
		gl.bindTexture(gl.TEXTURE_2D, netherTexture)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, netherPixels)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)

		genIcons()
	}
	function drawIcon(x, y, id) {
    if(!blockIcons[id]) return
    
		id = id < isCube ? (id | blockMode) : id
		x =  x / (3 * height) - 0.1666 * width / height
		y = y / (3 * height) - 0.1666
		initModelView(null, x, y, 0, 0, 0)

		let buffer = blockIcons[id]
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
		gl.drawElements(gl.TRIANGLES, blockIcons.lengths[id], gl.UNSIGNED_INT, 0)
	}

	function hotbar() {
		FOV(90)
    let s = inventory.size

    ctx2.fillStyle = "white"
    ctx2.font = "14px VT323"
    ctx2.textAlign = "right"
		for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
			if(inventory.hotbar[i].id) {
				drawIcon(x, y, inventory.hotbar[i].id)
        if(survival) ctx2.fillText(inventory.hotbar[i].amount, x+(s/2), y+(s/2))
			}
		}
	}
	function hud() {
		if (p.spectator) {
			return
		}

		hotbar()

		let s = inventory.size
		let x = width / 2 + 0.5
		let y = height / 2 + 0.5
    let maxX = width / 2 - inventory.hotbar.length / 2 * s + 9.5 * s + 25
    
    textSize(10)

		// Crosshair
		if (!p.spectator) {
			ctx.lineWidth = 1
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.moveTo(x - 10, y)
			ctx.lineTo(x + 10, y)
			ctx.moveTo(x, y - 10)
			ctx.lineTo(x, y + 10)
			ctx.stroke()
		}

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5

		ctx.strokeStyle = "black"
		ctx.lineWidth = 2
		ctx.beginPath()
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		ctx.strokeStyle = "white"
		ctx.lineWidth = 2
		ctx.beginPath()

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)

    if(survival){
      var iw = 18
      var iw2 = iw/2
      var iy = y-iw-4
      //Health bar
      var outline = (healEffect < 40 && healEffect > 30) || (healEffect < 20 && healEffect > 10)
      var heartNum = Math.ceil(p.health)
      let wither = witherEffect > 0
      let i
      for(i=0; i<heartNum; i+=2){
        var heartX = (i * iw2) + x;
        if(heartNum === i+1){
          ctx.drawImage(images[wither ? "witherHalfHeart":"halfHeart"], heartX, iy, iw, iw);
        }else{
          ctx.drawImage(images[wither ? "witherHeart":"heart"], heartX, iy, iw, iw);
        }
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, iy, iw, iw);
        }
      }
      for(; i<18; i+=2){
        var heartX = (i * iw2) + x;
        ctx.drawImage(images.deadHeart, heartX, iy, iw, iw);
        if(outline){
          ctx.drawImage(images.whiteHeart, heartX, iy, iw, iw);
        }
      }
      //Oxygen bar
      if(p.oxygen !== 18){
        for(i=0; i<p.oxygen; i+=2){
          var bubbleX = (maxX - (iw*10)) + (i * iw2)
          if(p.oxygen === i+1){
            ctx.drawImage(images.bubblePop, bubbleX, iy, iw, iw);
          }else{
            ctx.drawImage(images.bubble, bubbleX, iy, iw, iw);
          }
        }
      }
    }
    
    ctx.fillStyle = "white"

		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps

		if (p.autoBreak) {
			text("Super breaker enabled", 5, height - 89, 12)
		}
    if (p.autoBuild) {
			text("Hyper builder enabled", 5, height - 101, 12)
		}
    if (multiplayer) {
			let closest = Infinity
			let cname = "Yourself"
			for (let name in players) {
				let pos = players[name]
        if(pos.dimension === world.type){
          let distance = sqrt((pos.x - p2.x)*(pos.x - p2.x) + (pos.y+1 - p2.y)*(pos.y+1 - p2.y) + (pos.z - p2.z)*(pos.z - p2.z))
          if (distance < closest) {
            closest = distance
            cname = pos.username
          }
        }
			}
      if(cname === "Yourself") closest = 0
      var info = round(closest)+" blocks away"
      if(closest === 0) info = "Right here"
			text(`Closest player: ${cname} (${info})`, 5, height - 113, 12)
		}

		ctx.textAlign = 'right'
		text(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0)
		ctx.textAlign = 'left'
		text(str, 5, height - 77, 12)
    
    
	}
  window.invScroll = 0;
  let draggingInvBar = false
  let invHeight = 0
  var barW = 20
  var invBarOffset = 0
  var barH = 0
	function drawInv(nodraw) {
		let x = 0
		let y = 0
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13

		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		ctx.fillStyle = "rgb(127, 127, 127)"
		ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx2.clearRect(0, 0, canvas.width, canvas.height)
		FOV(90)

    let count = 1;
    if(survival){
      count = invLength
    }else{
      for (let i = 1; i < BLOCK_COUNT; i++) {
        if(!blockData[i].hidden)count ++;
      }
    }
    invHeight = (Math.ceil(count / perRow) * s)
    let invWinH = s * 9;

    // Scrollbar
    barH = height * (invWinH/invHeight);
    if(draggingInvBar){
      invScroll = map(mouseY-invBarOffset, (barH/2), height-(barH/2), 0, invHeight);
      if(invScroll > invHeight) invScroll = invHeight
      if(invScroll < 0) invScroll = 0
    }
    var barYCent = map(invScroll, 0, invHeight, (barH/2), height-(barH/2));
    var barTop = barYCent - (barH/2);
    fill(100)
    ctx.fillRect(width-barW-2, 0, barW+2, height)
    fill(200)
    ctx.fillRect(width-barW, barTop, barW-2, barH)

		// Draw the grid
    ctx.translate(0, -(invScroll % s))
		ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s)
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s)
		}
		y--
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2)
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s)
		}
    ctx.translate(0, invScroll % s)

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot
			ctx.lineWidth = 2
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.strokeRect(x, y, s, s)
		}
    
		//Box highlight in inv
		let overInv = Math.round(((mouseY + invScroll) - 50) / s) * perRow + Math.round((mouseX - 50) / s)
		if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2
			y = (overInv / perRow | 0) * s + 50 - s2
      y -= invScroll
      if(mouseY < s*9.5){
        ctx.lineWidth = 2
        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.strokeRect(x, y, s, s)
      }
		}

		if (inventory.holding && inventory.holding.id) {
			drawIcon(mouseX, mouseY, inventory.holding.id)
		}
    
    if(survival){
      ctx2.fillStyle = "white"
      ctx2.font = "14px VT323"
      ctx2.textAlign = "right"
      for (let i = 0; i < invLength; i++) {
        if(invItems[i] && invItems[i].id){
          x = (i) % perRow * s + 50
          y = ((i) / perRow | 0) * s + 50
          drawIcon(x, y - invScroll, invItems[i].id)
          ctx2.fillText(invItems[i].amount, x+(s/2), y+(s/2))
        }
      }
    }else{
      let invIdx = 0;
      for (let i = 1; i < BLOCK_COUNT; i++) {
        invIdx ++;
        if(blockData[i].hidden){
          while(blockData[i].hidden) i++
        }

        x = (invIdx - 1) % perRow * s + 50
        y = ((invIdx - 1) / perRow | 0) * s + 50
        y -= invScroll
        if(y < s*9.5){
          drawIcon(x, y, i)
        }
      }
    }
    
		hotbar()
		//hud()
		ctx.drawImage(gl.canvas, 0, 0)
    
    // show block name on hover
    if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow
			y = (overInv / perRow | 0)
      
      var wrongidx = x+(y*perRow)+1;
      var idx=1;
      if(survival){
        idx = wrongidx - 1
      }else{
        for(var i=1; i<wrongidx; i++){
          idx++;
          if(blockData[i+1] && blockData[i+1].hidden){
            /*let i2 = idx
            while(blockData[i2] && blockData[i2].hidden){
              i2++
              idx++
            }*/
            idx++
          }
        }
      }
      let name;
      if(survival){
        let id = invItems[idx] ? invItems[idx].id : 0
        name = id ? blockData[id].name : "";
      }else{
        name = blockData[idx] ? blockData[idx].name : "";
      }
      if((name !== "") && mouseY<s*9.5){
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
		}
    
    if(!nodraw)ctx.drawImage(canvas2, 0,0)
	}
	function clickInv(dontRedraw) {
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
    
    if(!survival){
      var idx = 0;
      for(var i=1; i<over+1; i++){
        if(!blockData[i]) break;

        idx ++;
        if(blockData[i+1] && blockData[i+1].hidden)idx++;
      }
      over = idx;
    }
    
    let count = survival ? invLength : BLOCK_COUNT - 1
    
    //for crafting
    let offX = width - s*4
    let offY = s * 2
    
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot]
			inventory.hotbar[overHot] = inventory.holding
			inventory.holding = temp
		} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
      if(survival){
        if(invItems[over] && invItems[over].id){
          let temp = inventory.holding
          if(temp.amount < 64 && invItems[over].amount < 64 && temp.id === invItems[over].id){ //stacking together
            while(temp.amount > 0){
              temp.amount--
              invItems[over].amount ++
              if(invItems[over].amount >= 64) break
            }
            if(temp.amount <= 0){
              temp.id = 0
            }
          }else{
            inventory.holding = invItems[over]
            invItems[over] = {id:0,amount:0}
            if(temp && temp.id){
              invItems[over] = temp
            }
          }
        }else if(inventory.holding){
          invItems[over] = inventory.holding
          inventory.holding = 0
        }
      }else{
			  inventory.holding = {id:over + 1, amount:64}
      }
		} else if(screen === "crafting" && mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){
      let X = Math.floor((mouseX - offX) / s)
      let Y = Math.floor((mouseY - offY) / s)
      let idx = (Y*3)+X
      let temp = inventory.holding
      inventory.holding = inventory.crafting[idx]
      inventory.crafting[idx] = temp
    }else{
			inventory.holding = 0
		}

		if(!dontRedraw)drawScreens.inventory()
	}

  function drawCrafting() {
    drawInv(true)
    let s = inventory.size
    let s2 = s/2
    
    gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
    
    let offX = width - s*4
    let offY = s * 2
    //draw grid
    ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
    let y = s*3+offY
    let x
    for(x=0; x<4; x++){
      ctx.moveTo(x*s+offX, offY)
      ctx.lineTo(x*s+offX, y)
    }
    x = s*3+offX
    for(y=0; y<4; y++){
      ctx.moveTo(offX, y*s+offY)
      ctx.lineTo(x, y*s+offY)
    }
    ctx.stroke()
    
    //icons
    ctx2.font = "14px VT323"
    ctx2.textAlign = "right"
    ctx2.fillStyle = "white"
    for(y=0; y<3; y++){
      for(x=0; x<3; x++){
        let idx = (y*3) + x
        if(inventory.crafting[idx] && inventory.crafting[idx].id){
          let X = x*s+offX, Y = y*s+offY
          drawIcon(X+s2,Y+s2, inventory.crafting[idx].id)
          ctx2.fillText(inventory.crafting[idx].amount, X+s, Y+s)
        }
      }
    }
    
    x = Math.floor((mouseX - offX) / s)
    y = Math.floor((mouseY - offY) / s)
    let over = (y * 3) + x
    if(!(x >= 0 && x < 3 && y >= 0 && y < 3)){
      over = -1
    }else if(over > -1 && over < 9){
      ctx.lineWidth = 2
      ctx.strokeStyle = "white"
      ctx.strokeRect(x*s+offX, y*s+offY, s,s)
    }
    
    x = offX + (s)
    y = offY + (s*4)
    over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    ctx.lineWidth = over?2:1
    ctx.strokeStyle = over?"white":"black"
    ctx.strokeRect(x,y, s,s)
    if(inventory.craftingRes && inventory.craftingRes.id){
      drawIcon(x+s2, y+s2, inventory.craftingRes.id)
      ctx2.font = "14px VT323"
      ctx2.textAlign = "right"
      ctx2.fillStyle = "white"
      ctx2.fillText(inventory.craftingRes.amount, x+s, y+s)
    }
    
    ctx.drawImage(gl.canvas,0,0)
    
    if(inventory.craftingRes && inventory.craftingRes.id){
      let name = blockData[inventory.craftingRes.id].name
      if(name !== "" && over){
        ctx.textAlign = "left"
        ctx.font = "16px VT323";
        var w = ctx.measureText(name).width;
        fill(0)
        ctx.fillRect(mouseX, mouseY, w+20, 20);
        
        fill(255);
        ctx.fillText(name, mouseX+10, mouseY+13+2);
      }
    }
    
    ctx.drawImage(canvas2,0,0)
  }
  
  function clickCrafting() {
    clickInv(true)
    
    let s = inventory.size
    let s2 = s/2
    let offX = width - s*4
    let offY = s * 2
    
    let x = offX + (s)
    let y = offY + (s*4)
    let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
    if(over && inventory.craftingRes && inventory.craftingRes.id){
      inventory.holding = Object.assign({}, inventory.craftingRes)
      for(let i=0; i<9; i++){
        let block = inventory.crafting[i]
        if(block && block.id){
          block.amount --
          if(block.amount < 1)inventory.crafting[i].id = 0
        }
      }
    }
    
    let arr = []
    inventory.crafting.forEach((v) => arr.push(v?v.id:0))
    let recipe = inventory.craftingStr = arr.join(",")
    if(crafts[recipe]){
      inventory.craftingRes = crafts[recipe]
    }else inventory.craftingRes = 0
    
    drawScreens.crafting()
  }

	let unpauseDelay = 0
	function mmoved(e) {
		let mouseS = settings.mouseSense / 30000
		p.rx -= e.movementY * mouseS
		p.ry += e.movementX * mouseS

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2
		}
	}
	function trackMouse(e) {
		if (screen !== "play") {
			cursor("")
			mouseX = e.x
			mouseY = e.y
      if(screen !== "main menu"){
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
        Slider.drag()
      }
		}
	}
	document.onmousemove = trackMouse
  
  //added by me from mobile test minekhan
	//https://www.khanacademy.org/computer-programming/mobile-test-minekhan/5100360783052800
	let pTouch = {x: -100, y: 0};
	canvas.addEventListener("touchstart", function(e) {
	    pTouch.x = e.changedTouches[0].pageX;
	    pTouch.y = e.changedTouches[0].pageY;
	}, false);
	canvas.addEventListener("touchmove", function(e) {
	    e.movementY = e.changedTouches[0].pageY - pTouch.y;
	    e.movementX = e.changedTouches[0].pageX - pTouch.x;
	    pTouch.x = e.changedTouches[0].pageX;
	    pTouch.y = e.changedTouches[0].pageY;
	    mmoved(e);
	    e.preventDefault();
	}, false);
	//end added part
	canvas.addEventListener("touchstart",function(){
	    mouseDown=true
	})
	canvas.addEventListener("touchend",() => mouseDown=false)
  canvas.addEventListener("touchcancel",() => mouseDown=false)
  
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved
		} else {
			doc.onmousemove = trackMouse
			if (screen === "play" && !freezeFrame) {
				changeScene("pause")
				unpauseDelay = Date.now() + 1000
			}
		}
		for (let key in Key) {
			Key[key] = false
		}
	}
	canvas.onmousedown = function(e) {
		mouseX = e.x
		mouseY = e.y
		mouseDown = true
		let block, index
		switch(e.button) {
			case 0:
				Key.leftMouse = true
				break
			case 1:
				Key.middleMouse = true
				if (!hitBox.pos) break
				updateHUD = true
				block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) & 0x3ff
				index = inventory.hotbar.indexOf(block)
				if (index >= 0) {
					inventory.hotbarSlot = index
				} else {
					inventory.hotbar[inventory.hotbarSlot] = block
				}
				break
			case 2:
				Key.rightMouse = true
				break
		}
		if(screen === "play") {
			if (doc.pointerLockElement !== canvas) {
				getPointer()
				p.lastBreak = Date.now()
			} else {
				place = false
				if(e.button === 0) {
					if(Key.control) {
						place = true
					} else if(!survival){
						changeWorldBlock(0)
					}
				}
				holding = inventory.hotbar[inventory.hotbarSlot].id
				if(e.button === 2 && holding) {
					place = true
				}
				if(place) {
					newWorldBlock()
				}
			}
		} else if (screen === "inventory" || screen === "crafting") {
      if(mouseDown && mouseX >= width-barW){
        draggingInvBar = true
        invBarOffset = mouseY-map(invScroll, 0, invHeight, (barH/2), height-(barH/2))
      }
      if(screen === "crafting")clickCrafting()
        else clickInv()
		}

		Button.click()
		Slider.click()
	}
	canvas.onmouseup = function(e) {
		switch(e.button) {
			case 0:
				Key.leftMouse = false
				break
			case 1:
				Key.middleMouse = false
				break
			case 2:
				Key.rightMouse = false
				break
		}
		mouseDown = false
		Slider.release()
    
    draggingInvBar = false
	}
  
  for(var onscreencontrol in onscreenControls){
	    var onscreencontrolElement = onscreenControls[onscreencontrol]
	    onscreencontrolElement.value = onscreencontrol
	    onscreencontrolElement.onmousedown=function(){
	        canvas.onkeydown({key:this.value})
	    }
	    onscreencontrolElement.onmouseup=function(){
	        canvas.onkeyup({key:this.value})
	    }
	    onscreencontrolElement.addEventListener("touchstart",onscreencontrolElement.onmousedown)
	    onscreencontrolElement.addEventListener("touchend",onscreencontrolElement.onmouseup)
      onscreencontrolElement.addEventListener("touchcancel",onscreencontrolElement.onmouseup)
	}
	onscreenControls[" "].addEventListener("click",function(){
    if (!survival && !p.spectator) {//fly toggle
			if (Date.now() < p.lastJump + 400) {
				p.flying ^= true
			} else {
				p.lastJump = Date.now()
			}
		}
	})
  let lastForward = 0
  onscreenControls.w.addEventListener("touchstart",function(){
			if (Date.now() < lastForward + 400) { //sprint toggle
				player.sprinting = true
			} else {
				lastForward = Date.now()
			}
	})
  onscreenControls.w.addEventListener("touchend",() => p.sprinting = false)
  onscreenControls.w.addEventListener("touchcancel",() => p.sprinting = false)
	onscreenControls[" "].addEventListener("mousedown",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("mouseup",function(){
	    Key[" "]=false
	})
	onscreenControls[" "].addEventListener("touchstart",function(){
	    Key[" "]=true
	})
	onscreenControls[" "].addEventListener("touchend",function(){
	    Key[" "]=false
	})
	
  onscreenControl_Element.onclick = e => {mouseX = e.x; mouseY = e.y}
  
  let changeSlot = () => {
    for(let i = 0; i < inventory.hotbar.length; i ++) {
      let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
		  let y = height - inventory.size
      
      x -= inventory.size/2
		  y -= inventory.size/2
			if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
			  inventory.hotbarSlot = i
			  holding = inventory.hotbar[inventory.hotbarSlot]
			  updateHUD = true
			}
		}
  }
	onscreenControl_Element.addEventListener("click",changeSlot)
	onscreenControl_Element.addEventListener("touchend",changeSlot)
  
	canvas.onkeydown = function(e) {
		let k = e.key.toLowerCase()
		if (e.preventDefault && k === " ") {
			e.preventDefault()
		}
		if (e.repeat || Key[k]) {
			return
		}
		Key[k] = true

		if (k === "t") {
			initTextures()
		}

		if (k === "enter") {
			blockMode = blockMode === CUBE ? SLAB : (blockMode === SLAB ? STAIR : (blockMode === STAIR ? FENCE : (blockMode === FENCE ? WALLPOST : (blockMode === WALLPOST ? WALL : (blockMode === WALL ? WALLU : (blockMode === WALLU ? FENCQ : CUBE))))))
			updateHUD = true
		}

		if (screen === "play") {
			if(k === "p") {
				releasePointer()
				changeScene("pause")
			}

			if(k === "b") {
				p.autoBreak = !p.autoBreak
				updateHUD = true
        if(survival) p.autoBreak = false
			}
      if(k === "h") {
				p.autoBuild = !p.autoBuild
				updateHUD = true
        if(survival) p.autoBuild = false
			}

			if (k === " " && !p.spectator) {
				if (Date.now() < p.lastJump + 400) {
					p.flying ^= true
          if(survival) p.flying = false
				} else {
					p.lastJump = Date.now()
				}
			}

			if (k === "z") {
				p.FOV(10, 300)
			}

			if (k === "shift" && !p.flying) {
				p.sneaking = true
				if (p.sprinting) {
					p.FOV(settings.fov, 100)
				}
				p.sprinting = false
				p.speed = 0.03
				p.bottomH = 1.32
			}

			if (k === "l" && !survival) {
				p.spectator = !p.spectator
				p.flying = true
				p.onGround = false
				updateHUD = true
			}
      if (k === "o"){
        p.thirdPerson = !p.thirdPerson
      }

			if (k === "e") {
				changeScene("inventory")
				releasePointer()
			}

			if (k === ";") {
				releasePointer()
				freezeFrame = true
			}
      
      if(k === "/"){
        Messages.showInput()
      }

			if (Key.backspace && inventory.hotbar[inventory.hotbarSlot] && inventory.hotbar[inventory.hotbarSlot].id) {
				let d = p.direction
        let block = holding || inventory.hotbar[inventory.hotbarSlot].id
        block = block < isCube ? block | blockMode : block
				world.addEntity(new Item(p.x + (d.x), p.y + (d.y), p.z + (d.z), d.x/4, d.y/4, d.z/4, block))
        if(survival){
          inventory.hotbar[inventory.hotbarSlot].amount --
          updateHUD = true
        }
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1
				holding = inventory.hotbar[inventory.hotbarSlot].id
				updateHUD = true
			}
		} else if (screen === "pause") {
			if(k === "p") {
				play()
			}
		} else if (screen === "inventory" || screen === "crafting") {
			if (k === "e") {
        if(screen === "crafting"){
          for(var i=0; i<9; i++){
            if(inventory.crafting[i] && inventory.crafting[i].id){
              for(var n=0; n<inventory.crafting[i].amount; n++)newInvItem(inventory.crafting[i].id)
              inventory.crafting[i].id = 0
            }
          }
          inventory.craftingRes = 0
        }
				play()
			}
			if (k === "enter") {
				drawScreens.inventory()
			}
		}
	}
	canvas.onkeyup = function(e) {
		let k = e.key.toLowerCase()
		Key[k] = false
		if(k === "escape" && (screen === "pause" || screen === "inventory" || screen === "options" && previousScreen === "pause") && Date.now() > unpauseDelay) {
			play()
		}
		if (screen === "play") {
			if (k === "z") {
				p.FOV(settings.fov, 300)
			}

			if (k === "shift" && p.sneaking) {
				p.sneaking = false
				p.speed = 0.075
				p.bottomH = 1.62
				// p.y += 0.3
			}
		}
	}
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false
		}
		mouseDown = false
		Slider.release()
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault()
	}
	window.onbeforeunload = e => { 
		if (screen === "play" && Key.control) {
			releasePointer()
			e.preventDefault()
			e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
			return true
		}
	}
	canvas.onwheel = e => {
		e.preventDefault()
		e.stopPropagation()
		if (e.deltaY > 0) {
			inventory.hotbarSlot++
		} else if (e.deltaY < 0) {
			inventory.hotbarSlot--
		}
		if (inventory.hotbarSlot > 8) {
			inventory.hotbarSlot = 0
		} else if (inventory.hotbarSlot < 0) {
			inventory.hotbarSlot = 8
		}

		updateHUD = true
		holding = inventory.hotbar[inventory.hotbarSlot].id
	}
	document.onwheel = e => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
	window.onresize = e => {
		width = window.innerWidth
		height = window.innerHeight
		canvas.height = height
		canvas.width = width
    canvas2.width = width
    canvas2.height = height
		gl.canvas.height = height
		gl.canvas.width = width
		gl.viewport(0, 0, width, height)
		initButtons()
		initBackgrounds()
		inventory.size = 40 * min(width, height) / 600
		genIcons()
		use3d()
		p.FOV(p.currentFov + 0.0001)

		if (screen === "play") {
			play()
		} else {
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
		}
	}

	function use2d() {
		gl.disableVertexAttribArray(glCache.aTexture)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aVertex)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.useProgram(program2D)
		
		gl.enableVertexAttribArray(glCache.aVertex2)
		gl.enableVertexAttribArray(glCache.aTexture2)
		gl.enableVertexAttribArray(glCache.aShadow2)
	}
	function use3d() {
		gl.disableVertexAttribArray(glCache.aTexture2)
		gl.disableVertexAttribArray(glCache.aShadow2)
		gl.disableVertexAttribArray(glCache.aVertex2)
		gl.useProgram(program3D)
		
		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
	}

	let maxLoad = 1
	function startLoad() {
		// Runs when the loading screen is opened; cache the player's position
		p2.x = p.x
		p2.y = p.y
		p2.z = p.z
		maxLoad = world.loadFrom.length + 9
	}
	function initWebgl() {
		if (!win.gl) {
			let canv = document.createElement('canvas')
			canv.width = ctx.canvas.width
			canv.height = ctx.canvas.height
			canv.style.position = "absolute"
			canv.style.zIndex = -1
			canv.style.top = "0px"
			canv.style.left = "0px"
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false })
			let ext = gl.getExtension('OES_element_index_uint')
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height)
			gl.enable(gl.DEPTH_TEST)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
			win.gl = gl
			glExtensions = []
			const availableExtensions = gl.getSupportedExtensions()
			for (let i = 0; i < availableExtensions.length; i++) {
				const extensionName = availableExtensions[i]
				glExtensions[extensionName.replace(/[A-Z]+_/g, "")] = gl.getExtension(extensionName)
			}
		} else {
			gl = win.gl
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas)
		}

		modelView = new Float32Array(16)
		glCache = {}
		win.glCache = glCache
		program3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D)
		program2D = createProgramObject(gl, vertexShaderSrc2D, fragmentShaderSrc2D)
		programEntity = createProgramObject(gl, vertexShaderSrcEntity, fragmentShaderSrcEntity)
    programParticle = createProgramObject(gl, vertexShaderSrcParticle, fragmentShaderSrcParticle)
		
		gl.useProgram(program2D)
		glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
		glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
		glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
		glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")

		gl.useProgram(programEntity)
		glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
		glCache.uLightLevelEntity = gl.getUniformLocation(programEntity, "uLightLevel")
		glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
		glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
		glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")
    
    gl.useProgram(programParticle)
		glCache.uSamplerParticle = gl.getUniformLocation(programParticle, "uSampler")
		glCache.uLightLevelParticle = gl.getUniformLocation(programParticle, "uLightLevel")
		glCache.uViewParticle = gl.getUniformLocation(programParticle, "uView")
		glCache.aTextureParticle = gl.getAttribLocation(programParticle, "aTexture")
		glCache.aVertexParticle = gl.getAttribLocation(programParticle, "aVertex")

		gl.useProgram(program3D)
		glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
		glCache.uPos = gl.getUniformLocation(program3D, "uPos")
		glCache.uDist = gl.getUniformLocation(program3D, "uDist")
		glCache.uTime = gl.getUniformLocation(program3D, "uTime")
		glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
		glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
		glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
		glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
		glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")
    glCache.skyColor = gl.getUniformLocation(program3D, "skyColor")

		gl.uniform1f(glCache.uDist, 1000)

		//Send the block textures to the GPU
		initTextures()
    initShapes()

		// These buffers are only used for drawing the main menu blocks
		sideEdgeBuffers = {}
		for (let side in shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW)
			sideEdgeBuffers[side] = edgeBuffer
		}
		texCoordsBuffers = []
		for (let t in textureCoords) {
			let buff = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buff)
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW)
			texCoordsBuffers.push(buff)
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.lineWidth(2)
		blockOutlines = false
		gl.enable(gl.POLYGON_OFFSET_FILL)
		gl.polygonOffset(1, 1)
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
	}
	function initBackgrounds() {
		// Home screen background
    const HALF_PI = Math.PI / 2
    const blocks = [
      7, 4, 1, 7,
      7, 4, 2, 7,
      7, 4, 3, 7,
      7, 4, 4, 7,
      7, 5, 1, 7,
      7, 5, 2, 7,
      7, 5, 3, 7,
      6, 4, 0, 7,
      6, 4, 1, 7,
      6, 4, 2, 7,
      6, 4, 3, 7,
      6, 4, 4, 7,
      6, 5, 0, 7,
      6, 5, 1, 7,
      6, 5, 2, 7,
      6, 5, 3, 7,
      6, 5, 4, 7,
      6, 6, 3, 7,
      6, 6, 4, 7,
      6, 7, 3, 7,
      5, 0, -1, 1,
      5, 0, 0, 1,
      5, 0, 1, 1,
      5, 0, 2, 1,
      5, 1, 2, 29,
      5, 2, 2, 29,
      5, 3, 2, 29,
      5, 4, 2, 29,
      5, 5, 2, 29,
      5, 6, 2, 29,
      5, 4, 0, 7,
      5, 4, 1, 7,
      5, 4, 3, 7,
      5, 4, 4, 7,
      5, 5, 0, 7,
      5, 5, 1, 7,
      5, 5, 3, 7,
      5, 5, 4, 7,
      5, 6, 1, 7,
      5, 6, 3, 7,
      5, 7, 1, 7,
      5, 7, 2, 7,
      5, 7, 3, 7,
      4, -1, -1, 1,
      4, -1, 0, 1,
      4, -1, 1, 1,
      4, -1, 2, 1,
      4, 0, 3, 1,
      4, 0, 4, 1,
      4, 0, 5, 1,
      4, 0, 6, 1,
      4, 0, 7, 5,
      4, 0, 8, 5,
      4, 0, 9, 5,
      4, 0, 10, 5,
      4, 4, 0, 7,
      4, 4, 1, 7,
      4, 4, 2, 7,
      4, 4, 3, 7,
      4, 4, 4, 7,
      4, 5, 0, 7,
      4, 5, 1, 7,
      4, 5, 2, 7,
      4, 5, 3, 7,
      4, 5, 4, 7,
      4, 6, 1, 7,
      4, 6, 2, 7,
      4, 6, 3, 7,
      4, 7, 4, 7,
      3, -1, -1, 1,
      3, -1, 0, 1,
      3, -1, 1, 1,
      3, -1, 2, 1,
      3, -1, 3, 1,
      3, -1, 4, 1,
      3, 0, 5, 1,
      3, 0, 6, 1,
      3, 0, 7, 1,
      3, 0, 8, 5,
      3, 0, 9, 5,
      3, 0, 10, 5,
      3, 4, 1, 7,
      3, 4, 2, 7,
      3, 4, 3, 7,
      3, 4, 4, 7,
      3, 5, 1, 7,
      3, 5, 2, 7,
      3, 5, 3, 7,
      2, -1, -1, 1,
      2, -1, 0, 1,
      2, -1, 1, 1,
      2, -1, 2, 1,
      2, -1, 3, 1,
      2, -1, 4, 1,
      2, -1, 5, 1,
      2, -1, 6, 1,
      2, -1, 7, 1,
      2, 0, 8, 5,
      2, 0, 9, 5,
      2, 0, 10, 5,
      1, -2, -1, 1,
      1, -2, 0, 1,
      1, -2, 1, 1,
      1, -2, 2, 1,
      1, -2, 3, 1,
      1, -1, 4, 1,
      1, -1, 5, 1,
      1, -1, 6, 1,
      1, -1, 7, 1,
      1, -1, 8, 1,
      1, -1, 9, 5,
      1, -1, 10, 5,
      0, -2, -1, 1,
      0, -2, 0, 1,
      0, -2, 1, 1,
      0, -2, 2, 1,
      0, -2, 3, 1,
      0, -2, 4, 1,
      0, -2, 5, 1,
      0, -1, 6, 1,
      0, -1, 7, 1,
      0, -1, 8, 1,
      0, -1, 9, 5,
      0, -1, 10, 5,
      -1, -2, -1, 1,
      -1, -2, 0, 1,
      -1, -2, 1, 1,
      -1, -2, 2, 1,
      -1, -2, 3, 1,
      -1, -2, 4, 1,
      -1, -2, 5, 1,
      -1, -2, 6, 1,
      -1, -2, 7, 1,
      -1, -1, 8, 1,
      -1, -1, 9, 1,
      -1, -1, 10, 1,
      -2, -2, -1, 1,
      -2, -2, 0, 1,
      -2, -2, 1, 1,
      -2, -2, 2, 1,
      -2, -2, 3, 1,
      -2, -2, 4, 1,
      -2, -2, 5, 1,
      -2, -2, 6, 1,
      -2, -2, 7, 1,
      -2, -2, 8, 1,
      -2, -2, 9, 1,
      -2, -1, 10, 1,
      -3, -2, -1, 1,
      -3, -2, 0, 1,
      -3, -2, 1, 1,
      -3, -2, 2, 1,
      -3, -2, 3, 1,
      -3, -2, 4, 1,
      -3, -2, 5, 1,
      -3, -2, 6, 1,
      -3, -2, 7, 1,
      -3, -2, 8, 1,
      -3, -2, 9, 1,
      -3, -2, 10, 1,
      -3, -2, 11, 1,
      -3, -2, 12, 1,
      -4, -2, -1, 1,
      -4, -2, 0, 1,
      -4, -2, 1, 1,
      -4, -2, 2, 1,
      -4, -2, 3, 1,
      -4, -2, 4, 1,
      -4, -2, 5, 1,
      -4, -2, 6, 1,
      -4, -2, 7, 1,
      -4, -2, 8, 1,
      -4, -2, 9, 1,
      -4, -2, 10, 1,
      -4, -2, 11, 1,
      -4, -2, 12, 1,
      -5, -2, -1, 1,
      -5, -2, 0, 1,
      -5, -2, 1, 1,
      -5, -2, 2, 1,
      -5, -2, 3, 1,
      -5, -2, 4, 1,
      -5, -2, 5, 1,
      -5, -2, 6, 1,
      -5, -2, 7, 1,
      -5, -2, 8, 1,
      -5, -2, 9, 1,
      -5, -2, 10, 1,
      -5, -2, 11, 1,
      -5, -2, 12, 1,
      -6, -2, -1, 1,
      -6, -2, 0, 1,
      -6, -2, 1, 1,
      -6, -2, 2, 1,
      -6, -2, 3, 1,
      -6, -2, 4, 1,
      -6, -2, 5, 1,
      -6, -2, 6, 1,
      -6, -2, 7, 1,
      -6, -2, 8, 1,
      -6, -2, 9, 1,
      -6, -2, 10, 1,
      -6, -2, 11, 1,
      -7, -2, 3, 1,
      -7, -2, 4, 1,
      -7, -2, 5, 1,
      -7, -2, 6, 1,
      -7, -2, 7, 1,
      -7, -2, 8, 1,
      -7, -2, 9, 1,
      -8, -2, 2, 1,
      -8, -2, 3, 1,
      -8, -2, 4, 1,
      -8, -2, 5, 1,
      -8, -2, 6, 1,
      -8, -2, 7, 1,
      -8, -2, 8, 1,
      -8, -1, 8, 33,//birch tree
      -8, 0, 8, 33,
      -9, 1, 10, 7,
      -8, 1, 10, 7,
      -7, 1, 10, 7,
      -10, 1, 9, 7,
      -9, 1, 9, 7,
      -8, 1, 9, 7,
      -7, 1, 9, 7,
      -6, 1, 9, 7,
      -10, 1, 8, 7,
      -9, 1, 8, 7,
      -8, 1, 8, 7,
      -7, 1, 8, 7,
      -6, 1, 8, 7,
      -10, 1, 7, 7,
      -9, 1, 7, 7,
      -8, 1, 7, 7,
      -7, 1, 7, 7,
      -6, 1, 7, 7,
      -9, 1, 6, 7,
      -8, 1, 6, 7,
      -7, 1, 6, 7,
      -9, 2, 10, 7,
      -8, 2, 10, 7,
      -7, 2, 10, 7,
      -10, 2, 9, 7,
      -9, 2, 9, 7,
      -8, 2, 9, 7,
      -7, 2, 9, 7,
      -6, 2, 9, 7,
      -10, 2, 8, 7,
      -9, 2, 8, 7,
      -8, 2, 8, 7,
      -7, 2, 8, 7,
      -6, 2, 8, 7,
      -10, 2, 7, 7,
      -9, 2, 7, 7,
      -8, 2, 7, 7,
      -7, 2, 7, 7,
      -6, 2, 7, 7,
      -9, 2, 6, 7,
      -8, 2, 6, 7,
      -7, 2, 6, 7,
      -7, 3, 8, 7,//topper leaves
      -9, 3, 8, 7,
      -8, 3, 7, 7,
      -8, 3, 9, 7,
      -7, 4, 8, 7,
      -9, 4, 8, 7,
      -8, 4, 7, 7,
      -8, 4, 9, 7,
      3, 1, 8, 141,//cactus
      3, 2, 8, 141,
    ];
    var mainBG = document.createElement("canvas");
    mainBG.width = gl.canvas.width;
    mainBG.height = gl.canvas.height;
    var mainBGRot = -HALF_PI / 3;
    win.renderMainBG = function(){
      mainBGRot += 0.01;
      if(mainBGRot > Math.PI*2){
        mainBGRot = 0;
      }
      
      use3d()
      gl.clearColor(sky[0], sky[1], sky[2], 1.0)
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
      FOV(100)
      initModelView(null, 1, 1.5, 5, -HALF_PI / 25, mainBGRot/*-HALF_PI / 3*/)
      gl.disableVertexAttribArray(glCache.aShadow)
      gl.disableVertexAttribArray(glCache.aSkylight)
      gl.disableVertexAttribArray(glCache.aBlocklight)
      gl.vertexAttrib1f(glCache.aShadow, 1.0)
      gl.vertexAttrib1f(glCache.aSkylight, 1.0)
      gl.vertexAttrib1f(glCache.aBlocklight, 1.0)

      gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
      for (let i = 0; i < blocks.length; i += 4) {
        block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
      }

      gl.enableVertexAttribArray(glCache.aShadow)
      gl.enableVertexAttribArray(glCache.aSkylight)
      gl.enableVertexAttribArray(glCache.aBlocklight)
    }

		// Dirt background
		use2d()
		let aspect = width / height
		let stack = height / 96
		let bright = 0.4
		if (dirtBuffer) {
			gl.deleteBuffer(dirtBuffer)
		}
		dirtBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
		let bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 1)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		let pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		dirtbg = ctx.createImageData(width, height)
		dirtbg.data.set(pixels)
    
    // Netherrack background
		bright = 0.4
		if (netherBuffer) {
			gl.deleteBuffer(netherBuffer)
		}
		netherBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, netherBuffer)
		bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 2) //netherrack textures uses TEXTURE2 so the number is 2
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		netherbg = ctx.createImageData(width, height)
		netherbg.data.set(pixels)
	}
	function initPlayer() {
		p = new Camera()
		p.speed = 0.075
		p.velocity = new PVector(0, 0, 0)
		p.pos = new Float32Array(3)
		p.sprintSpeed = 1.5
		p.flySpeed = 2.5
		p.x = 8
		p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
		p.z = 8
		p.previousX = 8
		p.previousY = 70
		p.previousZ = 8
		p.w = 3 / 8
		p.bottomH = 1.62
		p.topH = 0.18
		p.onGround = false
		p.jumpSpeed = 0.3
		p.sprinting = false
		p.maxYVelocity = 1.5
		p.gravityStength = -0.032
		p.lastUpdate = performance.now()
		p.lastBreak = Date.now()
		p.lastPlace = Date.now()
		p.lastJump = Date.now()
		p.autoBreak = false
    p.autoBuild = false
		p.flying = false
		p.sneaking = false
		p.spectator = false
    p.health = 18
    p.oxygen = 18
    p.lastY = 0 //y the last time it touched the ground
    p.character = new Character(1)
    p.thirdPerson = false
    p.hand = new PlayerHand()
		
		win.player = p
		win.p2 = p2
	}
	function initWorldsMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, version, size, id, edited) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.worlds.appendChild(div)
		}

		worlds = {}
		if (loadString) {
			try {
				let tempWorld = new World()
				tempWorld.loadSave(loadString)
				let now = Date.now()
				addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
				worlds[now] = {
					code: loadString,
					id: now
				}
			}
			catch(e) {
				console.log("Unable to load hardcoded save.")
				console.error(e)
			}
		}
		loadFromDB().then(res => {
			if(res && res.length) {
				let index = res.findIndex(obj => obj.id === "settings")
				if (index >= 0) {
					Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
					p.FOV(settings.fov)
					res.splice(index, 1)
				}
			}
			
			if (res && res.length) {
				res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
				for (let data of res) {
					addWorld(data.name, data.version, (data.code.length + 60), data.id, data.edited)
					worlds[data.id] = data
				}
			}
			window.worlds.onclick = Button.draw
			window.boxCenterTop.onkeyup = Button.draw
		}).catch(e => console.error(e))

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  var servers = {}
  async function initServersMenu() {
		while (window.servers.firstChild) {
			window.servers.removeChild(window.servers.firstChild)
		}
		selectedWorld = null

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, id, host, players) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
      div.innerHTML += "Hosted by "+host + br
      div.innerHTML += players.length+" player"+(players.length===1 ? "" : "s")+" online"
			
      servers[id] = {
        id:id,
        name:name,
        host:host
      }
			window.servers.appendChild(div)
		}

		var worlds;
    await getWorlds().then(r => worlds=r)
    worlds.forEach(r => addWorld(r.name, r.id, r.host, r.players))
    
		window.servers.onclick = Button.draw

		superflat = false
		trees = true
		caves = true
    survival = false
	}
  let marketplace = {}; win.marketplaceData = null
  async function initMarketplace(){
    marketplaceData = await fetch("https://Minekhan.thingmaker.repl.co/maps.json")
    await new Promise((resolve, reject) => {
      marketplaceData.text().then(r => {marketplaceData = JSON.parse(r); resolve()})
    })
    
    marketplace = {}
    window.marketplace.innerHTML = ""
    const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}
    function addWorld(name, version, size, id, edited) {
			let div = doc.createElement("div")
			div.className = "world"
			div.onclick = e => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + name + "</strong>" + br
			
			if (edited){
				let str = (new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				}))
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			div.innerHTML += `${size.toLocaleString()} bytes used`
			
			window.marketplace.appendChild(div)
      
      superflat = false
      trees = true
      caves = true
      survival = false
		}
    let tempWorld = new World()
    marketplaceData.forEach(data => {
      let loadString, mod
      if(typeof data === "object"){
        loadString = data.loadString
        mod = data.mod
      }else loadString = data
      
      tempWorld.loadSave(loadString)
		  let now = Date.now()
			addWorld(tempWorld.name, tempWorld.version, loadString.length, now)
			marketplace[now] = {
				code: loadString,
				id: now,
        name: tempWorld.name,
        version: tempWorld.version,
        mod: mod,
			}
    })
    window.marketplace.onclick = Button.draw
  }
  function saveFromMarketplace(){
    let save = marketplace[selectedWorld]
    saveToDB(save.id, {
			id: save.id,
			edited: Date.now(),
			name: save.name,
			version: save.version,
			code: save.code,
      mod: save.mod
		})
    initWorldsMenu()
    changeScene("loadsave menu")
  }
  
  var sounds = {
    click: "click.ogg",
    damage: {
      bigfall: "damage/fallbig.ogg",
      smallfall: "damage/fallsmall.ogg",
      hit1: "damage/hit1.ogg",
      hit2: "damage/hit2.ogg",
      hit3: "damage/hit3.ogg"
    },
    block: {
      grass: {
        dig1: "grass/dig1.ogg",
        dig2: "grass/dig2.ogg",
        dig3: "grass/dig3.ogg",
        dig4: "grass/dig4.ogg",
        step1: "grass/step1.ogg",
        step2: "grass/step2.ogg",
        step3: "grass/step3.ogg",
        step4: "grass/step4.ogg",
        step5: "grass/step5.ogg",
        step6: "grass/step6.ogg",
      },
      stone: {
        dig1: "stone/dig1.ogg",
        dig2: "stone/dig2.ogg",
        dig3: "stone/dig3.ogg",
        dig4: "stone/dig4.ogg",
        step1: "stone/step1.ogg",
        step2: "stone/step2.ogg",
        step3: "stone/step3.ogg",
        step4: "stone/step4.ogg",
        step5: "stone/step5.ogg",
        step6: "stone/step6.ogg",
      },
      gravel: {
        dig1: "gravel/dig1.ogg",
        dig2: "gravel/dig2.ogg",
        dig3: "gravel/dig3.ogg",
        dig4: "gravel/dig4.ogg",
        step1: "gravel/step1.ogg",
        step2: "gravel/step2.ogg",
        step3: "gravel/step3.ogg",
        step4: "gravel/step4.ogg",
      },
      sand: {
        dig1: "sand/dig1.ogg",
        dig2: "sand/dig2.ogg",
        dig3: "sand/dig3.ogg",
        dig4: "sand/dig4.ogg",
        step1: "sand/step1.ogg",
        step2: "sand/step2.ogg",
        step3: "sand/step3.ogg",
        step4: "sand/step4.ogg",
        step5: "sand/step5.ogg",
      },
      basalt: {
        dig1: "basalt/dig1.ogg",
        dig2: "basalt/dig2.ogg",
        dig3: "basalt/dig3.ogg",
        dig4: "basalt/dig4.ogg",
        dig5: "basalt/dig5.ogg",
        step1: "basalt/step1.ogg",
        step2: "basalt/step2.ogg",
        step3: "basalt/step3.ogg",
        step4: "basalt/step4.ogg",
        step5: "basalt/step5.ogg",
        step6: "basalt/step6.ogg",
      },
      chain: {
        dig1: "chain/dig1.ogg",
        dig2: "chain/dig2.ogg",
        dig3: "chain/dig3.ogg",
        dig4: "chain/dig4.ogg",
        step1: "chain/step1.ogg",
        step2: "chain/step2.ogg",
        step3: "chain/step3.ogg",
        step4: "chain/step4.ogg",
        step5: "chain/step5.ogg",
        step6: "chain/step6.ogg",
      },
      cloth: {
        dig1: "cloth/dig1.ogg",
        dig2: "cloth/dig2.ogg",
        dig3: "cloth/dig3.ogg",
        dig4: "cloth/dig4.ogg",
        step1: "cloth/step1.ogg",
        step2: "cloth/step2.ogg",
        step3: "cloth/step3.ogg",
        step4: "cloth/step4.ogg",
      },
      fungus: {
        dig1: "fungus/dig1.ogg",
        dig2: "fungus/dig2.ogg",
        dig3: "fungus/dig3.ogg",
        dig4: "fungus/dig4.ogg",
        dig5: "fungus/dig3.ogg",
        dig6: "fungus/dig4.ogg",
      },
      glass: {
        dig1: "glass/dig1.ogg",
        dig2: "glass/dig2.ogg",
        dig3: "glass/dig3.ogg",
      },
      lantern: {
        dig1: "lantern/dig1.ogg",
        dig2: "lantern/dig2.ogg",
        dig3: "lantern/dig3.ogg",
        dig4: "lantern/dig4.ogg",
        dig5: "lantern/dig5.ogg",
        dig6: "lantern/dig6.ogg",
        step1: "lantern/step1.ogg",
        step2: "lantern/step2.ogg",
        step3: "lantern/step3.ogg",
        step4: "lantern/step4.ogg",
        step5: "lantern/step5.ogg",
        step6: "lantern/step6.ogg",
      },
      nether_bricks: {
        dig1: "nether_bricks/dig1.ogg",
        dig2: "nether_bricks/dig2.ogg",
        dig3: "nether_bricks/dig3.ogg",
        dig4: "nether_bricks/dig4.ogg",
        dig5: "nether_bricks/dig5.ogg",
        dig6: "nether_bricks/dig6.ogg",
        step1: "nether_bricks/step1.ogg",
        step2: "nether_bricks/step2.ogg",
        step3: "nether_bricks/step3.ogg",
        step4: "nether_bricks/step4.ogg",
        step5: "nether_bricks/step5.ogg",
        step6: "nether_bricks/step6.ogg",
      },
      nether_ore: {
        dig1: "nether_ore/dig1.ogg",
        dig2: "nether_ore/dig2.ogg",
        dig3: "nether_ore/dig3.ogg",
        dig4: "nether_ore/dig4.ogg",
        step1: "nether_ore/step1.ogg",
        step2: "nether_ore/step2.ogg",
        step3: "nether_ore/step3.ogg",
        step4: "nether_ore/step4.ogg",
        step5: "nether_ore/step5.ogg",
      },
      nether_sprouts: {
        dig1: "nether_sprouts/dig1.ogg",
        dig2: "nether_sprouts/dig2.ogg",
        dig3: "nether_sprouts/dig3.ogg",
        dig4: "nether_sprouts/dig4.ogg",
        step1: "nether_sprouts/step1.ogg",
        step2: "nether_sprouts/step2.ogg",
        step3: "nether_sprouts/step3.ogg",
        step4: "nether_sprouts/step4.ogg",
        step5: "nether_sprouts/step5.ogg",
      },
      netherite: {
        dig1: "netherite/dig1.ogg",
        dig2: "netherite/dig2.ogg",
        dig3: "netherite/dig3.ogg",
        dig4: "netherite/dig4.ogg",
        step1: "netherite/step1.ogg",
        step2: "netherite/step2.ogg",
        step3: "netherite/step3.ogg",
        step4: "netherite/step4.ogg",
        step5: "netherite/step5.ogg",
        step6: "netherite/step6.ogg",
      },
      netherrack: {
        dig1: "netherrack/dig1.ogg",
        dig2: "netherrack/dig2.ogg",
        dig3: "netherrack/dig3.ogg",
        dig4: "netherrack/dig4.ogg",
        dig5: "netherrack/dig5.ogg",
        dig6: "netherrack/dig6.ogg",
        step1: "netherrack/step1.ogg",
        step2: "netherrack/step2.ogg",
        step3: "netherrack/step3.ogg",
        step4: "netherrack/step4.ogg",
        step5: "netherrack/step5.ogg",
        step6: "netherrack/step6.ogg",
      },
      netherwart: {
        dig1: "netherwart/dig1.ogg",
        dig2: "netherwart/dig2.ogg",
        dig3: "netherwart/dig3.ogg",
        dig4: "netherwart/dig4.ogg",
        dig5: "netherwart/dig5.ogg",
        dig6: "netherwart/dig6.ogg",
        step1: "netherwart/step1.ogg",
        step2: "netherwart/step2.ogg",
        step3: "netherwart/step3.ogg",
        step4: "netherwart/step4.ogg",
        step5: "netherwart/step5.ogg",
      },
      nylium: {
        dig1: "nylium/dig1.ogg",
        dig2: "nylium/dig2.ogg",
        dig3: "nylium/dig3.ogg",
        dig4: "nylium/dig4.ogg",
        dig5: "nylium/dig5.ogg",
        dig6: "nylium/dig6.ogg",
        step1: "nylium/step1.ogg",
        step2: "nylium/step2.ogg",
        step3: "nylium/step3.ogg",
        step4: "nylium/step4.ogg",
        step5: "nylium/step5.ogg",
        step6: "nylium/step6.ogg",
      },
      roots: {
        dig1: "roots/dig1.ogg",
        dig2: "roots/dig2.ogg",
        dig3: "roots/dig3.ogg",
        dig4: "roots/dig4.ogg",
        dig5: "roots/dig5.ogg",
        dig6: "roots/dig6.ogg",
        step1: "roots/step1.ogg",
        step2: "roots/step2.ogg",
        step3: "roots/step3.ogg",
        step4: "roots/step4.ogg",
        step5: "roots/step5.ogg",
      },
      shroomlight: {
        dig1: "shroomlight/dig1.ogg",
        dig2: "shroomlight/dig2.ogg",
        dig3: "shroomlight/dig3.ogg",
        dig4: "shroomlight/dig4.ogg",
        dig5: "shroomlight/dig5.ogg",
        step1: "shroomlight/step1.ogg",
        step2: "shroomlight/step2.ogg",
        step3: "shroomlight/step3.ogg",
        step4: "shroomlight/step4.ogg",
        step5: "shroomlight/step5.ogg",
        step6: "shroomlight/step6.ogg",
      },
      soul_sand: {
        dig1: "soul_sand/dig1.ogg",
        dig2: "soul_sand/dig2.ogg",
        dig3: "soul_sand/dig3.ogg",
        dig4: "soul_sand/dig4.ogg",
        dig5: "soul_sand/dig5.ogg",
        dig6: "soul_sand/dig6.ogg",
        dig7: "soul_sand/dig7.ogg",
        dig8: "soul_sand/dig8.ogg",
        dig9: "soul_sand/dig9.ogg",
        step1: "soul_sand/step1.ogg",
        step2: "soul_sand/step2.ogg",
        step3: "soul_sand/step3.ogg",
        step4: "soul_sand/step4.ogg",
        step5: "soul_sand/step5.ogg",
      },
      stem: {
        dig1: "stem/dig1.ogg",
        dig2: "stem/dig2.ogg",
        dig3: "stem/dig3.ogg",
        dig4: "stem/dig4.ogg",
        dig5: "stem/dig5.ogg",
        dig6: "stem/dig6.ogg",
        step1: "stem/step1.ogg",
        step2: "stem/step2.ogg",
        step3: "stem/step3.ogg",
        step4: "stem/step4.ogg",
        step5: "stem/step5.ogg",
        step6: "stem/step6.ogg",
      },
      wood: {
        dig1: "wood/dig1.ogg",
        dig2: "wood/dig2.ogg",
        dig3: "wood/dig3.ogg",
        dig4: "wood/dig4.ogg",
        step1: "wood/step1.ogg",
        step2: "wood/step2.ogg",
        step3: "wood/step3.ogg",
        step4: "wood/step4.ogg",
        step5: "wood/step5.ogg",
        step6: "wood/step6.ogg",
      },
      anvil: {
        land: "random/anvil_land.ogg"
      },
    },
    entity: {
      generic: {
        explode1: "random/explode1.ogg",
        explode2: "random/explode2.ogg",
        explode3: "random/explode3.ogg",
        explode4: "random/explode4.ogg",
      },
      tnt: {
        fuse: "random/fuse.ogg"
      },
      item: {
        pickup: "random/plop.ogg"
      },
    },
    liquid:{
      enter: "liquid/enter.ogg",
      exit: "liquid/exit.ogg"
    },
  }
  var soundVolumes = {
    
  }
  win.sounds = sounds
  function loadSoundBuffer(url){
    return new Promise((resolve, reject) => {
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.onerror = reject

      request.onload = function() {
        audioCtx.decodeAudioData(request.response, function(buffer) {
          resolve(buffer)
        }, reject);
      }
      request.send();
    })
  }
  async function initAudioCtx(){
    try{
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
    }catch(e) {
      alert('Web Audio API is not supported in this browser');
      return
    }
    
    async function loadSoundsObj(obj){
      for(var i in obj){
        if(typeof obj[i] === "object"){
          loadSoundsObj(obj[i])
        }else{
          var url = "https://data.thingmaker.repl.co/sounds/"+obj[i]
          await loadSoundBuffer(url).then(buffer => {
            obj[i] = buffer
            loadDone()
          }).catch(() => {
            loadDone()
          })
        }
      }
    }
    loadSoundsObj(sounds)
  }
  function playSound(name, start, volume){ //from https://www.html5rocks.com/en/tutorials/webaudio/intro/
    if(!soundOn) return
    var sound
    var soundVol
    if(name.includes(".")){
      sound = sounds

      soundVol = settings.soundVolume
      name = name.split(".")
      for(var i=0; i<name.length; i++){
        var n = name[i]
        if(sound[n]){
          sound = sound[n]
        }else return
        if(soundVol[n]){soundVol = soundVol[n]}
      }
      if(!(soundVol || soundVol === 0)) soundVol = 1
    }else{
      sound = sounds[name]
      soundVol = soundVolumes[name]
      if(!(soundVol || soundVol === 0)) soundVol = 1
    }
    volume = settings.soundVolume/100
    var buffer = sound
    if(audioCtx && (typeof buffer !== "string")){
      var source = audioCtx.createBufferSource();
      source.buffer = buffer;
      if( (!(volume || volume === 0)) || volume === 1){
        source.connect(audioCtx.destination);
      }else{
        var gainNode = audioCtx.createGain();
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.value = volume;
      }
      source.start(start || 0);
    }
  }
  win.playSound = playSound
  function blockSound(blockID, type, x,y,z){
    var block = blockData[blockID]
    var volume = posSound(x,y,z)
    
    var sound
    switch(type){
      case "place":
        sound = block.placeSound || block.digSound
        break;
      case "dig":
        sound = block.digSound
        break;
      case "step":
        sound = block.stepSound
        break;
      case "breaking":
        sound = block.stepSound
        break;
      case "land":
        sound = block.landSound || block.digSound
    }
    if(Array.isArray(sound)){
      sound = sound[Math.floor(Math.random()*sound.length)]
    }
    if(sound){
      playSound(sound, 0, volume)
    }
  }
  win.blockSound = blockSound
  function hitSound(){
    var i = Math.ceil(Math.random()*3)
    playSound("damage.hit"+i)
  }
  win.hitSound = hitSound
  var explodeSounds = ["entity.generic.explode1", "entity.generic.explode2", "entity.generic.explode3", "entity.generic.explode4"]
  function explodeSound(x,y,z){
    var sound = explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
    playSound(sound, 0, posSound(x,y,z))
  }
  win.explodeSound = explodeSound
  function posSound(x,y,z){
    var volume = 1
    if((x || x===0) && (y || y===0) && (z || z===0)){
      var falloff = volume > 16 ? 16*volume : 16
      var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
      volume = dist > falloff ? volume - ((dist - falloff) / 10) : volume
      if(volume < 0) volume = 0
    }
    return volume
  }
  
  let maxHTTPLoad = 0, loaded = 0
  win.allLoaded = false
  function findObjValueAmount(obj){
    for(var i in obj){
      if(typeof obj[i] === "object"){
        findObjValueAmount(obj[i])
      }else maxHTTPLoad ++
    }
  }
  findObjValueAmount(sounds)
  loadProg.innerHTML = `Loading 0% 0/${maxHTTPLoad}`
  function loadDone(){
    loaded ++
    let percent = Math.floor(loaded * 100 / maxHTTPLoad)
    loadProg.innerHTML = `Loading ${percent}% ${loaded}/${maxHTTPLoad}`
    if(loaded === maxHTTPLoad){
      loader.classList.add("hidden")
      allLoaded = true
    }
  }
  
  function createNewWorld(){
      dimensions = {
        overworld: new World(),
        nether: new World("nether")
      }
			world = dimensions.overworld
			world.id = Date.now()
			let name = boxCenterTop.value || "World"
			let number = ""
			while(true) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				} else {
					name = name + number
					break
				}
			}
			world.name = name.replace(/;/g, "\u037e")
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)

      if(survival) setHotbar([blockIds.craftingTable,0,0,0,0,0,0,0,0])
			changeScene("loading")
  }
	
	function initEverything() {
		console.log("Initializing world.")

		setSeed(Math.random() * 2000000000 | 0)
    console.log("worldSeed "+worldSeed)

    win.islandGenerator = new Generator();
    
		generatedChunks = 0

    crack.shape = shapes.cube

		initWebgl()
    constVersion(version)
    initPlayer()
    fetch("https://server.thingmaker.repl.co/getuser",{credentials:'include'}).then(r => r.text()).then(r => {
      username = r || "You"
      p.character.changeBlock(abs( (r || "").hashCode()) % 80 + 1)
    })

		message.innerHTML = ".>a/<etisbew ym>'oc.lper.rekamgniht.www//:sptth'=ferh a< tuo kcehc oslA>rb<>a/<etisbew s'draliW no nahKeniM ot kniL>'nahkenim/nuf.dralliw//:sptth'=ferh a<>rb<.>a<etisbew s'dralliW>'nuf.dralliw//:sptth'=ferh a< tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>\"wen_\"=tegrat \"8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth\"=ferh a< fo>rb<ffo-nips a si margorp sihT".split("").reverse().join("")
    
    crack.entity = new crackEntity("crack1",0,0,0)
    for(var i=0; i<crack.length; i++){crack.entity.cacheTexture(crack[i])}

		initBackgrounds()
		
		drawScreens[screen]()
		Button.draw()
		Slider.draw()

		p.FOV(settings.fov)
		initWorldsMenu()
    initMarketplace()
		initButtons()
    
    initAudioCtx()
    
    // See if a user followed a link here.
		if (urlParams.has("target")) {
			changeScene("multiplayer menu")
			initMultiplayer(urlParams.get("target"))
		}
    if (urlParams.has("changeScene") && drawScreens[urlParams.get("changeScene")]) {
			changeScene(urlParams.get("changeScene"))
		}
	}

	// Define all the scene draw functions
  let clear,dirt,nether
	(function() {
    var splashs = [
      "Multiplayer!",
      "Survival!",
      "Flowers? Make a garden!",
      "Also go to my website:\nwww.thingmaker.repl.co",
      "Nether!",
      "Can't break bedrock.",
      "Chat with a slash!",
      "Watch out from\nthe falling sand!",
      "Hard Parkour!",
      "MineKhan is on youtube!",
      "Original by Willard.",
      "Log => 4 planks\n2 Planks => 4 sticks\n1 stick + 1 coal\n=\ntorch",
      "Annoying cactus!",
      "Nice looking flowers.",
      "I like watermelon.",
      "Have you played\nMinecraft?",
      "So, you read splash text.",
      document.documentElement.outerHTML.split("\n").length+" lines of code.",
      "Island world type\nhas a volcano.",
      "Have you realized\npunching wood\nhurts your hand?",
      "Don't make a tnt\ncube over\nsomeone's mansion.",
      "Awesome!",
      "Fun!",
      "Build!",
      "Mine!",
      "Craft!",
      "Would you like a potion of fun?",
      "Falling anvils are\neven more annoying\nthan sand!",
      "No tnt!!!",
      "Don't mess\naround with\nuranium!!!",
      "Why does my\nhouse have a\nhole in the\nroof???",
      "www.thingmaker.repl.co",
      "§1C§2o§3l§4o§5r§6m§7a§8t§9i§ac",
      "Using WebGL!",
      "Who has awesome hair?",
      "Supercalifragilisticexpialidocious!",
      "Really really fun!",
      "Not kidding",
      "Punch diamonds!",
      "Very long useless text,\nglorbouirewsoytuderkoilsykrojeticfilistikmensuiklit",
      "Play for 10 hours!",
      "Also try VVVVVV!",
      "Also try Super Meat Boy!",
      "Also try Terraria!",
      "Also try Mount And Blade!",
      "Also try Project Zomboid!",
      "Also try World of Goo!",
      "Also try Limbo!",
      "Also try Pixeljunk Shooter!",
      "Also try Braid!",
      "Why are you reading this???",
      "Really. You read\n splash text.",
      "Umm... Why are\nthe trees floating?",
      "No robots",
      "Kick 'em up!",
      "Gotta eat some soup!",
      "Disgusting soup.",
      "This is a very\ncool splash."
    ]
    let splash = ""
    function rdmSplash(){
      splash = splashs[Math.floor(Math.random()*splashs.length)]
    }
    win.rdmSplash = rdmSplash
    win.setSplash = function(s){
      splash = splashs[s]
    }
    rdmSplash()
    setInterval(() => rdmSplash(), 60000)
		function drawTitle() {
			let title = "MINEKHAN"
			let subtext = "JAVASCRIPT EDITION"
			let font = "VT323,monospace"
			strokeWeight(1)
			ctx.textAlign = 'center'

			ctx.font = "bold 120px " + font
			fill(/*30*/70)
			text(title, width / 2, 158)
			//fill(40)
			text(title, width / 2, 155)
			ctx.font = "bold 121px " + font
			//fill(50)
			text(title, width / 2, 152)
			//fill(70)
			text(title, width / 2, 150)
			//fill(90)
			ctx.font = "bold 122px " + font
			text(title, width / 2, 148)
			fill(110)
			text(title, width / 2, 145)

			ctx.font = "bold 32px " + font
			fill(50)
			text(subtext, width / 2-1, 180)
			text(subtext, width / 2+1, 180)
			text(subtext, width / 2, 179)
			text(subtext, width / 2, 181)
			ctx.font = "bold 32px " + font
			fill(150)
			text(subtext, width / 2, 180)
      
      fill(230,220,0)
			ctx.translate(width/2 + 280,170)
			ctx.rotate(-Math.PI/8);
      var s = (size/40)*6+30
			ctx.font = "bold "+s+"px " + font
			text(splash, 0,0, s)
			ctx.rotate(Math.PI/8);
			ctx.translate(-(width/2+280),-170)
		}
    clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
    dirt = () => ctx.putImageData(dirtbg, 0, 0)
    nether = () => ctx.putImageData(netherbg, 0, 0)

    var size = 0
    var sizes = 0
    var sizess = 1
		drawScreens["main menu"] = () => {
      clear()
      sizes += sizess
      if((sizes > 5) || (sizes < -5)){
        sizess = -sizess
      }
      size += sizes
			drawTitle()
			fill(220)
			ctx.font = "20px VT323"
			ctx.textAlign = 'left'
			text("MineKhan " + version, width - (width - 2), height - 2)
		}

		drawScreens.play = () => {
      ctx2.clearRect(0,0,width,height)
      
      for(var i=0; i<9; i++){
        if(inventory.hotbar[i].id && inventory.hotbar[i].amount < 1){
          inventory.hotbar[i] = 0
          holding = inventory.hotbar[inventory.hotbarSlot].id
          updateHUD = true
        }
      }
      
      standingOn = world.getBlock(p2.x,p2.y-2,p2.z)
      
			controls()
			runGravity()
      
      if(survival){
        cracks()
      }
      var now = Date.now()
      if(witherEffect>0){
        witherEffect --;
        if(survival && now-lastBlockHarm > witherTime){
          lastBlockHarm = now
          p.health -= witherDamage
          harmEffect = 40
          hitSound()
          dieMessage = username+" got withered. Ew."
          updateHUD = true;
        }
      }
      
      if(now - lastHeal > healTime) {
        lastHeal = now
        if(p.health < 18){
          p.health += 1
          healEffect = 40
          updateHUD = true
        }
      }
      var blockHere = world.getBlock(p2.x, p2.y, p2.z)
      var blockAtFeet = world.getBlock(p2.x, p2.y-1, p2.z)
      if(!p.flying && Key[" "] && ((blockHere && blockData[blockHere].ladder) || (blockAtFeet && blockData[blockAtFeet].ladder))){
        p.velocity.y = 0
        p.y += 0.04
      }
      if(survival){
        if(liquid && blockHere === blockIds.Water){
          if(p.oxygen > 0){
            if(now - lastLoseOxygen > 1000){
              p.oxygen --
              lastLoseOxygen = now
              updateHUD = true
            }
          }else{
            if(now-lastBlockHarm > 500){
              lastBlockHarm = now
              p.health -= 1
              harmEffect = 40
              hitSound()
              dieMessage = username+" drowned."
              updateHUD = true;
            }
          }
        }else if(p.oxygen < 18 && now - lastGetOxygen > 300){
          lastGetOxygen = now
          p.oxygen = (Math.floor(p.oxygen/2)*2) + 2
          updateHUD = true
        }
      }
			if(p.health > 18) {
			  p.health = 18;
			}
      if(p.oxygen > 18) {
			  p.oxygen = 18;
			}
      
      if(harmEffect > 0){
        harmEffect --
        updateHUD = true
      }
      if(healEffect > 0){
        healEffect --
        updateHUD = true
      }
      
			resolveContactsAndUpdatePosition(now)

			if (updateHUD) {
				clear()
				gl.clearColor(0, 0, 0, 0)
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
				hud()
				ctx.drawImage(gl.canvas, 0, 0)
				updateHUD = false
				freezeFrame = false

				gl.clearColor(sky[0], sky[1], sky[2], 1.0)
			}
			defineWorld()
      
      if(harmEffect > 0){
        fill(255,0,0, harmEffect)
        ctx.fillRect(0,0,width,height)
      }
      if(portalEffect > 0){
        fill(255,0,255, portalEffect)
        ctx.fillRect(0,0,width,height)
        updateHUD = true
        portalEffect --
      }
      
      if(mouseDown && touchScreen){
			  ctx.beginPath()
        fill(255)
        strokeWeight(2)
        ellipse(pTouch.x, pTouch.y, 70,70)
        ctx.stroke()
        updateHUD=true
      }
      
      if(survival)ctx.drawImage(canvas2,0,0)
      
      if(p.health < 1){
        die()
        
        drawScreens.dead()
        Button.draw()
        Slider.draw()
      }
      
      if(titleOpacity > 0){
        titleOpacity --
        let alpha = titleOpacity/100
        ctx.font = "80px VT323"
        ctx.textAlign = "center"
        ctx.fillStyle = titleColor
        ctx.globalAlpha = alpha > 1 ? 1 : alpha
        text(title, width/2, height/2, 80)
        if(subtitle){
          ctx.font = "40px VT323"
          text(subtitle, width/2, height/2+50, 40)
        }
        ctx.globalAlpha = 1
        updateHUD = true
      }
      
      if((Key.w || Key.a || Key.s || Key.d) && p.onGround){
        let limit = 500
        if(p.sprinting) limit = 350
        if(now - lastStepSound > limit){
          lastStepSound = now
          blockSound(standingOn, "step")
        }
      }
		}

    drawScreens.dead = () => {
      ctx.drawImage(gl.canvas, 0, 0)
      
      ctx.fillStyle = "rgba(255,0,0,50%)"
      ctx.fillRect(0,0,width,height)
      
      fill(0)
      ctx.font = "50px Arial"
      ctx.textAlign = "center"
      ctx.fillText("You died", width/2, 100)
      
      ctx.font = "20px Arial"
      ctx.fillText(dieMessage, width/2, 140)
    }
    
		drawScreens.loading = () => {
      world = dimensions.overworld
			// This is really stupid, but it basically works by teleporting the player around to each chunk I'd like to load.
			// If chunks loaded from a save aren't generated, they're deleted from the save, so this loads them all.
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
            if (superflat === "island") {
                if (win.islandGenerator.stage < 10) {
                    if (!win.islandGenerator.seedSet) {
                        win.islandGenerator.SetSeed(noiseProfile.seed)
                    }
                    win.islandGenerator.Generate(frameStart);
                }   else {
                    let standing = true
        			if (world.loadFrom.length) {
        				let load = world.loadFrom[0]
        				p.x = load.x * 16
        				p.y = load.y * 16
        				p.z = load.z * 16
        				standing = false
        			} else {
        				p.x = p2.x
        				p.y = p2.y
        				p.z = p2.z
        
        				let cx = p.x >> 4
        				let cz = p.z >> 4
        
        				for (let x = cx - 1; x <= cx + 1; x++) {
        					for (let z = cz - 1; z <= cz + 1; z++) {
        						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
        							standing = false
        						} else {
        							sub++
        						}
        					}
        				}
        			}
        
        			if (standing) {
        				play()
        				return
        			}
			        world.tick()
                }
            }   else {
                let standing = true
    			if (world.loadFrom.length) {
    				let load = world.loadFrom[0]
    				p.x = load.x * 16
    				p.y = load.y * 16
    				p.z = load.z * 16
    				standing = false
    			} else {
    				p.x = p2.x
    				p.y = p2.y
    				p.z = p2.z
    
    				let cx = p.x >> 4
    				let cz = p.z >> 4
    
    				for (let x = cx - 1; x <= cx + 1; x++) {
    					for (let z = cz - 1; z <= cz + 1; z++) {
    						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
    							standing = false
    						} else {
    							sub++
    						}
    					}
    				}
    			}
    
    			if (standing) {
    				play()
    				return
    			}
		        world.tick()
          }

			let progress = Math.round( (superflat==="island"?50:100) * sub / maxLoad)
			if(superflat === "island")progress += Math.round((win.islandGenerator.stage/9.0+win.islandGenerator.h/win.islandGenerator.size*3/9)*50)
			
			dirt()
			fill(255)
			textSize(30)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}
    drawScreens.netherLoading = () => {
      world = dimensions.nether
			let frameStart = win.performance.now()+1
			let sub = maxLoad - world.loadFrom.length - 9
      let standing = true
      if (world.loadFrom.length) {
        let load = world.loadFrom[0]
        p.x = load.x * 16
        p.y = load.y * 16
        p.z = load.z * 16
        standing = false
      } else {
        p.x = p2.x
        p.y = p2.y
        p.z = p2.z

        let cx = p.x >> 4
        let cz = p.z >> 4

        for (let x = cx - 1; x <= cx + 1; x++) {
          for (let z = cz - 1; z <= cz + 1; z++) {
            if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
              standing = false
            } else {
              sub++
            }
          }
        }
      }

      if (standing) {
        play()
        return
      }
      world.tick()

			let progress = Math.round(100 * sub / maxLoad)
			
			nether()
			fill(255)
			textSize(30)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}

		drawScreens.inventory = drawInv
    
    drawScreens.crafting = drawCrafting

		drawScreens.pause = () => {
			strokeWeight(1)
			clear()
			ctx.drawImage(gl.canvas, 0, 0)

			textSize(60)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text("Paused", width / 2, 60)
		}

		drawScreens.options = () => {
			clear()
		}
		drawScreens["creation menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Create New World", width / 2, 20)
		}
		drawScreens["loadsave menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Select World", width / 2, 20)
		}
    drawScreens["multiplayer menu"] = () => {
      dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Select server", width / 2, 20)
    }
		drawScreens.editworld = dirt
    drawScreens.marketplace = () => {
      dirt()
      ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Marketplace", width / 2, 20)
    }
	})()

	// Give the font time to load and redraw the homescreen
	setTimeout(e => {
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}, 100)

	let debugMenu = false
	function gameLoop() {
		let frameStart = performance.now()
		if (!gl) {
			initEverything()
			releasePointer()
		}

    if(allLoaded){
      if(screen === "options"){
        if(previousScreen === "main menu"){
          if(analytics.frames % 2)renderMainBG()
        }
      }
      if(screen === "main menu"){
        if(analytics.frames % 2)renderMainBG()
        drawScreens[screen]()
        Button.draw()
        Slider.draw()
      }
      
      if (screen === "play" || screen === "loading" || screen === "netherLoading") {
        drawScreens[screen]()
        if(touchScreen && screen === "play") Button.draw()
      }
    }

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1)
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
			analytics.fps = round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate))
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
			analytics.frames = 0
			analytics.totalRenderTime = 0
			analytics.totalTickTime = 0
			analytics.totalFrameTime = 0
			analytics.worstFrameTime = 0
			analytics.lastUpdate = Date.now()
			updateHUD = true
		}

		analytics.frames++
		analytics.totalFrameTime += performance.now() - frameStart
		analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
		win.raf = requestAnimationFrame(gameLoop)
	}
	return gameLoop
}

var init = MineKhan()
if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf)
	console.log("Canceled", window.parent.raf)
}
init()


	</script>
    
    <script>
function hcyl(bottom, height, radius, id) {
    let radsq = radius * radius
    let innerRadsq = (radius - 1.2) * (radius - 1.2)
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq && d >= innerRadsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function cyl(bottom, height, radius, id) {
    let radsq = radius * radius
    height += bottom
    for (let x = -radius; x <= radius; x++) {
        for (let y = bottom; y < height; y++) {
            for (let z = -radius; z <= radius; z++) {
                let d = x * x + z * z
                if (d < radsq) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoid(w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
                }
            }
        }
    }
}

function sphereoidAt(X,Y,Z,w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d
    let w3 = (w - 1.5) * (w - 1.5)
    let h3 = (h - 1.5) * (h - 1.5)
    let d3 = (d - 1.5) * (d - 1.5)

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                let n2 = x * x / w3 + y * y / h3 + z * z / d3
                if (n < 1 && n2 >= 1) {
                    world.setBlock(X + x, Y + y, Z + z, id)
                }
            }
        }
    }
}
function ball(X,Y,Z,w, h, d, id) {
    let w2 = w * w
    let h2 = h * h
    let d2 = d * d

    for (let y = -h; y < h; y++) {
        for (let x = -w; x <= w; x++) {
            for (let z = -d; z <= d; z++) {
                let n = x * x / w2 + y * y / h2 + z * z / d2
                if (n < 1) {
                    world.setBlock(X + x, Y + y, Z + z, id)
                }
            }
        }
    }
}

function explode(x,y,z, r){
  /*world.setBlock(x,y,z,blockIds.air);
  for(var i=radius; i>0; i--){
    sphereoidAt(x,y,z,i,i,i, blockIds.air)
  }*/
  //ball(x,y,z,r,r,r,0)
  world.setBlock(x,y,z, 0)
  let w2 = r * r
  let h2 = w2
  let d2 = w2
  for (let Y = -r; Y < r; Y++) {
    for (let X = -r; X <= r; X++) {
      for (let Z = -r; Z <= r; Z++) {
        let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
        if (n < 1) {
          if(world.getBlock(X + x, Y + y, Z + z) === blockIds.tnt){
            blockData[blockIds.tnt].explode(X+x,Y+y,Z+z)
          }
          world.setBlock(X + x, Y + y, Z + z, 0)
        }
      }
    }
  }
  for(var i=0; i<world.entities.length; i++){
    var ent = world.entities[i]
    var dist = dist3(x,y,z, ent.x, ent.y, ent.z)
    if(dist <= r){
      ent.velx = ent.x - x; ent.velx = ((Math.sign(ent.velx)*r)-ent.velx)/10
      ent.vely = ent.y - y; ent.vely = ((Math.sign(ent.vely)*r)-ent.vely)/10
      ent.velz = ent.z - z; ent.velz = ((Math.sign(ent.velz)*r)-ent.velz)/10
    }
  }
  explodeSound(x,y,z)
}
function fall(x,y,z,b){
  if(world.getBlock(x,y-1,z)) return
  setTimeout(() => {
    world.setBlock(x,y,z, 0)
    world.addEntity(new BlockEntity(b, x,y,z, true))
  }, 100)
}
function blockParticles(block,x,y,z,amount){
  for(var i=0; i<amount; i++) world.particles.push(new BlockParticle(blockData[block].textures[2], x,y,z))
}

if (("serviceWorker" in navigator) && location.origin === "https://minekhan.thingmaker.repl.co") {
  window.addEventListener("load", function() {
    navigator.serviceWorker
      .register("/sw.js")
      .then(res => console.log("service worker registered"))
      .catch(err => console.log("service worker not registered", err))
  })
}
    </script>
	</body>
</html>
